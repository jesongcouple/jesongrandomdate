<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="theme-color" content="#ff4d6d" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- iOS í™ˆí™”ë©´ ì•„ì´ì½˜ì€ manifestë³´ë‹¤ apple-touch-iconì„ ìš°ì„ í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ -->
<link rel="apple-touch-icon" href="./apple-touch-icon.png" />
<!-- ë¸Œë¼ìš°ì € íƒ­ ì•„ì´ì½˜(ì„¤ì¹˜í˜• ì•„ì´ì½˜ê³¼ ë³„ê°œ) -->
<link rel="icon" href="./icon-192.png" type="image/png" sizes="192x192" />
<link rel="icon" href="./icon-512.png" type="image/png" sizes="512x512" />
<title>ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</title>
<style>
:root{--main:#ff4d6d;--bg:#fff0f3;--ink:#c9184a;--stageWpx:320px;--stageHpx:560px;--splashWpx:320px;--splashHpx:560px;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;font-family:-apple-system,system-ui,sans-serif;}
body{margin:0;background:var(--bg);}
.wrap{max-width:520px;margin:0 auto;padding:14px;}
.card{background:#fff;border:6px solid #ffccd5;border-radius:28px;padding:14px;box-shadow:0 14px 30px rgba(255,77,109,.18);}
.title{font-weight:900;color:var(--ink);font-size:20px;margin:0 0 14px;text-align:center;}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
input{flex:1;min-width:180px;padding:12px 14px;border-radius:18px;border:3px solid #ffccd5;font-size:16px;outline:none;text-align:center;}
button{padding:12px 16px;border:0;border-radius:999px;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:#fff;font-weight:900;font-size:16px;box-shadow:0 10px 18px rgba(255,77,109,.25);cursor:pointer;}
button:disabled{background:#ccc;box-shadow:none;cursor:default;}
.stageWrap{margin-top:12px;width:var(--stageWpx);height:var(--stageHpx);margin-left:auto;margin-right:auto;background:#fff8f9;border:2px solid #ffd6df;border-radius:22px;overflow:hidden;position:relative;}
.viewport{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;background:#fff8f9;position:relative;touch-action:none;}
.viewport{scrollbar-width:none;-ms-overflow-style:none;}
.viewport::-webkit-scrollbar{width:0;height:0;display:none;}

svg{display:block;}
.lineStroke{stroke-width:22;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;filter:drop-shadow(0 10px 14px rgba(0,0,0,.10));}
.lineInner{stroke:#fff;stroke-width:7;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;}
.connector{stroke:#ffb3c1;stroke-width:5;stroke-linecap:round;opacity:.75;fill:none;}
.label{font-size:12px;font-weight:900;fill:#c9184a;opacity:1;}
.stationDot{fill:#fff;stroke:var(--main);stroke-width:4;opacity:1;}
.token{filter:drop-shadow(0 10px 12px rgba(0,0,0,.16));}
.token circle,.token rect{fill:var(--main);stroke:#fff;stroke-width:4;}
#hudRect{fill:white;stroke:#ffccd5;stroke-width:4;opacity:.94;}
#confetti{position:absolute;inset:0;pointer-events:none;z-index:20;}

#resultOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;}
#resultBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
#resultBox{position:relative;width:min(360px,86vw);background:#fff;border-radius:24px;padding:22px 26px;text-align:center;border:4px solid #ffccd5;box-shadow:0 20px 40px rgba(255,77,109,.25);overflow:hidden;}
#resultCanvas{position:absolute;inset:0;pointer-events:none;z-index:2;}
#resultContent{position:relative;z-index:3;}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;display:none;background:rgba(0,0,0,.85);color:#fff;padding:12px 14px;border-radius:14px;font-weight:900;font-size:12px;line-height:1.35;}

/* --- Splash (tap -> loading -> reveal) --- */
#startOverlay{
  position:fixed;
  inset:0;
  z-index:100000;
  background:var(--bg);
  opacity:1;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0; /* ì¹´ë“œì²˜ëŸ¼ ì‘ê²ŒëŠ” ì•ˆ ë³´ì´ë˜, ìŠ¤í¬ë¡¤/ë„˜ì¹¨ ë°©ì§€ìš© ìµœì†Œ ì—¬ë°± */
  touch-action:manipulation;
  user-select:none;
}
#startOverlay.fadeOut{ opacity:0; transition:opacity .55s ease; }

.splashStage{
  width:var(--splashWpx);
  height:var(--splashHpx);
  border-radius:0;
  overflow:hidden;
  border:0;
  background:var(--bg);
  position:relative;
}
#splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
#tapHintWrap, #splashLoading{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  text-align:center;
  width:100%;
  padding:0 14px;
}
#tapHint{
  font-size:18px;
  font-weight:1000;
  letter-spacing:0.5px;
  color:rgba(255,255,255,.96);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  animation:tapPulse 1.05s ease-in-out infinite;
}
@keyframes tapPulse{
  0%{ transform:scale(.98); opacity:.55; }
  45%{ transform:scale(1.04); opacity:1; }
  100%{ transform:scale(.98); opacity:.55; }
}
#splashLoading{
  font-size:20px;
  font-weight:1000;
  letter-spacing:1px;
  color:rgba(255,255,255,.95);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  display:none;
  line-height:1;
}
#splashLoading.show{ display:block; }
#splashLoading .dots::after{ content:""; animation:dots 1.05s steps(4,end) infinite; }
#splashLoading .blink{ animation:blink 0.55s steps(2,end) infinite; }
@keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:.25} }
@keyframes dots{ 0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""} }
#startOverlay.loading #splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
@keyframes loadingZoom{ 0%{ transform:scale(1); filter:saturate(1.05); } 50%{ transform:scale(1.02); filter:saturate(1.15); } 100%{ transform:scale(1); filter:saturate(1.05); } }

/* --- Mini settings button & modal --- */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:800;
  font-size:17px;
  line-height:1;
  box-shadow:0 6px 12px rgba(255,77,109,.18);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
}
.miniBtn:active{ transform:translateY(1px) scale(.99); }

#settingsOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9000;
}
#settingsOverlay.show{ display:flex; }
#settingsBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
}
#settingsBox{
  border:3px solid #ffd6df;
  position:relative;
  width:min(380px, 88vw);
  background:#fff;
  border-radius:24px;
  padding:20px 22px 18px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.settingsTitle{
  font-weight:1000;
  font-size:16px;
  color:#d6336c;
  text-align:center;
  margin-bottom:14px;
}
.settingsRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 6px;
  border-radius:18px;
  background:#fff8f9;
  border:3px solid #ffccd5;
  margin-bottom:10px;
}
.settingsLabel{
  font-weight:900;
  font-size:13px;
  color:#d6336c;
  white-space:nowrap;
}
.stepper{
  display:flex;
  align-items:center;
  gap:8px;
}
.numInput{
  width:84px;
  min-width:84px;
  padding:10px 10px;
  border-radius:14px;
  border:2px solid #ffd6df;
  font-weight:1000;
  font-size:16px;
  text-align:center;
  outline:none;
}
.stepBtn{
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:16px;
  line-height:1;
  box-shadow:0 10px 18px rgba(255,77,109,.18);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
}
.stepBtn:active{ transform:translateY(1px) scale(.99); }

.settingsHint{
  margin:8px 2px 14px;
  font-weight:900;
  font-size:12px;
  color:#ff4d6d;
  text-align:center;
  opacity:.92;
}
.settingsActions{
  display:flex;
  justify-content:center;
  gap:10px;
}
.ghostBtn{
  padding:10px 16px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:#fff0f3;
  color:#d6336c;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
}
.solidBtn{
  padding:10px 18px;
  border-radius:999px;
  border:0;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
}


/* === Visual viewport height var (mobile Safari fix) === */
:root{ --vvh: 1vh; }
#startOverlay{ height: calc(var(--vvh) * 100); }
#splashStage{ height: calc(var(--vvh) * 100); width: 100%; }


/* === Settings UI tone override (softer) === */
.miniBtn{
  width:40px !important;
  height:40px !important;
  border-radius:12px !important;
  border:2px solid #ffd6df !important;
  background: rgba(255,240,243,.92) !important;
  color:#c9184a !important;
  box-shadow:0 6px 12px rgba(201,24,74,.12) !important;
  font-weight:900 !important;
}
.miniBtn:hover{ filter:none !important; }
.stepBtn{
  border:2px solid #ffd6df !important;
  background: linear-gradient(135deg,#ff8fa3,#ffb3c1) !important;
  box-shadow:0 6px 12px rgba(201,24,74,.10) !important;
}
#settingsBox{
  border:3px solid #ffd6df !important;
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 4px 8px rgba(201,24,74,.16),
    inset 0 1px 0 rgba(255,255,255,.7) !important;
}


/* === Mobile splash: fill the whole screen (no side gaps) === */
@media (max-width: 700px){
  #startOverlay{ padding:0 !important; }
  .splashStage{ width:100vw !important; height:calc(var(--vvh) * 100) !important; }
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}


/* === Settings button: deep pink 3D === */
.miniBtn{
  background: linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  border:2px solid #ffb3c1 !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}





/* === Settings button redraw (border + 3D, no mismatch) === */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:46px;
  height:46px;
  border-radius:16px;
  border:0 !important;
  background: linear-gradient(180deg,#ff7a9b 0%, #ff3d66 100%) !important;
  color:#fff !important;
  font-weight:900;
  font-size:18px;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
  box-shadow: 0 12px 18px rgba(201,24,74,.22);
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:16px;
  box-shadow:
    inset 0 0 0 3px rgba(255,204,213,.95),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.14);
  pointer-events:none;
}
.miniBtn::after{
  content:"";
  position:absolute;
  inset:4px;
  border-radius:12px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%);
  pointer-events:none;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98);
  box-shadow: 0 8px 12px rgba(201,24,74,.20);
}
@media (max-width:700px){
  .miniBtn{ right: calc(10px + env(safe-area-inset-right)); bottom: calc(10px + env(safe-area-inset-bottom)); }
}


/* === Settings button border redraw (perfect match) === */
.miniBtn{
  position:absolute !important;
  right:10px !important;
  bottom:10px !important;
  width:46px !important;
  height:46px !important;
  border-radius:16px !important;
  border:none !important;            /* border drawn by ::before */
  background:linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  cursor:pointer !important;
  z-index:30 !important;
  padding:0 !important;
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  border:3px solid rgba(255,204,213,.95);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    0 0 0 1px rgba(255,204,213,.15);
  pointer-events:none;
}
.miniBtn:active{
  transform:translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}



/* === Pan extra space: allow camera to truly center token (top+bottom) === */
#panTopPad{ height:120px; width:1px; }
#panBottomPad{ height:900px; width:1px; }


.row{position:relative;z-index:50;}


/* Hide native number input spinners (use our icon buttons instead) */
.numInput::-webkit-outer-spin-button,
.numInput::-webkit-inner-spin-button{
  -webkit-appearance: none;
  margin: 0;
}
.numInput{
  -moz-appearance: textfield;
  appearance: textfield;
}
</style>
</head>

<body>

<!-- Splash -->
<div id="startOverlay" aria-label="ì‹œì‘ í™”ë©´" role="button" tabindex="0">
  <div class="splashStage">
    <img id="splashImg" src="./splash-bg.png" alt="ì œâ¤ï¸ì†¡ ëœë¤ë°ì´íŠ¸ ì‹œì‘ í™”ë©´" />
    <div id="tapHintWrap"><div id="tapHint">í™”ë©´ì„ í„°ì¹˜í•´ì£¼ì„¸ìš”</div></div>
    <div id="splashLoading" aria-live="polite"><span class="blink">ë¡œë”©ì¤‘</span><span class="dots"></span></div>
  </div>
</div>

<!-- Game UI -->
<div class="wrap">
  <div class="card">
    <h1 class="title">ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</h1>
    <div class="row">
      <input id="startInput" inputmode="text" autocomplete="off" spellcheck="false" placeholder="ì¶œë°œì—­ (ì˜ˆ: í˜œí™”)" />
      <button id="goBtn">ì¶œë°œ</button>
    </div>

    <div class="stageWrap">
      <div class="viewport" id="viewport">
        <div id="panTopPad" aria-hidden="true"></div>
        <svg id="map">
          <g id="mapShift">
          <g id="gLines"></g>
          <g id="gDots"></g>

          <!-- HUD -->
          <g id="hudG">
            <rect id="hudRect" x="-120" y="-40" rx="16" ry="16" width="240" height="74"></rect>
            <text id="hudLine1" x="0" y="-12" text-anchor="middle" dominant-baseline="middle" font-size="14" font-weight="900" fill="#c9184a">-</text>
            <text id="hudLine2" x="0" y="12" text-anchor="middle" dominant-baseline="middle" font-size="12" font-weight="900" fill="#ff4d6d">-</text>
          </g>

          <!-- Token -->
          <g id="token" class="token">
            <!-- head + body (refined) -->
            <circle cx="0" cy="-14" r="9"></circle>
            <rect x="-10" y="-2" width="20" height="24" rx="6" ry="6"></rect>
          </g>
                  </g>
        </svg>
        <div id="panBottomPad" aria-hidden="true"></div>
      </div>
      <canvas id="confetti"></canvas>

      <!-- Settings button (bottom-right) -->
      <button id="settingsBtn" class="miniBtn" type="button" aria-label="ì´ë™ ì •ê±°ì¥ ì„¤ì •">âš™ï¸</button>
    </div>
  </div>
</div>

<!-- Settings overlay -->
<div id="settingsOverlay" aria-hidden="true">
  <div id="settingsBackdrop"></div>
  <div id="settingsBox" role="dialog" aria-modal="true" aria-label="ì´ë™ ì •ê±°ì¥ ì„¤ì •">
    <div class="settingsTitle">ì´ë™ ì •ê±°ì¥ ì„¤ì •</div>

    <div class="settingsRow">
      <div class="settingsLabel">ìµœì†Œ ì´ë™ì—­</div>
      <div class="stepper">
        <button type="button" class="stepBtn" data-step="min" data-delta="-1" aria-label="ìµœì†Œ ê°ì†Œ">â–¾</button>
        <input id="minStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" />
        <button type="button" class="stepBtn" data-step="min" data-delta="1" aria-label="ìµœì†Œ ì¦ê°€">â–´</button>
      </div>
    </div>

    <div class="settingsRow">
      <div class="settingsLabel">ìµœëŒ€ ì´ë™ì—­</div>
      <div class="stepper">
        <button type="button" class="stepBtn" data-step="max" data-delta="-1" aria-label="ìµœëŒ€ ê°ì†Œ">â–¾</button>
        <input id="maxStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" / value="25">
        <button type="button" class="stepBtn" data-step="max" data-delta="1" aria-label="ìµœëŒ€ ì¦ê°€">â–´</button>
      </div>
    </div>
<div class="settingsActions">
      <button type="button" id="settingsCancel" class="ghostBtn">ì·¨ì†Œ</button>
      <button type="button" id="settingsOk" class="solidBtn">í™•ì¸</button>
    </div>
  </div>
</div>

<!-- Result overlay -->
<div id="resultOverlay">
  <div id="resultBackdrop"></div>
  <div id="resultBox">
    <canvas id="resultCanvas"></canvas>
    <div id="resultContent">
      <div style="font-size:13px;font-weight:900;color:#777;">ìµœì¢… ë„ì°©</div>
      <div id="resultStation" style="margin-top:6px;font-size:26px;font-weight:900;color:#d6336c;"></div>
      <div id="resultCount" style="margin-top:10px;font-size:15px;font-weight:900;color:#ff4d6d;"></div>
      <button id="searchBtn" style="margin-top:12px;padding:10px 16px;border-radius:999px;border:none;background:#fff0f3;color:#d6336c;font-weight:900;font-size:14px;cursor:pointer;border:2px solid #ffccd5;">ë°ì´íŠ¸ì½”ìŠ¤ ì•Œì•„ë³´ê¸°ğŸ”</button>
      <button id="closeBtn" style="margin-top:14px;padding:10px 16px;border-radius:999px;border:none;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:white;font-weight:900;font-size:14px;cursor:pointer;">í™•ì¸ â¤ï¸</button>
    </div>
  </div>
</div>

<div id="err"></div>

<script>
  const TRANSFER_SFX_URL = new URL('transfer-loop.mp3', window.location.href).href;

function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

// Persistent settings keys
const LAST_STATION_KEY = "jesong_last_station";
const MIN_STOPS_KEY = "jesong_min_stops";
const MAX_STOPS_KEY = "jesong_max_stops";
const DEFAULT_FIRST_STATION = "ì„œìš¸ì—­";


(function(){
  const errEl=document.getElementById('err');
  function showErr(msg){
    errEl.textContent=msg;
    errEl.style.display='block';
    clearTimeout(showErr.__t);
    showErr.__t=setTimeout(()=>{ errEl.style.display='none'; }, 3200);
  }
  window.addEventListener('error',(e)=>showErr('JS ì—ëŸ¬: '+(e.message||'unknown')));
  window.addEventListener('unhandledrejection',(e)=>showErr('Promise ì—ëŸ¬: '+(e.reason?.message||e.reason||'unknown')));  // Responsive stage sizing (game + splash)
  function setStageSize(){
    const vv=window.visualViewport;
    const vw=(vv&&vv.width)||window.innerWidth;
    const vh=(vv&&vv.height)||window.innerHeight;

    const card=document.querySelector('.card');
    const title=document.querySelector('.title');
    const row=document.querySelector('.row');

    const wrapPad = 28; // .wrap padding (14*2)
    const maxW = Math.min(520, (card ? (card.clientWidth - 28) : (vw - wrapPad)));

    const titleH = title ? title.getBoundingClientRect().height : 0;
    const rowH   = row   ? row.getBoundingClientRect().height   : 0;
    const chrome = 34;

    const availableH = vh - (titleH + rowH) - chrome - 18;
    const maxH = Math.min(980, Math.max(480, availableH));

    // Game: keep as-is (no scroll on web)
    const HEIGHT_FACTOR = 0.92;
    const w = Math.max(300, Math.min(maxW, maxW));
    const h = Math.max(420, Math.min(maxH, maxH * HEIGHT_FACTOR));    // Splash: ì‹œì‘í™”ë©´ì€ ìŠ¤í”Œë˜ì‹œ ì´ë¯¸ì§€ ë¹„ìœ¨(9:16)ì„ ìœ ì§€í•˜ë©´ì„œ,
    // ì›¹ì—ì„œ 'í° í™”ë©´ 1ëŒ€'ê°€ ì¤‘ì•™ì— í¬ê²Œ ë³´ì´ë„ë¡(ìŠ¤í¬ë¡¤ ì—†ì´) ê°€ëŠ¥í•œ í•œ í¬ê²Œ ë§ì¶˜ë‹¤.
    // â€» ê²Œì„ ë¹„ìœ¨ì„ ë”°ë¼ê°€ë©´ ì‹œì‘í™”ë©´ì´ ì˜†ìœ¼ë¡œ ë„“ì–´ì ¸ì„œ(=ê°€ë¡œ ê³¼í™•ëŒ€) ì—¬ê¸°ì„œëŠ” ì´ë¯¸ì§€ ë¹„ìœ¨ì„ ê³ ì •í•œë‹¤.
    const splashRatio = 16/9; // height / width (ìŠ¤í”Œë˜ì‹œ ì›ë³¸ ë¹„ìœ¨)
    // ëª¨ë°”ì¼ì—ì„œëŠ” ë¹ˆê³µê°„ ì—†ê²Œ 'ë³´ì´ëŠ” í™”ë©´(visual viewport)'ì„ ê½‰ ì±„ìš°ê²Œ í•¨
    let splashW, splashH;

    // Mobile: fill the visible viewport (no blanks)
    if (vw <= 700){
      splashW = vw;
      splashH = vh;
    } else {
      // Desktop/web: keep centered 'phone screen' frame
      splashH = Math.min(vh, maxH);
      splashW = splashH / splashRatio;
      if (splashW > maxW){
        splashW = maxW;
        splashH = splashW * splashRatio;
      }
    }

    const root=document.documentElement;
    root.style.setProperty('--stageWpx', w.toFixed(2)+'px');
    root.style.setProperty('--stageHpx', h.toFixed(2)+'px');
    root.style.setProperty('--splashWpx', splashW.toFixed(2)+'px');
    root.style.setProperty('--splashHpx', splashH.toFixed(2)+'px');
  }

  function min(a,b,c){ return Math.min(a,b,c); }

  window.addEventListener('resize', setStageSize, {passive:true});
  window.addEventListener('orientationchange', setStageSize, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', setStageSize, {passive:true});
  setStageSize();

  // Splash: tap -> loading -> reveal
  const splash=document.getElementById('startOverlay');
  const hintWrap=document.getElementById('tapHintWrap');
  const loadingWrap=document.getElementById('splashLoading');
  let splashStarted=false;

  function removeSplash(){
    if(!splash) return;
    splash.classList.add('fadeOut');
    setTimeout(()=>{ try{ splash.remove(); } catch(e){ splash.style.display='none'; } }, 600);
  }

  function beginSplashLoading(){
    if(!splash || splashStarted) return;
    splashStarted=true;
    // prevent double taps during loading but keep initial tap working
    splash.style.pointerEvents='none';
    splash.classList.add('loading');
    if(hintWrap) hintWrap.style.display='none';
    if(loadingWrap) loadingWrap.classList.add('show');

    // Give some action: subtle tick every 240ms
    let ticks=0;
    const iv=setInterval(()=>{ ticks++; if(ticks>12) clearInterval(iv); else { try{ playTick(); }catch(e){} } }, 240);

    setTimeout(()=>{
      try{ clearInterval(iv); }catch(e){}
      removeSplash();
      // After splash disappears (fadeOut 600ms), force-center on the token.
      scheduleInitialCenter();
      setTimeout(()=>{ try{ snapCameraToTokenNow(); }catch(e){} }, 650);
    }, 3000);
  }

  if(splash){
    // iOS/Safari reliability: use pointerdown/touchstart (click can be delayed or swallowed)
    const onSplashGesture = (e)=>{
      // prevent accidental scrolling / selection during splash tap
      try{ e.preventDefault(); }catch(err){}
      beginSplashLoading();
    };
    splash.addEventListener('pointerdown', onSplashGesture, {passive:false});
    splash.addEventListener('touchstart', onSplashGesture, {passive:false});
    splash.addEventListener('click', (e)=>{ try{ e.preventDefault(); }catch(err){} beginSplashLoading(); }, {passive:false});
    splash.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') beginSplashLoading(); });
  }

  const DATA = {"1í˜¸ì„ ":["ì—°ì²œ","ì „ê³¡","ì²­ì‚°","ì†Œìš”ì‚°","ë™ë‘ì²œ","ì§€í–‰","ë•ì •","ë•ê³„","ì–‘ì£¼","ë…¹ì–‘","ê°€ëŠ¥","ì˜ì •ë¶€","íšŒë£¡","ë§ì›”ì‚¬","ë„ë´‰ì‚°","ë„ë´‰","ë°©í•™","ì°½ë™","ë…¹ì²œ","ì›”ê³„","ê´‘ìš´ëŒ€","ì„ê³„","ì‹ ì´ë¬¸","ì™¸ëŒ€ì•","íšŒê¸°","ì²­ëŸ‰ë¦¬","ì œê¸°ë™","ì‹ ì„¤ë™","ë™ë¬˜ì•","ë™ëŒ€ë¬¸","ì¢…ë¡œ5ê°€","ì¢…ë¡œ3ê°€","ì¢…ê°","ì‹œì²­","ì„œìš¸ì—­","ë‚¨ì˜","ìš©ì‚°","ë…¸ëŸ‰ì§„","ëŒ€ë°©","ì‹ ê¸¸","ì˜ë“±í¬","ì‹ ë„ë¦¼","êµ¬ë¡œ","êµ¬ì¼","ê°œë´‰","ì˜¤ë¥˜ë™","ì˜¨ìˆ˜","ì—­ê³¡","ì†Œì‚¬","ë¶€ì²œ","ì¤‘ë™","ìƒë™","ì†¡ë‚´","ë¶€ê°œ","ë¶€í‰","ë°±ìš´","ë™ì•”","ê°„ì„","ì£¼ì•ˆ","ë„í™”","ì œë¬¼í¬","ë„ì›","ë™ì¸ì²œ","ì¸ì²œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ë…ì‚°","ê¸ˆì²œêµ¬ì²­","ì„ìˆ˜","ê´€ì•…","ì•ˆì–‘","ëª…í•™","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ì˜ì™•","ì„±ê· ê´€ëŒ€","í™”ì„œ","ìˆ˜ì›","ì„¸ë¥˜","ë³‘ì ","ì„¸ë§ˆ","ì˜¤ì‚°ëŒ€","ì˜¤ì‚°","ì§„ìœ„","ì†¡íƒ„","ì„œì •ë¦¬","í‰íƒì§€ì œ","í‰íƒ","ì„±í™˜","ì§ì‚°","ë‘ì •","ì²œì•ˆ","ë´‰ëª…","ìŒìš©","ì•„ì‚°","íƒ•ì •","ë°°ë°©","ì˜¨ì–‘ì˜¨ì²œ","ì‹ ì°½"],"2í˜¸ì„ ":["ì‹œì²­","ì„ì§€ë¡œì…êµ¬","ì„ì§€ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì‹ ë‹¹","ìƒì™•ì‹­ë¦¬","ì™•ì‹­ë¦¬","í•œì–‘ëŒ€","ëšì„¬","ì„±ìˆ˜","ê±´ëŒ€ì…êµ¬","êµ¬ì˜","ê°•ë³€","ì ì‹¤ë‚˜ë£¨","ì ì‹¤","ì ì‹¤ìƒˆë‚´","ì¢…í•©ìš´ë™ì¥","ì‚¼ì„±","ì„ ë¦‰","ì—­ì‚¼","ê°•ë‚¨","êµëŒ€","ì„œì´ˆ","ë°©ë°°","ì‚¬ë‹¹","ë‚™ì„±ëŒ€","ì„œìš¸ëŒ€ì…êµ¬","ë´‰ì²œ","ì‹ ë¦¼","ì‹ ëŒ€ë°©","êµ¬ë¡œë””ì§€í„¸ë‹¨ì§€","ëŒ€ë¦¼","ì‹ ë„ë¦¼","ë¬¸ë˜","ì˜ë“±í¬êµ¬ì²­","ë‹¹ì‚°","í•©ì •","í™ëŒ€ì…êµ¬","ì‹ ì´Œ","ì´ëŒ€","ì•„í˜„","ì¶©ì •ë¡œ","ìš©ë‹µ","ì‹ ë‹µ","ìš©ë‘","ì‹ ì„¤ë™","ë„ë¦¼ì²œ","ì–‘ì²œêµ¬ì²­","ì‹ ì •ë„¤ê±°ë¦¬","ê¹Œì¹˜ì‚°"],"3í˜¸ì„ ":["ëŒ€í™”","ì£¼ì—½","ì •ë°œì‚°","ë§ˆë‘","ë°±ì„","ëŒ€ê³¡","í™”ì •","ì›ë‹¹","ì›í¥","ì‚¼ì†¡","ì§€ì¶•","êµ¬íŒŒë°œ","ì—°ì‹ ë‚´","ë¶ˆê´‘","ë…¹ë²ˆ","í™ì œ","ë¬´ì•…ì¬","ë…ë¦½ë¬¸","ê²½ë³µê¶","ì•ˆêµ­","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ3ê°€","ì¶©ë¬´ë¡œ","ë™ëŒ€ì…êµ¬","ì•½ìˆ˜","ê¸ˆí˜¸","ì˜¥ìˆ˜","ì••êµ¬ì •","ì‹ ì‚¬","ì ì›","ê³ ì†í„°ë¯¸ë„","êµëŒ€","ë‚¨ë¶€í„°ë¯¸ë„","ì–‘ì¬","ë§¤ë´‰","ë„ê³¡","ëŒ€ì¹˜","í•™ì—¬ìš¸","ëŒ€ì²­","ì¼ì›","ìˆ˜ì„œ","ê°€ë½ì‹œì¥","ê²½ì°°ë³‘ì›","ì˜¤ê¸ˆ"],"4í˜¸ì„ ":["ì§„ì ‘","ì˜¤ë‚¨","ë³„ë‚´ë³„ê°€ëŒ","ë‹¹ê³ ê°œ","ìƒê³„","ë…¸ì›","ì°½ë™","ìŒë¬¸","ìˆ˜ìœ ","ë¯¸ì•„","ë¯¸ì•„ì‚¬ê±°ë¦¬","ê¸¸ìŒ","ì„±ì‹ ì—¬ëŒ€ì…êµ¬","í•œì„±ëŒ€ì…êµ¬","í˜œí™”","ë™ëŒ€ë¬¸","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì¶©ë¬´ë¡œ","ëª…ë™","íšŒí˜„","ì„œìš¸ì—­","ìˆ™ëŒ€ì…êµ¬","ì‚¼ê°ì§€","ì‹ ìš©ì‚°","ì´ì´Œ","ë™ì‘","ì´ì‹ ëŒ€ì…êµ¬","ì‚¬ë‹¹","ë‚¨íƒœë ¹","ì„ ë°”ìœ„","ê²½ë§ˆê³µì›","ëŒ€ê³µì›","ê³¼ì²œ","ì •ë¶€ê³¼ì²œì²­ì‚¬","ì¸ë•ì›","í‰ì´Œ","ë²”ê³„","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„"],"5í˜¸ì„ ":["ë°©í™”","ê°œí™”ì‚°","ê¹€í¬ê³µí•­","ì†¡ì •","ë§ˆê³¡","ë°œì‚°","ìš°ì¥ì‚°","í™”ê³¡","ê¹Œì¹˜ì‚°","ì‹ ì •","ëª©ë™","ì˜¤ëª©êµ","ì–‘í‰","ì˜ë“±í¬êµ¬ì²­","ì˜ë“±í¬ì‹œì¥","ì‹ ê¸¸","ì—¬ì˜ë„","ì—¬ì˜ë‚˜ë£¨","ë§ˆí¬","ê³µë•","ì• ì˜¤ê°œ","ì¶©ì •ë¡œ","ì„œëŒ€ë¬¸","ê´‘í™”ë¬¸","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì²­êµ¬","ì‹ ê¸ˆí˜¸","í–‰ë‹¹","ì™•ì‹­ë¦¬","ë§ˆì¥","ë‹µì‹­ë¦¬","ì¥í•œí‰","êµ°ì","ì•„ì°¨ì‚°","ê´‘ë‚˜ë£¨","ì²œí˜¸","ê°•ë™","ê¸¸ë™","êµ½ì€ë‹¤ë¦¬","ëª…ì¼","ê³ ë•","ìƒì¼ë™","ê°•ì¼","ë¯¸ì‚¬","í•˜ë‚¨í’ì‚°","í•˜ë‚¨ì‹œì²­","í•˜ë‚¨ê²€ë‹¨ì‚°","ë‘”ì´Œë™","ì˜¬ë¦¼í”½ê³µì›","ë°©ì´","ì˜¤ê¸ˆ","ê°œë¡±","ê±°ì—¬","ë§ˆì²œ"],"6í˜¸ì„ ":["ì‘ì•”","ì—­ì´Œ","ë…ë°”ìœ„","ì—°ì‹ ë‚´","êµ¬ì‚°","ìƒˆì ˆ","ì¦ì‚°","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ì›”ë“œì»µê²½ê¸°ì¥","ë§ˆí¬êµ¬ì²­","ë§ì›","í•©ì •","ìƒìˆ˜","ê´‘í¥ì°½","ëŒ€í¥","ê³µë•","íš¨ì°½ê³µì›ì•","ì‚¼ê°ì§€","ë…¹ì‚¬í‰","ì´íƒœì›","í•œê°•ì§„","ë²„í‹°ê³ ê°œ","ì•½ìˆ˜","ì²­êµ¬","ì‹ ë‹¹","ë™ë¬˜ì•","ì°½ì‹ ","ë³´ë¬¸","ì•ˆì•”","ê³ ë ¤ëŒ€","ì›”ê³¡","ìƒì›”ê³¡","ëŒê³¶ì´","ì„ê³„","íƒœë¦‰ì…êµ¬","í™”ë‘ëŒ€","ë´‰í™”ì‚°","ì‹ ë‚´"],"7í˜¸ì„ ":["ì¥ì•”","ë„ë´‰ì‚°","ìˆ˜ë½ì‚°","ë§ˆë“¤","ë…¸ì›","ì¤‘ê³„","í•˜ê³„","ê³µë¦‰","íƒœë¦‰ì…êµ¬","ë¨¹ê³¨","ì¤‘í™”","ìƒë´‰","ë©´ëª©","ì‚¬ê°€ì •","ìš©ë§ˆì‚°","ì¤‘ê³¡","êµ°ì","ì–´ë¦°ì´ëŒ€ê³µì›","ê±´ëŒ€ì…êµ¬","ëšì„¬ìœ ì›ì§€","ì²­ë‹´","ê°•ë‚¨êµ¬ì²­","í•™ë™","ë…¼í˜„","ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ë‚´ë°©","ì´ìˆ˜","ë‚¨ì„±","ìˆ­ì‹¤ëŒ€ì…êµ¬","ìƒë„","ì¥ìŠ¹ë°°ê¸°","ì‹ ëŒ€ë°©ì‚¼ê±°ë¦¬","ë³´ë¼ë§¤","ì‹ í’","ëŒ€ë¦¼","ë‚¨êµ¬ë¡œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ì² ì‚°","ê´‘ëª…ì‚¬ê±°ë¦¬","ì²œì™•","ì˜¨ìˆ˜","ê¹Œì¹˜ìš¸","ë¶€ì²œì¢…í•©ìš´ë™ì¥","ì¶˜ì˜","ì‹ ì¤‘ë™","ë¶€ì²œì‹œì²­","ìƒë™","ì‚¼ì‚°ì²´ìœ¡ê´€","êµ´í¬ì²œ","ë¶€í‰êµ¬ì²­","ìƒê°ˆ","ì‚°ê³¡","ì„ë‚¨"],"8í˜¸ì„ ":["ë³„ë‚´","ë‹¤ì‚°","ë™êµ¬ë¦‰","êµ¬ë¦¬","ì¥ìí˜¸ìˆ˜ê³µì›","ì•”ì‚¬ì—­ì‚¬ê³µì›","ì•”ì‚¬","ì²œí˜¸","ê°•ë™êµ¬ì²­","ëª½ì´Œí† ì„±","ì ì‹¤","ì„ì´Œ","ì†¡íŒŒ","ê°€ë½ì‹œì¥","ë¬¸ì •","ì¥ì§€","ë³µì •","ë‚¨ìœ„ë¡€","ì‚°ì„±","ë‚¨í•œì‚°ì„±ì…êµ¬","ë‹¨ëŒ€ì˜¤ê±°ë¦¬","ì‹ í¥","ì‹ ì´Œ","ìˆ˜ì§„","ëª¨ë€"],"9í˜¸ì„ ":["ê°œí™”","ê¹€í¬ê³µí•­","ê³µí•­ì‹œì¥","ì‹ ë°©í™”","ë§ˆê³¡ë‚˜ë£¨","ì–‘ì²œí–¥êµ","ê°€ì–‘","ì¦ë¯¸","ë“±ì´Œ","ì—¼ì°½","ì‹ ëª©ë™","ì„ ìœ ë„","ë‹¹ì‚°","êµ­íšŒì˜ì‚¬ë‹¹","ì—¬ì˜ë„","ìƒ›ê°•","ë…¸ëŸ‰ì§„","ë…¸ë“¤","í‘ì„","ë™ì‘","êµ¬ë°˜í¬","ì‹ ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ì‚¬í‰","ì‹ ë…¼í˜„","ì–¸ì£¼","ì„ ì •ë¦‰","ì‚¼ì„±ì¤‘ì•™","ë´‰ì€ì‚¬","ì¢…í•©ìš´ë™ì¥","ì‚¼ì „","ì„ì´Œê³ ë¶„","ì„ì´Œ","ì†¡íŒŒë‚˜ë£¨","í•œì„±ë°±ì œ","ì˜¬ë¦¼í”½ê³µì›","ë‘”ì´Œì˜¤ë¥œ","ì¤‘ì•™ë³´í›ˆë³‘ì›"],"ê²½ì˜ì¤‘ì•™ì„ ":["ë¬¸ì‚°","íŒŒì£¼","ì›”ë¡±","ê¸ˆì´Œ","ê¸ˆë¦‰","ìš´ì •","ì•¼ë‹¹","íƒ„í˜„","ì¼ì‚°","í’ì‚°","ë°±ë§ˆ","ê³¡ì‚°","ëŒ€ê³¡","ëŠ¥ê³¡","í–‰ì‹ ","ê°•ë§¤","í™”ì „","ìˆ˜ìƒ‰","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ê°€ì¢Œ","í™ëŒ€ì…êµ¬","ì„œê°•ëŒ€","ê³µë•","íš¨ì°½ê³µì›ì•","ìš©ì‚°","ì´ì´Œ","ì„œë¹™ê³ ","í•œë‚¨","ì˜¥ìˆ˜","ì‘ë´‰","ì™•ì‹­ë¦¬","ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","ì–‘ì›","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ë„ì‹¬","íŒ”ë‹¹","ìš´ê¸¸ì‚°","ì–‘ìˆ˜","ì‹ ì›","êµ­ìˆ˜","ì•„ì‹ ","ì˜¤ë¹ˆ","ì–‘í‰","ì›ë•","ìš©ë¬¸","ì§€í‰"],"ì‹ ë¶„ë‹¹ì„ ":["ì‹ ì‚¬","ë…¼í˜„","ì‹ ë…¼í˜„","ê°•ë‚¨","ì–‘ì¬","ì–‘ì¬ì‹œë¯¼ì˜ìˆ²","ì²­ê³„ì‚°ì…êµ¬","íŒêµ","ì •ì","ë¯¸ê¸ˆ","ë™ì²œ","ìˆ˜ì§€êµ¬ì²­","ì„±ë³µ","ìƒí˜„","ê´‘êµì¤‘ì•™","ê´‘êµ"],"ìˆ˜ì¸ë¶„ë‹¹ì„ ":["ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ì™•ì‹­ë¦¬","ì„œìš¸ìˆ²","ì••êµ¬ì •ë¡œë°ì˜¤","ê°•ë‚¨êµ¬ì²­","ì„ ì •ë¦‰","ì„ ë¦‰","í•œí‹°","ë„ê³¡","êµ¬ë£¡","ê°œí¬ë™","ëŒ€ëª¨ì‚°ì…êµ¬","ìˆ˜ì„œ","ë³µì •","ê°€ì²œëŒ€","íƒœí‰","ëª¨ë€","ì•¼íƒ‘","ì´ë§¤","ì„œí˜„","ìˆ˜ë‚´","ì •ì","ë¯¸ê¸ˆ","ì˜¤ë¦¬","ì£½ì „","ë³´ì •","êµ¬ì„±","ì‹ ê°ˆ","ê¸°í¥","ìƒê°ˆ","ì²­ëª…","ì˜í†µ","ë§í¬","ë§¤íƒ„ê¶Œì„ ","ìˆ˜ì›ì‹œì²­","ë§¤êµ","ìˆ˜ì›","ê³ ìƒ‰","ì˜¤ëª©ì²œ","ì–´ì²œ","ì•¼ëª©","ì‚¬ë¦¬","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ë‹¬ì›”","ì›”ê³¶","ì†Œë˜í¬êµ¬","ì¸ì²œë…¼í˜„","í˜¸êµ¬í¬","ë‚¨ë™ì¸ë”ìŠ¤íŒŒí¬","ì›ì¸ì¬","ì—°ìˆ˜","ì†¡ë„","í•™ìµ","ì¸í•˜ëŒ€","ìˆ­ì˜","ì‹ í¬","ì¸ì²œ"]};

  // Audio: NO BGM, only SFX
  let audioCtx=null, sfxGain=null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(!sfxGain){ sfxGain = audioCtx.createGain(); sfxGain.gain.value=0.18; sfxGain.connect(audioCtx.destination); }
  }
  function startBGM(){ ensureAudio(); }
  function playTick(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    const f=audioCtx.createBiquadFilter();
    o.type='square'; o.frequency.value=1500;
    f.type='bandpass'; f.frequency.value=1100; f.Q.value=9;
    g.gain.value=0.0001;
    o.connect(f).connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.18, now+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.06);
    o.stop(now+0.07);
    const o2=audioCtx.createOscillator();
    const g2=audioCtx.createGain();
    o2.type='sine'; o2.frequency.value=420;
    g2.gain.value=0.0001;
    o2.connect(g2).connect(sfxGain);
    o2.start(now+0.018);
    g2.gain.linearRampToValueAtTime(0.07, now+0.03);
    g2.gain.exponentialRampToValueAtTime(0.0001, now+0.16);
    o2.stop(now+0.17);
  }
  function playDing(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.type='sine'; o.frequency.value=880;
    g.gain.value=0.0001;
    o.connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.14, now+0.02);
    o.frequency.linearRampToValueAtTime(1175, now+0.14);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.42);
    o.stop(now+0.43);
  }
  function playFanfare(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const g=audioCtx.createGain();
    g.gain.value=0.0001;
    g.connect(sfxGain);
    const o1=audioCtx.createOscillator();
    const o2=audioCtx.createOscillator();
    o1.type='square'; o2.type='square';
    o1.connect(g); o2.connect(g);
    const seq=[523.25,659.25,783.99,1046.5];
    const dur=0.10;
    o1.start(now); o2.start(now);
    seq.forEach((f,i)=>{ o1.frequency.setValueAtTime(f, now+i*dur); o2.frequency.setValueAtTime(f*0.5, now+i*dur); });
    g.gain.linearRampToValueAtTime(0.18, now+0.02);
    g.gain.linearRampToValueAtTime(0.12, now+0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, now+seq.length*dur+0.12);
    o1.stop(now+seq.length*dur+0.15);
    o2.stop(now+seq.length*dur+0.15);
  }

  function formatStation(s){ s=String(s).trim().replace(/ì—­$/,''); return s+'ì—­'; }
  function normalizeName(s){ return String(s).trim().replace(/ì—­$/,'').replace(/\s+/g,''); }

  // Build line data (line-aware)
  function cleanLine(arr){
    const out=[];
    for(let i=0;i<arr.length;i++){
      const s=String(arr[i]).trim();
      if(!s) continue;
      if(out.length && out[out.length-1]===s) continue;
      out.push(s);
    }
    return out;
  }
  const subwayData={};
  const lineNames=Object.keys(DATA);
  for(const line of lineNames) subwayData[line]=cleanLine(DATA[line]);

  const lineIndex={};
  for(const line of lineNames){
    lineIndex[line]={};
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++) lineIndex[line][arr[i]]=i;
  }
  const stationLines=new Map();
  for(const line of lineNames){
    for(const st of subwayData[line]){
      if(!stationLines.has(st)) stationLines.set(st,new Set());
      stationLines.get(st).add(line);
    }
  }
  const getLinesOf=(st)=>stationLines.get(st)?Array.from(stationLines.get(st)):[];

  const getNextOnLine=(line,st,dir)=>{
    const idx=lineIndex[line][st];
    if(idx===undefined) return null;
    const arr=subwayData[line];
    const ni=idx+dir;
    if(ni<0||ni>=arr.length) return null;
    return arr[ni];
  };

  const allStations=Array.from(stationLines.keys());

  // Load saved movement settings
  try{
    const ms = parseInt(localStorage.getItem(MIN_STOPS_KEY)||'',10);
    const mx = parseInt(localStorage.getItem(MAX_STOPS_KEY)||'',10);
    if(Number.isFinite(ms)) minStops = Math.max(1, Math.min(99, ms));
    if(Number.isFinite(mx)) maxStops = Math.max(1, Math.min(99, mx));
    if(minStops>maxStops) [minStops,maxStops] = [maxStops,minStops];
  }catch(e){}


  // Layout (no x-averaging)
  const yStep=90, xStep=22, marginX=90, marginY=90;
  const pos=new Map();
  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const y=marginY + li*yStep;
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++){
      const st=arr[i];
      const x=marginX + i*xStep;
      pos.set(line+'::'+st, {x:x,y:y});
    }
  }

  // Draw SVG
  const viewport=document.getElementById('viewport');
  const map=document.getElementById('map');
  const gLines=document.getElementById('gLines');
  const gDots=document.getElementById('gDots');
  const token=document.getElementById('token');

  // --- Camera follow (stable): keep token centered without jitter (step-based + smoothing) ---
  const viewportEl = document.getElementById('viewport');

    let isAutoScroll = false;
// User can drag the view freely; after a short pause, camera returns to token center.
  if(viewportEl){
    const GRACE_MS = 1200; // time after last interaction before recenter
    const markUserPan = () => {
            if(isAutoScroll) return;
userPanUntil = Date.now() + GRACE_MS;
      if(recenterTimer) clearTimeout(recenterTimer);
      recenterTimer = setTimeout(() => {
        // Once user stops, snap back to token center (even if not animating)
        followTokenStable(true);
        setTimeout(()=>followTokenStable(true), 60);
      }, GRACE_MS + 20);
    };

    viewportEl.addEventListener('pointerdown', markUserPan, {passive:true});
    viewportEl.addEventListener('pointermove', markUserPan, {passive:true});
    window.addEventListener('pointerup', markUserPan, {passive:true});

    viewportEl.addEventListener('touchstart', markUserPan, {passive:true});
    viewportEl.addEventListener('touchmove', markUserPan, {passive:true});
    window.addEventListener('touchend', markUserPan, {passive:true});

    viewportEl.addEventListener('wheel', markUserPan, {passive:true});
    viewportEl.addEventListener('scroll', markUserPan, {passive:true});
  }

  let followPending = false;
  let userPanUntil = 0; // timestamp until which we don't auto-center (user is dragging)
  let recenterTimer = null;


  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  // Camera offset: user wants the person token to be **dead center**.
  const CAMERA_OFFSET_Y = 0;

  function scheduleInitialCenter(){
    // iOS Safari: run a few times after layout settles
    requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} });
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 120);
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 320);
  }

  // Snap camera to token immediately (used after teleport / after splash removal)
  function snapCameraToTokenNow(){
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }


  function followTokenStable(force){
    if(followPending) return;
    followPending = true;
    requestAnimationFrame(()=>{
      followPending = false;

      // overlays guard
      const startOverlayEl = document.getElementById('startOverlay');
      const settingsOverlayEl = document.getElementById('settingsOverlay');
      if(startOverlayEl){
        // While splash is fading out, allow camera to run so map becomes visible immediately.
        const cs = getComputedStyle(startOverlayEl);
        const fading = startOverlayEl.classList.contains('fadeOut');
        if(!fading && cs.display !== 'none' && cs.visibility !== 'hidden' && !startOverlayEl.classList.contains('hidden')) return;
      }


  // Snap camera to token immediately (useful right after setting station via input)
  function snapCameraToTokenNow(){
    // 2 frames only, once per teleport -> no noticeable stutter
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }
      if(settingsOverlayEl && settingsOverlayEl.classList.contains('show')) return;

      if(!viewportEl || !token) return;
      if(!force && Date.now() < userPanUntil) return;

      const vp = viewportEl.getBoundingClientRect();
      const tr = token.getBoundingClientRect();

      // token center in scroll-content coordinates
      const tokenCx = (tr.left - vp.left) + viewportEl.scrollLeft + tr.width/2;
      const tokenCy = (tr.top  - vp.top ) + viewportEl.scrollTop  + tr.height/2;

      const vpW = viewportEl.clientWidth;
      const vpH = viewportEl.clientHeight;

      const targetLeft = clamp(tokenCx - vpW/2, 0, viewportEl.scrollWidth - vpW);
      const targetTop  = clamp(tokenCy - vpH/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - vpH);

      isAutoScroll = true;
      viewportEl.scrollLeft = targetLeft;
      viewportEl.scrollTop  = targetTop;
      requestAnimationFrame(()=>{ isAutoScroll = false; });

      // one more settle frame for iOS timing
      requestAnimationFrame(()=>{
        const vp2 = viewportEl.getBoundingClientRect();
        const tr2 = token.getBoundingClientRect();
        const tokenCx2 = (tr2.left - vp2.left) + viewportEl.scrollLeft + tr2.width/2;
        const tokenCy2 = (tr2.top  - vp2.top ) + viewportEl.scrollTop  + tr2.height/2;
        const tL2 = clamp(tokenCx2 - viewportEl.clientWidth/2, 0, viewportEl.scrollWidth - viewportEl.clientWidth);
        const tT2 = clamp(tokenCy2 - viewportEl.clientHeight/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - viewportEl.clientHeight);
        isAutoScroll = true;
        viewportEl.scrollLeft = tL2;
        viewportEl.scrollTop  = tT2;
        requestAnimationFrame(()=>{ isAutoScroll = false; });
      });
    });
  }



  const hudG=document.getElementById('hudG');
  const HUD_OFFSET_Y = 68; // adjusted: closer to head, avoid clipping

  const hudLine1=document.getElementById('hudLine1');
  const hudLine2=document.getElementById('hudLine2');

  const LINE_COLORS={"1í˜¸ì„ ":"#1e88e5","2í˜¸ì„ ":"#2e7d32","3í˜¸ì„ ":"#f9a825","4í˜¸ì„ ":"#039be5","5í˜¸ì„ ":"#8e24aa","6í˜¸ì„ ":"#6d4c41","7í˜¸ì„ ":"#7b1fa2","8í˜¸ì„ ":"#d81b60","9í˜¸ì„ ":"#b59a00","ê²½ì˜ì¤‘ì•™ì„ ":"#00838f","ì‹ ë¶„ë‹¹ì„ ":"#c62828","ìˆ˜ì¸ë¶„ë‹¹ì„ ":"#f06292"};
  const lineColor=(n)=>LINE_COLORS[n]||"#ff4d6d";
  function svgEl(tag, attrs){
    const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  let maxLen=0;
  // Extra top padding so the token can be centered even when starting near the top lines.
  // (Otherwise scrollTop clamps to 0 and the token appears too low.)
  const PAD_TOP = 700;
  const PAD_BOTTOM = 900;
  const mapShift = document.getElementById('mapShift');
  for(const line of lineNames) maxLen=Math.max(maxLen, subwayData[line].length);
  const W=Math.max(1800, marginX + maxLen*xStep + 140);
  const H=Math.max(1100, marginY + lineNames.length*yStep + 140);
  map.setAttribute('width', String(W));
  map.setAttribute('height', String(H + PAD_TOP + PAD_BOTTOM));
  map.setAttribute('viewBox', '0 ' + (-PAD_TOP) + ' ' + W + ' ' + (H + PAD_TOP + PAD_BOTTOM));
  if(mapShift) mapShift.setAttribute('transform', 'translate(0,'+PAD_TOP+')');
for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const arr=subwayData[line];
    let d='';
    for(let i=0;i<arr.length;i++){
      const p=pos.get(line+'::'+arr[i]);
      d += (i===0 ? ('M '+p.x+' '+p.y) : (' L '+p.x+' '+p.y));
    }
    gLines.appendChild(svgEl('path', {d:d, class:'lineStroke', stroke: lineColor(line)}));
    gLines.appendChild(svgEl('path', {d:d, class:'lineInner'}));
    const label=svgEl('text', {x:'16', y:String(marginY + li*yStep + 5), class:'label'});
    label.textContent=line;
    gLines.appendChild(label);
  }

  stationLines.forEach((set, st)=>{
    const lines=Array.from(set);
    if(lines.length<2) return;
    const pts=[];
    for(const l of lines){ const p=pos.get(l+'::'+st); if(p) pts.push(p); }
    pts.sort((a,b)=>a.y-b.y);
    if(pts.length<2) return;
    let d='M '+pts[0].x+' '+pts[0].y;
    for(let i=1;i<pts.length;i++) d += ' L '+pts[i].x+' '+pts[i].y;
    gLines.appendChild(svgEl('path', {d:d, class:'connector'}));
  });

  stationLines.forEach((set, st)=>{
    if(set.size<2) return;
    for(const line of set){
      const p=pos.get(line+'::'+st);
      if(!p) continue;
      gDots.appendChild(svgEl('circle', {cx:String(p.x), cy:String(p.y), r:'4', class:'stationDot'}));
    }
  });

  // Drag-to-pan
  (function enableDragPan(){
    let isDown=false, startX=0, startY=0, sl=0, st=0;
    viewport.addEventListener('pointerdown',(e)=>{
      isDown=true; viewport.setPointerCapture(e.pointerId);
      startX=e.clientX; startY=e.clientY;
      sl=viewport.scrollLeft; st=viewport.scrollTop;
    });
    viewport.addEventListener('pointermove',(e)=>{
      if(!isDown) return;
      viewport.scrollLeft = sl - (e.clientX - startX);
      viewport.scrollTop  = st - (e.clientY - startY);
    });
    viewport.addEventListener('pointerup',()=>{ isDown=false; });
    viewport.addEventListener('pointercancel',()=>{ isDown=false; });
    // Set initial scroll so default view stays the same (but you can drag down to see more top)
})();

  // Confetti
  const confCanvas=document.getElementById('confetti');
  const confCtx=confCanvas.getContext('2d');
  function resizeCanvasTo(el, canvas, ctx){
    const r=el.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height};
  }
  function burstConfettiOn(canvas, ctx, w, h){
    if(canvas.__raf) cancelAnimationFrame(canvas.__raf);
    const colors=["#ff4d6d","#ff85a2","#ffd6e0","#c9184a","#ffb3c1","#ffe3ea"];
    const pieces=[];
    const count=190;
    for(let i=0;i<count;i++) pieces.push({x:w*0.5,y:h*0.32,vx:(Math.random()-0.5)*9,vy:-Math.random()*11-7,g:0.22+Math.random()*0.18,w:4+Math.random()*5,h:3+Math.random()*5,a:Math.random()*Math.PI,va:(Math.random()-0.5)*0.25,c:colors[Math.floor(Math.random()*colors.length)],life:0,max:170+Math.random()*70});
    function tick(){
      ctx.clearRect(0,0,w,h);
      let alive=0;
      for(const p of pieces){
        p.life++; if(p.life<p.max) alive++;
        p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.va;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.a);
        ctx.globalAlpha=Math.max(0,1-p.life/p.max);
        ctx.fillStyle=p.c;
        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }
      ctx.globalAlpha=1;
      if(alive>0) canvas.__raf=requestAnimationFrame(tick);
      else ctx.clearRect(0,0,w,h);
    }
    tick();
  }
  resizeCanvasTo(viewport, confCanvas, confCtx);
  window.addEventListener('resize', ()=>{ resizeCanvasTo(viewport, confCanvas, confCtx); });

  // Movement helpers
  // Camera policy (IMPORTANT):
  // - Person token must stay *dead center* of the map viewport.
  // - User can drag/pan anytime; while dragging we don't fight.
  // - After dragging ends, we gently return to token.
  // We reuse the existing followTokenStable() logic above to avoid conflicting camera systems.
  function setTokenXY(x,y, smooth){
    token.setAttribute('transform','translate('+x+','+y+')');
    hudG.setAttribute('transform','translate('+x+','+(y-HUD_OFFSET_Y)+')');

    // If smooth=false (snap moments like first render / arrival), force-center once.
    // Otherwise keep centering every frame (but do not fight the user while dragging).
    try{ followTokenStable(!smooth); }catch(e){}
  }

  function setTokenAt(line, st, smooth){
    const p=pos.get(line+'::'+st);
    if(!p) return;
    setTokenXY(p.x,p.y,smooth);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
  function moveSegment(lineA, stA, lineB, stB){
    const a=pos.get(lineA+'::'+stA);
    const b=pos.get(lineB+'::'+stB);
    if(!a||!b) return Promise.resolve();
    const d=dist(a,b);
    const duration=Math.max(240, Math.min(650, d*6.5));
    const start=performance.now();
    return new Promise(res=>{
      function tick(t){
        const p=Math.min(1,(t-start)/duration);
        const e=p<0.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
        setTokenXY(a.x+(b.x-a.x)*e, a.y+(b.y-a.y)*e, true);
        if(p<1) requestAnimationFrame(tick); else res();
      }
      requestAnimationFrame(tick);
    });
  }

  // Path generator: transfer only at interchange, stop at terminal, no reverse
  let minStops = 1;
  let maxStops = 25;
  
  // ------------------------------
  // Pathfinding (ìµœì  ê²½ë¡œ: ìµœì†Œ ì´ë™ì—­ + ë¶ˆí•„ìš” í™˜ìŠ¹ ìµœì†Œí™”)
  // ------------------------------
  // Build station adjacency (neighbors along each line)
  const stationNeighbors = new Map(); // station -> Set(neighborStation)
  lineNames.forEach(line => {
    const arr = subwayData[line];
    for(let i=0;i<arr.length;i++){
      const a = arr[i];
      if(!stationNeighbors.has(a)) stationNeighbors.set(a, new Set());
      if(i>0){
        const b = arr[i-1];
        if(!stationNeighbors.has(b)) stationNeighbors.set(b, new Set());
        stationNeighbors.get(a).add(b);
        stationNeighbors.get(b).add(a);
      }
    }
  });

  function bfsDistances(start){
    const q=[start];
    const dist=new Map([[start,0]]);
    for(let qi=0; qi<q.length; qi++){
      const cur=q[qi];
      const d=dist.get(cur);
      const ns=stationNeighbors.get(cur);
      if(!ns) continue;
      ns.forEach(n=>{
        if(!dist.has(n)){
          dist.set(n,d+1);
          q.push(n);
        }
      });
    }
    return dist;
  }

  // Dijkstra with lexicographic cost: (stops, transfers)
  // State is (station, line). Move along same line adds 1 stop. Transfer changes line adds 1 transfer (0 stop). We minimize transfers first, then stops.
  function bestRoute(startStation, endStation){
    const startLines = getLinesOf(startStation);
    const endLines = getLinesOf(endStation);
    if(!startLines.length || !endLines.length) return null;

    const pq=[];
    const key=(st,line)=>st+"@@"+line;
    const best=new Map();     // key -> [stops, transfers]
    const prev=new Map();     // key -> previous key
    const prevStep=new Map(); // key -> {st,line}

    function push(st,line,stops,transfers,fromKey){
      const k=key(st,line);
      const cur=best.get(k);
      if(cur){
        if(transfers>cur[1] || (transfers===cur[1] && stops>=cur[0])) return;
      }
      best.set(k,[stops,transfers]);
      if(fromKey){
        prev.set(k,fromKey);
        prevStep.set(k,{st,line});
      }
      pq.push([stops,transfers,st,line]);
    }

    // init: allow starting on any line at startStation with 0/0
    startLines.forEach(line=>push(startStation,line,0,0,null));

    // poor man's priority queue: sort each pop (small graph so OK)
    while(pq.length){
      pq.sort((a,b)=> (a[1]-b[1]) || (a[0]-b[0]));
      const [stops,transfers,st,line]=pq.shift();
      const k=key(st,line);
      const cur=best.get(k);
      if(!cur || cur[0]!==stops || cur[1]!==transfers) continue;

      if(st===endStation && endLines.includes(line)){
        // reconstruct
        const path=[];
        let kk=k;
        while(kk){
          const [station, ln] = kk.split("@@");
          path.push({line: ln, st: station});
          kk = prev.get(kk);
        }
        path.reverse();
        // compress any accidental duplicates (same station+line)
        const out=[];
        for(const step of path){
          const last=out[out.length-1];
          if(last && last.st===step.st && last.line===step.line) continue;
          out.push(step);
        }
        return out;
      }

      // 1) move to neighbors along same line
      const idxMap = lineIndex[line];
      const arr = subwayData[line];
      const idx = idxMap ? idxMap[st] : undefined;
      if(idx!==undefined){
        if(idx>0){
          const n=arr[idx-1];
          push(n,line,stops+1,transfers,k);
        }
        if(idx<arr.length-1){
          const n=arr[idx+1];
          push(n,line,stops+1,transfers,k);
        }
      }

      // 2) transfer at same station
      const linesHere = getLinesOf(st).filter(l=>l!==line);
      for(const nl of linesHere){
        push(st,nl,stops,transfers+1,k);
      }
    }

    // If we couldn't reach with line-matching end, allow endStation on any line (still minimal)
    // Find best among endStation states
    let bestEndKey=null, bestCost=null;
    for(const ln of endLines){
      const k=key(endStation,ln);
      const c=best.get(k);
      if(c && (!bestCost || c[1]<bestCost[1] || (c[1]==bestCost[1] && c[0]<bestCost[0]))){
        bestCost=c; bestEndKey=k;
      }
    }
    if(!bestEndKey) return null;
    const path=[];
    let kk=bestEndKey;
    while(kk){
      const [station, ln] = kk.split("@@");
      path.push({line: ln, st: station});
      kk = prev.get(kk);
    }
    path.reverse();
    const out=[];
    for(const step of path){
      const last=out[out.length-1];
      if(last && last.st===step.st && last.line===step.line) continue;
      out.push(step);
    }
    return out;
  }

  // Pick a random destination within [minStops, maxStops] stops, then compute best route to it.
  
  // Pick a random destination within [minStops, maxStops] stops from start (by BFS distance),
  // then compute an optimal route prioritizing: (1) minimum transfers, (2) minimum stops.
  function planOptimalTrip(startStation){
    const dist = bfsDistances(startStation);
    const candidates = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(!d) continue;
      if(st !== startStation && d >= minStops && d <= maxStops) candidates.push(st);
    }

    // Fallbacks if constraints too tight
    let dest = null;
    if(candidates.length){
      dest = pick(candidates);
    }else{
      // Choose the farthest reachable within maxStops, else any reachable station.
      let far = -1;
      for(const st of allStations){
        const d = dist.get(st);
        if(!d || st===startStation) continue;
        if(d <= maxStops && d > far){ far=d; dest=st; }
      }
      if(!dest){
        const reachable = [];
        for(const st of allStations){
          const d = dist.get(st);
          if(d && st!==startStation) reachable.push(st);
        }
        dest = reachable.length ? pick(reachable) : startStation;
      }
    }

    // Compute best route (min transfers, then min stops)
    const best = dijkstraMinTransferStops(startStation, dest);
    return { dest, path: best.path };
  }
);
    let dest = candidates.length ? pick(candidates) : null;
    if(!dest){
      // fallback: farthest within maxStops, else any reachable
      let far=-1;
      dist.forEach((d,st)=>{
        if(st!==startStation && d<=maxStops && d>far){ far=d; dest=st; }
      });
      if(!dest){
        const keys=[...dist.keys()].filter(s=>s!==startStation);
        dest = keys.length ? pick(keys) : startStation;
      }
    }
    const route = bestRoute(startStation, dest);
    return route || [{line:getLinesOf(startStation)[0]||lineNames[0], st:startStation}];
  }


function randomWalkPath(startLine, startStation){
    let curLine = startLine;

    const idx = lineIndex[curLine][startStation];
    const arr = subwayData[curLine];

    // ì¢…ì ì—ì„œ ì¶œë°œí•˜ë©´ ë¬´ì¡°ê±´ ì¢…ì  ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì¶œë°œ
    let dir;
    if (idx === 0) dir = 1;
    else if (idx === arr.length - 1) dir = -1;
    else dir = Math.random() < 0.5 ? -1 : 1;

    const stepsPlanned = randInt(minStops, maxStops);
    const path = [{ line: curLine, st: startStation }];
    let curSt = startStation;

    for (let step = 1; step <= stepsPlanned; step++) {
      const linesAtCur = getLinesOf(curSt);
      if (linesAtCur.length >= 2) {
        const remain = stepsPlanned - step + 1;
        const nearEnd = remain <= 6;
        const pTransfer = nearEnd ? 0.55 : 0.22;
        if (Math.random() < pTransfer) {
          const choices = linesAtCur.filter(l => l !== curLine);
          if (choices.length) {
            curLine = pick(choices);

            // í™˜ìŠ¹ í›„ì—ë„ ì¢…ì ì´ë©´ ë°©í–¥ ë‹¤ì‹œ ë³´ì •
            const newIdx = lineIndex[curLine][curSt];
            const newArr = subwayData[curLine];
            if (newIdx === 0) dir = 1;
            else if (newIdx === newArr.length - 1) dir = -1;
          }
        }
      }

      const nextSt = getNextOnLine(curLine, curSt, dir);
      if (!nextSt) break;

      curSt = nextSt;
      path.push({ line: curLine, st: curSt });
    }

    return path;
  }

  // Result overlay
  const overlay=document.getElementById('resultOverlay');
  const resultStation=document.getElementById('resultStation');
  const resultCount=document.getElementById('resultCount');
  const resultBox=document.getElementById('resultBox');
  const resultCanvas=document.getElementById('resultCanvas');
  const resultCtx=resultCanvas.getContext('2d');

  document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; });
  document.getElementById('searchBtn').addEventListener('click', ()=>{
    const station = (resultStation.textContent || '').trim(); // includes 'ì—­'
    const query = encodeURIComponent(station + " ë°ì´íŠ¸ì½”ìŠ¤");
    window.open("https://search.naver.com/search.naver?query=" + query, "_blank");
  });

  function showResultOverlay(stationName,totalMoved){
    resultStation.textContent = formatStation(stationName);
    resultCount.textContent = 'ì´ ' + totalMoved + 'ì •ê±°ì¥ ì´ë™';
    overlay.style.display='flex';
    const dims = resizeCanvasTo(resultBox, resultCanvas, resultCtx);
    burstConfettiOn(resultCanvas, resultCtx, dims.w, dims.h);
    playFanfare();
  }

  // Init
  const startInput=document.getElementById('startInput');
  const goBtn=document.getElementById('goBtn');

  try{ localStorage.removeItem(LAST_STATION_KEY); }catch(e){}
  let currentStation = (allStations.includes(DEFAULT_FIRST_STATION) ? DEFAULT_FIRST_STATION : (allStations[0] || DEFAULT_FIRST_STATION));
let currentLine = getLinesOf(currentStation)[0] || lineNames[0];
  startInput.value=currentStation;
  // Force initial dead-center on the person token.
  setTokenAt(currentLine,currentStation,false);
    try{ snapCameraToTokenNow(); }catch(e){}
  // Ensure initial camera is centered on token (after layout settles)
  requestAnimationFrame(()=>requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} }));

  scheduleInitialCenter();
  hudLine1.textContent=formatStation(currentStation);
  hudLine2.textContent='ì´ë™: 0ì •ê±°ì¥';
  let animating=false;

  // --- Transfer SFX (loop while transferring) ---
  let isTransferring = false;
  let audioPrimed = false;
  const sfxTransfer = document.getElementById('sfxTransfer');
  if(sfxTransfer){
    try{ sfxTransfer.src = TRANSFER_SFX_URL; sfxTransfer.load(); }catch(e){}
    try{ sfxTransfer.volume = 0.8; }catch(e){}
    try{ sfxTransfer.muted = false; }catch(e){}
  }
  if(sfxTransfer){
    sfxTransfer.loop = true;
    sfxTransfer.volume = 0.75;
    sfxTransfer.preload = 'auto';
  }

  function primeAudio(){
    // iOS: unlock audio on first user gesture
    if(audioPrimed) return;
    if(!sfxTransfer) { audioPrimed = true; return; }
    audioPrimed = true;
    try{
      sfxTransfer.pause();
      sfxTransfer.currentTime = 0;
      sfxTransfer.muted = true;
      const p = sfxTransfer.play();
      // once a play is allowed, immediately stop and unmute
      Promise.resolve(p).then(()=>{
        try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
        sfxTransfer.muted = false;
      }).catch(()=>{
        // even if it fails, keep unmuted; future plays after gesture may work
        sfxTransfer.muted = false;
      });
    }catch(e){
      try{ sfxTransfer.muted = false; }catch(_e){}
    }
  }

  function startTransferSound(){
    if(!sfxTransfer) return;
    // ensure primed (safe to call repeatedly)
    if(!audioPrimed) primeAudio();

    if(isTransferring) return;
    isTransferring = true;

    try{
      sfxTransfer.muted = false;
      // do not always rewind (prevents clicks); only if ended or not started
      if(isNaN(sfxTransfer.currentTime) || sfxTransfer.currentTime > 0.25){
        // keep current position for smooth loop start
      }else{
        try{ sfxTransfer.currentTime = 0; }catch(e){}
      }
      const p = sfxTransfer.play();
      if(p && p.catch) p.catch(()=>{});
    }catch(e){}
  }

  function stopTransferSound(){
    if(!sfxTransfer) return;
    if(!isTransferring) return;
    isTransferring = false;
    try{
      sfxTransfer.pause();
      sfxTransfer.currentTime = 0;
    }catch(e){}
  }
  // Settings UI (min/max stops)
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsBackdrop = document.getElementById('settingsBackdrop');
  const minStopsInputEl = document.getElementById('minStopsInput');
  const maxStopsInputEl = document.getElementById('maxStopsInput');
  const settingsOk = document.getElementById('settingsOk');
  const settingsCancel = document.getElementById('settingsCancel');

  function clampInt(v, lo, hi){
    v = parseInt(String(v||'').trim(), 10);
    if(!Number.isFinite(v)) return lo;
    return Math.max(lo, Math.min(hi, v));
  }
  function openSettings(){
    if(animating) return;
    minStopsInputEl.value = String(minStops);
    maxStopsInputEl.value = String(maxStops);
    settingsOverlay.classList.add('show');
    settingsOverlay.setAttribute('aria-hidden','false');
    try{ playTick(); }catch(e){}
    setTimeout(()=>{ try{ minStopsInputEl.focus(); }catch(e){} }, 40);
  }
  function closeSettings(){
    settingsOverlay.classList.remove('show');
    settingsOverlay.setAttribute('aria-hidden','true');
  }
  function applySettings(){
    const minEl = document.getElementById('minStopsInput');
    const maxEl = document.getElementById('maxStopsInput');

    let newMin = parseInt(minEl?.value ?? '', 10);
    let newMax = parseInt(maxEl?.value ?? '', 10);

    if(!Number.isFinite(newMin)) newMin = 6;
    if(!Number.isFinite(newMax)) newMax = 25;

    newMin = Math.min(99, Math.max(1, newMin));
    newMax = Math.min(99, Math.max(1, newMax));

    if(newMax < newMin){
      // Keep the user's intent: push max up to min
      newMax = newMin;
      if(maxEl) maxEl.value = String(newMax);
    }

    minStops = newMin;
    maxStops = newMax;

    try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
    try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}

    // No reroll automatically; next trip uses the new settings.
  }catch(e){}
    closeSettings();
    try{ playDing(); }catch(e){}
  }

  if(settingsBtn){
    settingsBtn.addEventListener('click', openSettings);
    settingsBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); openSettings(); }, {passive:false});
  }
  if(settingsBackdrop){
    settingsBackdrop.addEventListener('click', closeSettings);
  }
  if(settingsCancel){
    settingsCancel.addEventListener('click', closeSettings);
  }
  if(settingsOk){
    settingsOk.addEventListener('click', applySettings);
  }

  // Step buttons
  document.querySelectorAll('.stepBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const which = btn.getAttribute('data-step');
      const delta = parseInt(btn.getAttribute('data-delta')||'0',10) || 0;
      if(which === 'min'){
        const next = clampInt(minStopsInputEl.value,1,25) + delta;
        minStopsInputEl.value = String(clampInt(next,1,25));
      } else {
        const next = clampInt(maxStopsInputEl.value,1,25) + delta;
        maxStopsInputEl.value = String(clampInt(next,1,25));
      }
      try{ playTick(); }catch(e){}
    });
  });

  // Enter = apply, ESC = close
  settingsOverlay && settingsOverlay.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape') closeSettings();
    if(e.key === 'Enter') applySettings();
  });


  function findStartStation(input){
    const q=normalizeName(input);
    for(const s of allStations) if(normalizeName(s)===q) return s;
    return null;
  }

  async function animatePath(path){
    let moved=0;
    for(let i=0;i<path.length;i++){
      const cur=path[i];
      hudLine1.textContent=formatStation(cur.st);
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';
      if(i===0){
        // Teleport to start: snap camera immediately so it follows from the first segment
        setTokenAt(cur.line,cur.st,false);
        try{ snapCameraToTokenNow(); }catch(e){}
        await sleep(180);
        continue;
      }
      const prev=path[i-1];
            if(prev.line !== cur.line){ startTransferSound(); }
      await moveSegment(prev.line,prev.st,cur.line,cur.st);
      if(prev.line !== cur.line){ stopTransferSound(); }

      moved++;
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';
      playTick();
      await sleep(160);
      const remain=(path.length-1)-i;
      const t=Math.max(0,6-remain);
      const jitter=Math.floor(Math.random()*180);
      const curve=t===0 ? 1 : (1 + 0.14*t*t);
      let ms=(380 + jitter)*curve;
      if(remain<=2) ms += 260;
      await sleep(ms);
    }
    return moved;
  }

  async function finale(targetStation,totalMoved){
    stopTransferSound();
    playDing();
    const dims = resizeCanvasTo(viewport, confCanvas, confCtx);
    burstConfettiOn(confCanvas, confCtx, dims.w, dims.h);
    showResultOverlay(targetStation,totalMoved);
  }

  async function onStart(){
    if(animating) return;
    const startStation=findStartStation(startInput.value);
    if(!startStation){ showErr('ì¶œë°œì—­ ì˜¤íƒ€! ì˜ˆ: í˜œí™”, ë™ëŒ€ë¬¸, ì„œìš¸ì—­, ê°•ë‚¨'); return; }
    animating=true; goBtn.disabled=true;
    primeAudio();
    startBGM();
    overlay.style.display='none';
    currentStation=startStation;
    currentLine=getLinesOf(currentStation)[0] || lineNames[0];
    const path=planOptimalTrip(currentStation);
    // update currentLine to the route's starting line (could change if station belongs to multiple lines)
    currentLine = path[0]?.line || currentLine;
    const last=path[path.length-1];
    const moved=await animatePath(path);
    await finale(last.st,moved);
    currentStation=last.st;
    currentLine=last.line;
    try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
    animating=false; goBtn.disabled=false;
  }

  goBtn.addEventListener('click', onStart);
  goBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
})();

// === VisualViewport height fix (prevents top blank on mobile Safari) ===
(function setupVvh(){
  const setVvh = () => {
    const vv = window.visualViewport;
    const h = vv ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--vvh', (h * 0.01) + 'px');
  };
  setVvh();
  window.addEventListener('resize', setVvh);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', setVvh);
})();

</script>
  <audio id="sfxTransfer" src="" preload="auto"></audio>
</body>
</html>
