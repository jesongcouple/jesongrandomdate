<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="theme-color" content="#ff4d6d" />
<link rel="manifest" href="./manifest.webmanifest" />
<link rel="apple-touch-icon" href="./icons/apple-touch-icon.png" />
<title>ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</title>
<style>
:root{--main:#ff4d6d;--bg:#fff0f3;--ink:#c9184a;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;font-family:-apple-system,system-ui,sans-serif;}
html,body{margin:0;background:var(--bg);height:100%;min-height:100dvh;}
.wrap{max-width:520px;margin:0 auto;padding:calc(14px + env(safe-area-inset-top)) 14px calc(14px + env(safe-area-inset-bottom));}
.card{background:#fff;border:6px solid #ffccd5;border-radius:28px;padding:14px;box-shadow:0 14px 30px rgba(255,77,109,.18);}
.title{font-weight:900;color:var(--ink);font-size:20px;margin:0 0 14px;text-align:center;}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
input{flex:1;min-width:180px;padding:12px 14px;border-radius:18px;border:3px solid #ffccd5;font-size:16px;outline:none;text-align:center;}
button{padding:12px 16px;border:0;border-radius:999px;background:linear-gradient(135deg,#ff4d6d,#ff85a2);color:#fff;font-weight:900;font-size:16px;box-shadow:0 10px 18px rgba(255,77,109,.25);cursor:pointer;}
button:disabled{background:#ccc;box-shadow:none;cursor:default;}
/* Phone-like stage: JS sets exact width/height. Game and splash can be tuned independently. */
:root{--stageWpx:320px;--stageHpx:568px;--splashHpx:568px;}
.stageWrap{margin-top:12px;width:var(--stageWpx);height:var(--stageHpx);margin-left:auto;margin-right:auto;background:transparent;border:0;border-radius:22px;overflow:hidden;position:relative;}
.viewport{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;background:#fff8f9;position:relative;touch-action:none;}
.viewport{scrollbar-width:none;-ms-overflow-style:none;}
.viewport::-webkit-scrollbar{width:0;height:0;display:none;}

svg{display:block;}
.lineStroke{stroke-width:22;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;filter:drop-shadow(0 10px 14px rgba(0,0,0,.10));}
.lineInner{stroke:#fff;stroke-width:7;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;}
.connector{stroke:#ffb3c1;stroke-width:5;stroke-linecap:round;opacity:.75;fill:none;}
.label{font-size:12px;font-weight:900;fill:#c9184a;opacity:1;}
.stationDot{fill:#fff;stroke:var(--main);stroke-width:4;opacity:1;}
.token{filter:drop-shadow(0 10px 12px rgba(0,0,0,.16));}
.token circle,.token rect{fill:var(--main);stroke:#fff;stroke-width:4;}
#hudRect{fill:white;stroke:#ffccd5;stroke-width:4;opacity:.94;}
#confetti{position:absolute;inset:0;pointer-events:none;z-index:20;}

#resultOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;}
#resultBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
#resultBox{position:relative;width:min(360px,86vw);background:#fff;border-radius:24px;padding:22px 26px;text-align:center;border:4px solid #ffccd5;box-shadow:0 20px 40px rgba(255,77,109,.25);overflow:hidden;}
#resultCanvas{position:absolute;inset:0;pointer-events:none;z-index:2;}
#resultContent{position:relative;z-index:3;}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;display:none;background:rgba(0,0,0,.85);color:#fff;padding:12px 14px;border-radius:14px;font-weight:900;font-size:12px;line-height:1.35;}

/* --- Splash (tap -> loading -> reveal) --- */
#startOverlay{
  position:fixed;
  inset:0;
  height:100dvh;
  z-index:100000;
  opacity:1;
  /* Surrounding area should match the game's background tone */
  background:var(--bg);
  touch-action:manipulation;
  user-select:none;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:calc(14px + env(safe-area-inset-top)) 14px calc(14px + env(safe-area-inset-bottom));
}
#startOverlay.fadeOut{ opacity:0; transition:opacity .55s ease; }

/* splash stage matches game stage size + ratio */
.splashStage{
  width:var(--stageWpx);
  height:var(--splashHpx);
  border-radius:22px;
  overflow:hidden;
  border:0;
  background:#fff8f9;
  position:relative;
  box-shadow:none;
  /* Splash uses the same width, but can be slightly taller than the game stage on web. */
}

#splashImg{
  width:100%;
  height:100%;
  object-fit:cover; /* match game framing: fill stage */
  object-position:center center;
  display:block;
  background:transparent;
}

/* íƒ€ì´í‹€ ì•„ë˜ìª½(ëŒ€ëµ) ìœ„ì¹˜ì— ë¬¸êµ¬ ì˜¤ë²„ë ˆì´ */
#tapHintWrap{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  text-align:center;
  width:min(92vw,520px);
  padding:0 14px;
}
#tapHint{
  font-size:18px;
  font-weight:1000;
  letter-spacing:0.5px;
  color:rgba(255,255,255,.96);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  animation:tapPulse 1.05s ease-in-out infinite;
}
@keyframes tapPulse{
  0%{ transform:scale(.98); opacity:.55; filter:blur(.1px); }
  45%{ transform:scale(1.04); opacity:1; }
  100%{ transform:scale(.98); opacity:.55; }
}

#splashLoading{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  font-size:20px;
  font-weight:1000;
  letter-spacing:1px;
  color:rgba(255,255,255,.95);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  padding:0;
  border-radius:0;
  background:transparent;
  border:0;
  display:none;
  line-height:1;
}

#splashLoading.show{ display:block; }
#splashLoading .dots::after{ content:""; animation:dots 1.05s steps(4,end) infinite; }
#splashLoading .blink{ animation:blink 0.55s steps(2,end) infinite; }
@keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:.25} }
@keyframes dots{ 0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""} }

/* ë¡œë”© ì¤‘ í™”ë©´ ì‚´ì§ í”ë“¤ë¦¬ëŠ” ëŠë‚Œ */
#startOverlay.loading #splashImg{ animation:loadingZoom 1.2s ease-in-out infinite; }
@keyframes loadingZoom{
  0%{ transform:scale(1); filter:saturate(1.05); }
  50%{ transform:scale(1.02); filter:saturate(1.15); }
  100%{ transform:scale(1); filter:saturate(1.05); }
}
</style>
</head>

<body>

<!-- Splash -->
<div id="startOverlay" aria-label="ì‹œì‘ í™”ë©´" role="button" tabindex="0">
  <div class="splashStage">
    <img id="splashImg" src="./splash-bg.png" alt="ì œâ¤ï¸ì†¡ ëœë¤ë°ì´íŠ¸ ì‹œì‘ í™”ë©´" />

    <div id="tapHintWrap" aria-hidden="false">
      <div id="tapHint">í™”ë©´ì„ í„°ì¹˜í•´ì£¼ì„¸ìš”</div>
    </div>

    <div id="splashLoading" aria-live="polite">
      <span class="blink">ë¡œë”©ì¤‘</span><span class="dots"></span>
    </div>
  </div>
</div>

<!-- Game UI -->
<div class="wrap">
  <div class="card">
    <h1 class="title">ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</h1>
    <div class="row">
      <input id="startInput" inputmode="text" autocomplete="off" spellcheck="false" placeholder="ì¶œë°œì—­ (ì˜ˆ: í˜œí™”)" />
      <button id="goBtn">ì¶œë°œ!</button>
    </div>

    <div class="stageWrap">
      <div class="viewport" id="viewport">
        <svg id="map">
          <g id="gLines"></g>
          <g id="gDots"></g>

          <!-- HUD -->
          <g id="hudG">
            <!-- Token ë¨¸ë¦¬ ìœ„ì— ê³ ì •ë˜ë„ë¡, HUDëŠ” (0,0)ì„ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ì•™ì •ë ¬ëœ ì¢Œí‘œê³„ë¥¼ ì‚¬ìš© -->
            <rect id="hudRect" x="-120" y="-114" rx="16" ry="16" width="240" height="74"></rect>
            <text id="hudLine1" x="0" y="-84" text-anchor="middle" font-size="14" font-weight="900" fill="#c9184a">-</text>
            <text id="hudLine2" x="0" y="-60" text-anchor="middle" font-size="12" font-weight="900" fill="#ff4d6d">-</text>
          </g>

          <!-- Token -->
          <g id="token" class="token">
            <!-- í† í°: ê·€ì—¬ìš´ ì‚¬ëŒ(ì•„ì£¼ ë‹¨ìˆœ ë²„ì „: ë¨¸ë¦¬+ëª¸í†µ) -->
            <circle cx="0" cy="-18" r="12"></circle>
            <rect x="-12" y="-6" width="24" height="28" rx="12" ry="12"></rect>
          </g>
        </svg>
      </div>
      <canvas id="confetti"></canvas>
    </div>
  </div>
</div>

<!-- Result overlay -->
<div id="resultOverlay">
  <div id="resultBackdrop"></div>
  <div id="resultBox">
    <canvas id="resultCanvas"></canvas>
    <div id="resultContent">
      <div style="font-size:13px;font-weight:900;color:#777;">ìµœì¢… ë„ì°©</div>
      <div id="resultStation" style="margin-top:6px;font-size:26px;font-weight:900;color:#c9184a;"></div>
      <div id="resultCount" style="margin-top:10px;font-size:15px;font-weight:900;color:#ff4d6d;"></div>
      <button id="searchBtn" style="margin-top:12px;padding:10px 16px;border-radius:999px;border:none;background:#fff0f3;color:#c9184a;font-weight:900;font-size:14px;cursor:pointer;border:2px solid #ffccd5;">ë°ì´íŠ¸ì½”ìŠ¤ ì•Œì•„ë³´ê¸°ğŸ”</button>
      <button id="closeBtn" style="margin-top:14px;padding:10px 16px;border-radius:999px;border:none;background:linear-gradient(135deg,#ff4d6d,#ff85a2);color:white;font-weight:900;font-size:14px;cursor:pointer;">í™•ì¸ â¤ï¸</button>
    </div>
  </div>
</div>

<div id="err"></div>

<script>
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// Stage size: keep a PHONE portrait ratio (not 16:9).
// Splash + game share the exact same stage size.
(function initStageSizing(){
  const root=document.documentElement;

  function px(n){ return Math.max(0, Math.floor(n||0)); }

  function setStageSize(){
    const vv=window.visualViewport;
    const vw=(vv&&vv.width)||window.innerWidth;
    const vh=(vv&&vv.height)||window.innerHeight;

    const wrap=document.querySelector('.wrap');
    const card=document.querySelector('.card');
    const title=document.querySelector('.title');
    const row=document.querySelector('.row');

    // Width: as wide as the card allows (phone = almost full width)
    const wrapPad = 28; // .wrap left+right padding (14px*2)
    // Card has 14px padding on each side -> content width = card.clientWidth - 28
    const maxW = Math.min(520, (card ? (card.clientWidth - 28) : (vw - wrapPad)));


    // Height: use nearly the full viewport minus the UI above the stage.
    const titleH = title ? title.getBoundingClientRect().height : 0;
    const rowH   = row   ? row.getBoundingClientRect().height   : 0;
    const chrome = 34;   // extra breathing room (avoid page scroll on web)

    // Keep the stage BIG on phones. (Min height bumped so it doesn't get "tiny")
    const availableH = vh - (titleH + rowH) - chrome - (wrap ? 18 : 0);
    const maxH = Math.min(980, Math.max(520, availableH));

    // Width: fixed by the card width.
    let w = maxW;

    // Game height: slightly reduced so the whole card fits on web without scrolling.
    const HEIGHT_FACTOR = 0.92;
    let h = maxH * HEIGHT_FACTOR;

    // Splash height: use MORE of the viewport (no title/inputs on top), so it can feel longer.
    // This fixes the "splash looks shorter than game" feeling.
    const splashMaxH = Math.min(980, Math.max(520, vh - 24));
    let splashH = splashMaxH;

    // Safety clamps (keep it usable even on tiny viewports)
    w = Math.max(300, Math.min(maxW, w));
    h = Math.max(420, Math.min(maxH, h));
    splashH = Math.max(420, Math.min(splashMaxH, splashH));

    root.style.setProperty('--stageWpx', w.toFixed(2)+'px');
    root.style.setProperty('--stageHpx', h.toFixed(2)+'px');
    root.style.setProperty('--splashHpx', splashH.toFixed(2)+'px');
  }

  window.addEventListener('resize', setStageSize, {passive:true});
  window.addEventListener('orientationchange', setStageSize, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', setStageSize, {passive:true});
  setStageSize();
})();

function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

(function(){
  const errEl=document.getElementById('err');
  function showErr(msg){
    errEl.textContent=msg;
    errEl.style.display='block';
    clearTimeout(showErr.__t);
    showErr.__t=setTimeout(()=>{ errEl.style.display='none'; }, 3200);
  }
  window.addEventListener('error',(e)=>showErr('JS ì—ëŸ¬: '+(e.message||'unknown')));
  window.addEventListener('unhandledrejection',(e)=>showErr('Promise ì—ëŸ¬: '+(e.reason?.message||e.reason||'unknown')));

  // Splash: tap -> loading(0~100) -> reveal game screen
  const splash=document.getElementById('startOverlay');
  const hintWrap=document.getElementById('tapHintWrap');
  const loadingWrap=document.getElementById('splashLoading');
  let splashStarted=false;

  function removeSplash(){
    if(!splash) return;
    splash.classList.add('fadeOut');
    setTimeout(()=>{
      try{ splash.remove(); }
      catch(e){ splash.style.display='none'; }
    }, 600);
  }

  function beginSplashLoading(){
    if(!splash || splashStarted) return;
    splashStarted=true;

    // iOS ì˜¤ë””ì˜¤ ì •ì±…: ì‚¬ìš©ì ì…ë ¥ ì‹œì ì—ë§Œ AudioContext ì¬ìƒ ê°€ëŠ¥
    try{
      ensureAudio();
      if(audioCtx && audioCtx.state==='suspended') audioCtx.resume();
    }catch(e){}

    splash.classList.add('loading');
    if(hintWrap) hintWrap.style.display='none';
    if(loadingWrap) loadingWrap.classList.add('show');

    const DURATION=3000;
    const start=performance.now();
    let lastTickTime=0;

    const step=(now)=>{
      const t=Math.min(1,(now-start)/DURATION);

      // ì•¡ì…˜ê°: ì¼ì • ê°„ê²©ìœ¼ë¡œ í‹± ì†Œë¦¬(í¼ì„¼íŠ¸ ì—†ì´ë„ ë¦¬ë“¬ê°)
      if(now - lastTickTime >= 140 && t < 1){
        playTick();
        lastTickTime = now;
      }

      if(t<1){
        requestAnimationFrame(step);
      }else{
        playDing();
        removeSplash();
      }
    };
    requestAnimationFrame(step);
  }

  if(splash){
    splash.addEventListener('click', beginSplashLoading, {passive:true});
    splash.addEventListener('touchend', beginSplashLoading, {passive:true});
    splash.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' || e.key===' '){ e.preventDefault(); beginSplashLoading(); }
    });
  }

  const DATA = {"1í˜¸ì„ ":["ì—°ì²œ","ì „ê³¡","ì²­ì‚°","ì†Œìš”ì‚°","ë™ë‘ì²œ","ì§€í–‰","ë•ì •","ë•ê³„","ì–‘ì£¼","ë…¹ì–‘","ê°€ëŠ¥","ì˜ì •ë¶€","íšŒë£¡","ë§ì›”ì‚¬","ë„ë´‰ì‚°","ë„ë´‰","ë°©í•™","ì°½ë™","ë…¹ì²œ","ì›”ê³„","ê´‘ìš´ëŒ€","ì„ê³„","ì‹ ì´ë¬¸","ì™¸ëŒ€ì•","íšŒê¸°","ì²­ëŸ‰ë¦¬","ì œê¸°ë™","ì‹ ì„¤ë™","ë™ë¬˜ì•","ë™ëŒ€ë¬¸","ì¢…ë¡œ5ê°€","ì¢…ë¡œ3ê°€","ì¢…ê°","ì‹œì²­","ì„œìš¸ì—­","ë‚¨ì˜","ìš©ì‚°","ë…¸ëŸ‰ì§„","ëŒ€ë°©","ì‹ ê¸¸","ì˜ë“±í¬","ì‹ ë„ë¦¼","êµ¬ë¡œ","êµ¬ì¼","ê°œë´‰","ì˜¤ë¥˜ë™","ì˜¨ìˆ˜","ì—­ê³¡","ì†Œì‚¬","ë¶€ì²œ","ì¤‘ë™","ìƒë™","ì†¡ë‚´","ë¶€ê°œ","ë¶€í‰","ë°±ìš´","ë™ì•”","ê°„ì„","ì£¼ì•ˆ","ë„í™”","ì œë¬¼í¬","ë„ì›","ë™ì¸ì²œ","ì¸ì²œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ë…ì‚°","ê¸ˆì²œêµ¬ì²­","ì„ìˆ˜","ê´€ì•…","ì•ˆì–‘","ëª…í•™","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ì˜ì™•","ì„±ê· ê´€ëŒ€","í™”ì„œ","ìˆ˜ì›","ì„¸ë¥˜","ë³‘ì ","ì„¸ë§ˆ","ì˜¤ì‚°ëŒ€","ì˜¤ì‚°","ì§„ìœ„","ì†¡íƒ„","ì„œì •ë¦¬","í‰íƒì§€ì œ","í‰íƒ","ì„±í™˜","ì§ì‚°","ë‘ì •","ì²œì•ˆ","ë´‰ëª…","ìŒìš©","ì•„ì‚°","íƒ•ì •","ë°°ë°©","ì˜¨ì–‘ì˜¨ì²œ","ì‹ ì°½"],"2í˜¸ì„ ":["ì‹œì²­","ì„ì§€ë¡œì…êµ¬","ì„ì§€ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì‹ ë‹¹","ìƒì™•ì‹­ë¦¬","ì™•ì‹­ë¦¬","í•œì–‘ëŒ€","ëšì„¬","ì„±ìˆ˜","ê±´ëŒ€ì…êµ¬","êµ¬ì˜","ê°•ë³€","ì ì‹¤ë‚˜ë£¨","ì ì‹¤","ì ì‹¤ìƒˆë‚´","ì¢…í•©ìš´ë™ì¥","ì‚¼ì„±","ì„ ë¦‰","ì—­ì‚¼","ê°•ë‚¨","êµëŒ€","ì„œì´ˆ","ë°©ë°°","ì‚¬ë‹¹","ë‚™ì„±ëŒ€","ì„œìš¸ëŒ€ì…êµ¬","ë´‰ì²œ","ì‹ ë¦¼","ì‹ ëŒ€ë°©","êµ¬ë¡œë””ì§€í„¸ë‹¨ì§€","ëŒ€ë¦¼","ì‹ ë„ë¦¼","ë¬¸ë˜","ì˜ë“±í¬êµ¬ì²­","ë‹¹ì‚°","í•©ì •","í™ëŒ€ì…êµ¬","ì‹ ì´Œ","ì´ëŒ€","ì•„í˜„","ì¶©ì •ë¡œ","ìš©ë‹µ","ì‹ ë‹µ","ìš©ë‘","ì‹ ì„¤ë™","ë„ë¦¼ì²œ","ì–‘ì²œêµ¬ì²­","ì‹ ì •ë„¤ê±°ë¦¬","ê¹Œì¹˜ì‚°"],"3í˜¸ì„ ":["ëŒ€í™”","ì£¼ì—½","ì •ë°œì‚°","ë§ˆë‘","ë°±ì„","ëŒ€ê³¡","í™”ì •","ì›ë‹¹","ì›í¥","ì‚¼ì†¡","ì§€ì¶•","êµ¬íŒŒë°œ","ì—°ì‹ ë‚´","ë¶ˆê´‘","ë…¹ë²ˆ","í™ì œ","ë¬´ì•…ì¬","ë…ë¦½ë¬¸","ê²½ë³µê¶","ì•ˆêµ­","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ3ê°€","ì¶©ë¬´ë¡œ","ë™ëŒ€ì…êµ¬","ì•½ìˆ˜","ê¸ˆí˜¸","ì˜¥ìˆ˜","ì••êµ¬ì •","ì‹ ì‚¬","ì ì›","ê³ ì†í„°ë¯¸ë„","êµëŒ€","ë‚¨ë¶€í„°ë¯¸ë„","ì–‘ì¬","ë§¤ë´‰","ë„ê³¡","ëŒ€ì¹˜","í•™ì—¬ìš¸","ëŒ€ì²­","ì¼ì›","ìˆ˜ì„œ","ê°€ë½ì‹œì¥","ê²½ì°°ë³‘ì›","ì˜¤ê¸ˆ"],"4í˜¸ì„ ":["ì§„ì ‘","ì˜¤ë‚¨","ë³„ë‚´ë³„ê°€ëŒ","ë‹¹ê³ ê°œ","ìƒê³„","ë…¸ì›","ì°½ë™","ìŒë¬¸","ìˆ˜ìœ ","ë¯¸ì•„","ë¯¸ì•„ì‚¬ê±°ë¦¬","ê¸¸ìŒ","ì„±ì‹ ì—¬ëŒ€ì…êµ¬","í•œì„±ëŒ€ì…êµ¬","í˜œí™”","ë™ëŒ€ë¬¸","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì¶©ë¬´ë¡œ","ëª…ë™","íšŒí˜„","ì„œìš¸ì—­","ìˆ™ëŒ€ì…êµ¬","ì‚¼ê°ì§€","ì‹ ìš©ì‚°","ì´ì´Œ","ë™ì‘","ì´ì‹ ëŒ€ì…êµ¬","ì‚¬ë‹¹","ë‚¨íƒœë ¹","ì„ ë°”ìœ„","ê²½ë§ˆê³µì›","ëŒ€ê³µì›","ê³¼ì²œ","ì •ë¶€ê³¼ì²œì²­ì‚¬","ì¸ë•ì›","í‰ì´Œ","ë²”ê³„","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„"],"5í˜¸ì„ ":["ë°©í™”","ê°œí™”ì‚°","ê¹€í¬ê³µí•­","ì†¡ì •","ë§ˆê³¡","ë°œì‚°","ìš°ì¥ì‚°","í™”ê³¡","ê¹Œì¹˜ì‚°","ì‹ ì •","ëª©ë™","ì˜¤ëª©êµ","ì–‘í‰","ì˜ë“±í¬êµ¬ì²­","ì˜ë“±í¬ì‹œì¥","ì‹ ê¸¸","ì—¬ì˜ë„","ì—¬ì˜ë‚˜ë£¨","ë§ˆí¬","ê³µë•","ì• ì˜¤ê°œ","ì¶©ì •ë¡œ","ì„œëŒ€ë¬¸","ê´‘í™”ë¬¸","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì²­êµ¬","ì‹ ê¸ˆí˜¸","í–‰ë‹¹","ì™•ì‹­ë¦¬","ë§ˆì¥","ë‹µì‹­ë¦¬","ì¥í•œí‰","êµ°ì","ì•„ì°¨ì‚°","ê´‘ë‚˜ë£¨","ì²œí˜¸","ê°•ë™","ê¸¸ë™","êµ½ì€ë‹¤ë¦¬","ëª…ì¼","ê³ ë•","ìƒì¼ë™","ê°•ì¼","ë¯¸ì‚¬","í•˜ë‚¨í’ì‚°","í•˜ë‚¨ì‹œì²­","í•˜ë‚¨ê²€ë‹¨ì‚°","ë‘”ì´Œë™","ì˜¬ë¦¼í”½ê³µì›","ë°©ì´","ì˜¤ê¸ˆ","ê°œë¡±","ê±°ì—¬","ë§ˆì²œ"],"6í˜¸ì„ ":["ì‘ì•”","ì—­ì´Œ","ë…ë°”ìœ„","ì—°ì‹ ë‚´","êµ¬ì‚°","ìƒˆì ˆ","ì¦ì‚°","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ì›”ë“œì»µê²½ê¸°ì¥","ë§ˆí¬êµ¬ì²­","ë§ì›","í•©ì •","ìƒìˆ˜","ê´‘í¥ì°½","ëŒ€í¥","ê³µë•","íš¨ì°½ê³µì›ì•","ì‚¼ê°ì§€","ë…¹ì‚¬í‰","ì´íƒœì›","í•œê°•ì§„","ë²„í‹°ê³ ê°œ","ì•½ìˆ˜","ì²­êµ¬","ì‹ ë‹¹","ë™ë¬˜ì•","ì°½ì‹ ","ë³´ë¬¸","ì•ˆì•”","ê³ ë ¤ëŒ€","ì›”ê³¡","ìƒì›”ê³¡","ëŒê³¶ì´","ì„ê³„","íƒœë¦‰ì…êµ¬","í™”ë‘ëŒ€","ë´‰í™”ì‚°","ì‹ ë‚´"],"7í˜¸ì„ ":["ì¥ì•”","ë„ë´‰ì‚°","ìˆ˜ë½ì‚°","ë§ˆë“¤","ë…¸ì›","ì¤‘ê³„","í•˜ê³„","ê³µë¦‰","íƒœë¦‰ì…êµ¬","ë¨¹ê³¨","ì¤‘í™”","ìƒë´‰","ë©´ëª©","ì‚¬ê°€ì •","ìš©ë§ˆì‚°","ì¤‘ê³¡","êµ°ì","ì–´ë¦°ì´ëŒ€ê³µì›","ê±´ëŒ€ì…êµ¬","ëšì„¬ìœ ì›ì§€","ì²­ë‹´","ê°•ë‚¨êµ¬ì²­","í•™ë™","ë…¼í˜„","ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ë‚´ë°©","ì´ìˆ˜","ë‚¨ì„±","ìˆ­ì‹¤ëŒ€ì…êµ¬","ìƒë„","ì¥ìŠ¹ë°°ê¸°","ì‹ ëŒ€ë°©ì‚¼ê±°ë¦¬","ë³´ë¼ë§¤","ì‹ í’","ëŒ€ë¦¼","ë‚¨êµ¬ë¡œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ì² ì‚°","ê´‘ëª…ì‚¬ê±°ë¦¬","ì²œì™•","ì˜¨ìˆ˜","ê¹Œì¹˜ìš¸","ë¶€ì²œì¢…í•©ìš´ë™ì¥","ì¶˜ì˜","ì‹ ì¤‘ë™","ë¶€ì²œì‹œì²­","ìƒë™","ì‚¼ì‚°ì²´ìœ¡ê´€","êµ´í¬ì²œ","ë¶€í‰êµ¬ì²­","ìƒê°ˆ","ì‚°ê³¡","ì„ë‚¨"],"8í˜¸ì„ ":["ë³„ë‚´","ë‹¤ì‚°","ë™êµ¬ë¦‰","êµ¬ë¦¬","ì¥ìí˜¸ìˆ˜ê³µì›","ì•”ì‚¬ì—­ì‚¬ê³µì›","ì•”ì‚¬","ì²œí˜¸","ê°•ë™êµ¬ì²­","ëª½ì´Œí† ì„±","ì ì‹¤","ì„ì´Œ","ì†¡íŒŒ","ê°€ë½ì‹œì¥","ë¬¸ì •","ì¥ì§€","ë³µì •","ë‚¨ìœ„ë¡€","ì‚°ì„±","ë‚¨í•œì‚°ì„±ì…êµ¬","ë‹¨ëŒ€ì˜¤ê±°ë¦¬","ì‹ í¥","ì‹ ì´Œ","ìˆ˜ì§„","ëª¨ë€"],"9í˜¸ì„ ":["ê°œí™”","ê¹€í¬ê³µí•­","ê³µí•­ì‹œì¥","ì‹ ë°©í™”","ë§ˆê³¡ë‚˜ë£¨","ì–‘ì²œí–¥êµ","ê°€ì–‘","ì¦ë¯¸","ë“±ì´Œ","ì—¼ì°½","ì‹ ëª©ë™","ì„ ìœ ë„","ë‹¹ì‚°","êµ­íšŒì˜ì‚¬ë‹¹","ì—¬ì˜ë„","ìƒ›ê°•","ë…¸ëŸ‰ì§„","ë…¸ë“¤","í‘ì„","ë™ì‘","êµ¬ë°˜í¬","ì‹ ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ì‚¬í‰","ì‹ ë…¼í˜„","ì–¸ì£¼","ì„ ì •ë¦‰","ì‚¼ì„±ì¤‘ì•™","ë´‰ì€ì‚¬","ì¢…í•©ìš´ë™ì¥","ì‚¼ì „","ì„ì´Œê³ ë¶„","ì„ì´Œ","ì†¡íŒŒë‚˜ë£¨","í•œì„±ë°±ì œ","ì˜¬ë¦¼í”½ê³µì›","ë‘”ì´Œì˜¤ë¥œ","ì¤‘ì•™ë³´í›ˆë³‘ì›"],"ê²½ì˜ì¤‘ì•™ì„ ":["ë¬¸ì‚°","íŒŒì£¼","ì›”ë¡±","ê¸ˆì´Œ","ê¸ˆë¦‰","ìš´ì •","ì•¼ë‹¹","íƒ„í˜„","ì¼ì‚°","í’ì‚°","ë°±ë§ˆ","ê³¡ì‚°","ëŒ€ê³¡","ëŠ¥ê³¡","í–‰ì‹ ","ê°•ë§¤","í™”ì „","ìˆ˜ìƒ‰","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ê°€ì¢Œ","í™ëŒ€ì…êµ¬","ì„œê°•ëŒ€","ê³µë•","íš¨ì°½ê³µì›ì•","ìš©ì‚°","ì´ì´Œ","ì„œë¹™ê³ ","í•œë‚¨","ì˜¥ìˆ˜","ì‘ë´‰","ì™•ì‹­ë¦¬","ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","ì–‘ì›","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ë„ì‹¬","íŒ”ë‹¹","ìš´ê¸¸ì‚°","ì–‘ìˆ˜","ì‹ ì›","êµ­ìˆ˜","ì•„ì‹ ","ì˜¤ë¹ˆ","ì–‘í‰","ì›ë•","ìš©ë¬¸","ì§€í‰"],"ì‹ ë¶„ë‹¹ì„ ":["ì‹ ì‚¬","ë…¼í˜„","ì‹ ë…¼í˜„","ê°•ë‚¨","ì–‘ì¬","ì–‘ì¬ì‹œë¯¼ì˜ìˆ²","ì²­ê³„ì‚°ì…êµ¬","íŒêµ","ì •ì","ë¯¸ê¸ˆ","ë™ì²œ","ìˆ˜ì§€êµ¬ì²­","ì„±ë³µ","ìƒí˜„","ê´‘êµì¤‘ì•™","ê´‘êµ"],"ìˆ˜ì¸ë¶„ë‹¹ì„ ":["ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ì™•ì‹­ë¦¬","ì„œìš¸ìˆ²","ì••êµ¬ì •ë¡œë°ì˜¤","ê°•ë‚¨êµ¬ì²­","ì„ ì •ë¦‰","ì„ ë¦‰","í•œí‹°","ë„ê³¡","êµ¬ë£¡","ê°œí¬ë™","ëŒ€ëª¨ì‚°ì…êµ¬","ìˆ˜ì„œ","ë³µì •","ê°€ì²œëŒ€","íƒœí‰","ëª¨ë€","ì•¼íƒ‘","ì´ë§¤","ì„œí˜„","ìˆ˜ë‚´","ì •ì","ë¯¸ê¸ˆ","ì˜¤ë¦¬","ì£½ì „","ë³´ì •","êµ¬ì„±","ì‹ ê°ˆ","ê¸°í¥","ìƒê°ˆ","ì²­ëª…","ì˜í†µ","ë§í¬","ë§¤íƒ„ê¶Œì„ ","ìˆ˜ì›ì‹œì²­","ë§¤êµ","ìˆ˜ì›","ê³ ìƒ‰","ì˜¤ëª©ì²œ","ì–´ì²œ","ì•¼ëª©","ì‚¬ë¦¬","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ë‹¬ì›”","ì›”ê³¶","ì†Œë˜í¬êµ¬","ì¸ì²œë…¼í˜„","í˜¸êµ¬í¬","ë‚¨ë™ì¸ë”ìŠ¤íŒŒí¬","ì›ì¸ì¬","ì—°ìˆ˜","ì†¡ë„","í•™ìµ","ì¸í•˜ëŒ€","ìˆ­ì˜","ì‹ í¬","ì¸ì²œ"]};

  // Audio: NO BGM, only SFX
  let audioCtx=null, sfxGain=null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(!sfxGain){ sfxGain = audioCtx.createGain(); sfxGain.gain.value=0.18; sfxGain.connect(audioCtx.destination); }
  }
  function startBGM(){ ensureAudio(); }
  function playTick(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    const f=audioCtx.createBiquadFilter();
    o.type='square'; o.frequency.value=1500;
    f.type='bandpass'; f.frequency.value=1100; f.Q.value=9;
    g.gain.value=0.0001;
    o.connect(f).connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.18, now+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.06);
    o.stop(now+0.07);
    const o2=audioCtx.createOscillator();
    const g2=audioCtx.createGain();
    o2.type='sine'; o2.frequency.value=420;
    g2.gain.value=0.0001;
    o2.connect(g2).connect(sfxGain);
    o2.start(now+0.018);
    g2.gain.linearRampToValueAtTime(0.07, now+0.03);
    g2.gain.exponentialRampToValueAtTime(0.0001, now+0.16);
    o2.stop(now+0.17);
  }
  function playDing(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.type='sine'; o.frequency.value=880;
    g.gain.value=0.0001;
    o.connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.14, now+0.02);
    o.frequency.linearRampToValueAtTime(1175, now+0.14);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.42);
    o.stop(now+0.43);
  }
  function playFanfare(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const g=audioCtx.createGain();
    g.gain.value=0.0001;
    g.connect(sfxGain);
    const o1=audioCtx.createOscillator();
    const o2=audioCtx.createOscillator();
    o1.type='square'; o2.type='square';
    o1.connect(g); o2.connect(g);
    const seq=[523.25,659.25,783.99,1046.5];
    const dur=0.10;
    o1.start(now); o2.start(now);
    seq.forEach((f,i)=>{ o1.frequency.setValueAtTime(f, now+i*dur); o2.frequency.setValueAtTime(f*0.5, now+i*dur); });
    g.gain.linearRampToValueAtTime(0.18, now+0.02);
    g.gain.linearRampToValueAtTime(0.12, now+0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, now+seq.length*dur+0.12);
    o1.stop(now+seq.length*dur+0.15);
    o2.stop(now+seq.length*dur+0.15);
  }

  function formatStation(s){ s=String(s).trim().replace(/ì—­$/,''); return s+'ì—­'; }
  function normalizeName(s){ return String(s).trim().replace(/ì—­$/,'').replace(/\s+/g,''); }

  // Build line data (line-aware)
  function cleanLine(arr){
    const out=[];
    for(let i=0;i<arr.length;i++){
      const s=String(arr[i]).trim();
      if(!s) continue;
      if(out.length && out[out.length-1]===s) continue;
      out.push(s);
    }
    return out;
  }
  const subwayData={};
  const lineNames=Object.keys(DATA);
  for(const line of lineNames) subwayData[line]=cleanLine(DATA[line]);

  const lineIndex={};
  for(const line of lineNames){
    lineIndex[line]={};
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++) lineIndex[line][arr[i]]=i;
  }
  const stationLines=new Map();
  for(const line of lineNames){
    for(const st of subwayData[line]){
      if(!stationLines.has(st)) stationLines.set(st,new Set());
      stationLines.get(st).add(line);
    }
  }
  const getLinesOf=(st)=>stationLines.get(st)?Array.from(stationLines.get(st)):[];

  const getNextOnLine=(line,st,dir)=>{
    const idx=lineIndex[line][st];
    if(idx===undefined) return null;
    const arr=subwayData[line];
    const ni=idx+dir;
    if(ni<0||ni>=arr.length) return null;
    return arr[ni];
  };

  const allStations=Array.from(stationLines.keys());

  // Layout (no x-averaging)
  const yStep=90, xStep=22, marginX=90, marginY=90;
  const pos=new Map();
  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const y=marginY + li*yStep;
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++){
      const st=arr[i];
      const x=marginX + i*xStep;
      pos.set(line+'::'+st, {x:x,y:y});
    }
  }

  // Draw SVG
  const viewport=document.getElementById('viewport');
  const map=document.getElementById('map');
  const gLines=document.getElementById('gLines');
  const gDots=document.getElementById('gDots');
  const token=document.getElementById('token');
  const hudG=document.getElementById('hudG');
  const hudLine1=document.getElementById('hudLine1');
  const hudLine2=document.getElementById('hudLine2');

  const LINE_COLORS={"1í˜¸ì„ ":"#1e88e5","2í˜¸ì„ ":"#2e7d32","3í˜¸ì„ ":"#f9a825","4í˜¸ì„ ":"#039be5","5í˜¸ì„ ":"#8e24aa","6í˜¸ì„ ":"#6d4c41","7í˜¸ì„ ":"#7b1fa2","8í˜¸ì„ ":"#d81b60","9í˜¸ì„ ":"#b59a00","ê²½ì˜ì¤‘ì•™ì„ ":"#00838f","ì‹ ë¶„ë‹¹ì„ ":"#c62828","ìˆ˜ì¸ë¶„ë‹¹ì„ ":"#f06292"};
  const lineColor=(n)=>LINE_COLORS[n]||"#ff4d6d";
  function svgEl(tag, attrs){
    const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  let maxLen=0;
  for(const line of lineNames) maxLen=Math.max(maxLen, subwayData[line].length);
  const W=Math.max(1800, marginX + maxLen*xStep + 140);
  const H=Math.max(1100, marginY + lineNames.length*yStep + 140);
  map.setAttribute('width', String(W));
  map.setAttribute('height', String(H));
  map.setAttribute('viewBox', '0 0 '+W+' '+H);

  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const arr=subwayData[line];
    let d='';
    for(let i=0;i<arr.length;i++){
      const p=pos.get(line+'::'+arr[i]);
      d += (i===0 ? ('M '+p.x+' '+p.y) : (' L '+p.x+' '+p.y));
    }
    gLines.appendChild(svgEl('path', {d:d, class:'lineStroke', stroke: lineColor(line)}));
    gLines.appendChild(svgEl('path', {d:d, class:'lineInner'}));
    const label=svgEl('text', {x:'16', y:String(marginY + li*yStep + 5), class:'label'});
    label.textContent=line;
    gLines.appendChild(label);
  }

  stationLines.forEach((set, st)=>{
    const lines=Array.from(set);
    if(lines.length<2) return;
    const pts=[];
    for(const l of lines){ const p=pos.get(l+'::'+st); if(p) pts.push(p); }
    pts.sort((a,b)=>a.y-b.y);
    if(pts.length<2) return;
    let d='M '+pts[0].x+' '+pts[0].y;
    for(let i=1;i<pts.length;i++) d += ' L '+pts[i].x+' '+pts[i].y;
    gLines.appendChild(svgEl('path', {d:d, class:'connector'}));
  });

  stationLines.forEach((set, st)=>{
    if(set.size<2) return;
    for(const line of set){
      const p=pos.get(line+'::'+st);
      if(!p) continue;
      gDots.appendChild(svgEl('circle', {cx:String(p.x), cy:String(p.y), r:'4', class:'stationDot'}));
    }
  });

  // Drag-to-pan
  (function enableDragPan(){
    let isDown=false, startX=0, startY=0, sl=0, st=0;
    viewport.addEventListener('pointerdown',(e)=>{
      isDown=true; viewport.setPointerCapture(e.pointerId);
      startX=e.clientX; startY=e.clientY;
      sl=viewport.scrollLeft; st=viewport.scrollTop;
    });
    viewport.addEventListener('pointermove',(e)=>{
      if(!isDown) return;
      viewport.scrollLeft = sl - (e.clientX - startX);
      viewport.scrollTop  = st - (e.clientY - startY);
    });
    viewport.addEventListener('pointerup',()=>{ isDown=false; });
    viewport.addEventListener('pointercancel',()=>{ isDown=false; });
  })();

  // Confetti
  const confCanvas=document.getElementById('confetti');
  const confCtx=confCanvas.getContext('2d');
  function resizeCanvasTo(el, canvas, ctx){
    const r=el.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height};
  }
  function burstConfettiOn(canvas, ctx, w, h){
    if(canvas.__raf) cancelAnimationFrame(canvas.__raf);
    const colors=["#ff4d6d","#ff85a2","#ffd6e0","#c9184a","#ffb3c1","#ffe3ea"];
    const pieces=[];
    const count=190;
    for(let i=0;i<count;i++) pieces.push({x:w*0.5,y:h*0.32,vx:(Math.random()-0.5)*9,vy:-Math.random()*11-7,g:0.22+Math.random()*0.18,w:4+Math.random()*5,h:3+Math.random()*5,a:Math.random()*Math.PI,va:(Math.random()-0.5)*0.25,c:colors[Math.floor(Math.random()*colors.length)],life:0,max:170+Math.random()*70});
    function tick(){
      ctx.clearRect(0,0,w,h);
      let alive=0;
      for(const p of pieces){
        p.life++; if(p.life<p.max) alive++;
        p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.va;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.a);
        ctx.globalAlpha=Math.max(0,1-p.life/p.max);
        ctx.fillStyle=p.c;
        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }
      ctx.globalAlpha=1;
      if(alive>0) canvas.__raf=requestAnimationFrame(tick);
      else ctx.clearRect(0,0,w,h);
    }
    tick();
  }
  resizeCanvasTo(viewport, confCanvas, confCtx);
  window.addEventListener('resize', ()=>{ resizeCanvasTo(viewport, confCanvas, confCtx); });

  // Movement helpers
  function setTokenXY(x,y, smooth){
    token.setAttribute('transform','translate('+x+','+y+')');
    hudG.setAttribute('transform','translate('+x+','+y+')');
    if(smooth){
      viewport.scrollTo({left:Math.max(0,x-viewport.clientWidth/2), top:Math.max(0,y-viewport.clientHeight/2), behavior:'smooth'});
    }
  }
  function setTokenAt(line, st, smooth){
    const p=pos.get(line+'::'+st);
    if(!p) return;
    setTokenXY(p.x,p.y,smooth);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
  function moveSegment(lineA, stA, lineB, stB){
    const a=pos.get(lineA+'::'+stA);
    const b=pos.get(lineB+'::'+stB);
    if(!a||!b) return Promise.resolve();
    const d=dist(a,b);
    const duration=Math.max(240, Math.min(650, d*6.5));
    const start=performance.now();
    return new Promise(res=>{
      function tick(t){
        const p=Math.min(1,(t-start)/duration);
        const e=p<0.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
        setTokenXY(a.x+(b.x-a.x)*e, a.y+(b.y-a.y)*e, true);
        if(p<1) requestAnimationFrame(tick); else res();
      }
      requestAnimationFrame(tick);
    });
  }

  // Path generator: transfer only at interchange, stop at terminal, no reverse
  const MAX_STOPS=25;
  function randomWalkPath(startLine, startStation){
    let curLine = startLine;

    const idx = lineIndex[curLine][startStation];
    const arr = subwayData[curLine];

    // ì¢…ì ì—ì„œ ì¶œë°œí•˜ë©´ ë¬´ì¡°ê±´ ì¢…ì  ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì¶œë°œ
    let dir;
    if (idx === 0) dir = 1;
    else if (idx === arr.length - 1) dir = -1;
    else dir = Math.random() < 0.5 ? -1 : 1;

    const stepsPlanned = randInt(1, MAX_STOPS);
    const path = [{ line: curLine, st: startStation }];
    let curSt = startStation;

    for (let step = 1; step <= stepsPlanned; step++) {
      const linesAtCur = getLinesOf(curSt);
      if (linesAtCur.length >= 2) {
        const remain = stepsPlanned - step + 1;
        const nearEnd = remain <= 6;
        const pTransfer = nearEnd ? 0.55 : 0.22;
        if (Math.random() < pTransfer) {
          const choices = linesAtCur.filter(l => l !== curLine);
          if (choices.length) {
            curLine = pick(choices);

            // í™˜ìŠ¹ í›„ì—ë„ ì¢…ì ì´ë©´ ë°©í–¥ ë‹¤ì‹œ ë³´ì •
            const newIdx = lineIndex[curLine][curSt];
            const newArr = subwayData[curLine];
            if (newIdx === 0) dir = 1;
            else if (newIdx === newArr.length - 1) dir = -1;
          }
        }
      }

      const nextSt = getNextOnLine(curLine, curSt, dir);
      if (!nextSt) break;

      curSt = nextSt;
      path.push({ line: curLine, st: curSt });
    }

    return path;
  }

  // Result overlay
  const overlay=document.getElementById('resultOverlay');
  const resultStation=document.getElementById('resultStation');
  const resultCount=document.getElementById('resultCount');
  const resultBox=document.getElementById('resultBox');
  const resultCanvas=document.getElementById('resultCanvas');
  const resultCtx=resultCanvas.getContext('2d');

  document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; });
  document.getElementById('searchBtn').addEventListener('click', ()=>{
    const station = (resultStation.textContent || '').trim(); // includes 'ì—­'
    const query = encodeURIComponent(station + " ë°ì´íŠ¸ì½”ìŠ¤");
    window.open("https://search.naver.com/search.naver?query=" + query, "_blank");
  });

  function showResultOverlay(stationName,totalMoved){
    resultStation.textContent = formatStation(stationName);
    resultCount.textContent = 'ì´ ' + totalMoved + 'ì •ê±°ì¥ ì´ë™';
    overlay.style.display='flex';
    const dims = resizeCanvasTo(resultBox, resultCanvas, resultCtx);
    burstConfettiOn(resultCanvas, resultCtx, dims.w, dims.h);
    playFanfare();
  }

  // Init
  const startInput=document.getElementById('startInput');
  const goBtn=document.getElementById('goBtn');

  let currentStation = allStations.includes('í™”ì •') ? 'í™”ì •' : (allStations[0] || 'ì‹œì²­');
  let currentLine = getLinesOf(currentStation)[0] || lineNames[0];
  startInput.value=currentStation;
  setTokenAt(currentLine,currentStation,true);
  hudLine1.textContent=formatStation(currentStation);
  hudLine2.textContent='ì´ë™: 0ì •ê±°ì¥';
  let animating=false;

  function findStartStation(input){
    const q=normalizeName(input);
    for(const s of allStations) if(normalizeName(s)===q) return s;
    return null;
  }

  async function animatePath(path){
    let moved=0;
    for(let i=0;i<path.length;i++){
      const cur=path[i];
      hudLine1.textContent=formatStation(cur.st);
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';
      if(i===0){ setTokenAt(cur.line,cur.st,true); await sleep(280); continue; }
      const prev=path[i-1];
      await moveSegment(prev.line,prev.st,cur.line,cur.st);
      moved++;
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';
      playTick();
      await sleep(160);
      const remain=(path.length-1)-i;
      const t=Math.max(0,6-remain);
      const jitter=Math.floor(Math.random()*180);
      const curve=t===0 ? 1 : (1 + 0.14*t*t);
      let ms=(380 + jitter)*curve;
      if(remain<=2) ms += 260;
      await sleep(ms);
    }
    return moved;
  }

  async function finale(targetStation,totalMoved){
    playDing();
    const dims = resizeCanvasTo(viewport, confCanvas, confCtx);
    burstConfettiOn(confCanvas, confCtx, dims.w, dims.h);
    showResultOverlay(targetStation,totalMoved);
  }

  async function onStart(){
    if(animating) return;
    const startStation=findStartStation(startInput.value);
    if(!startStation){ showErr('ì¶œë°œì—­ ì˜¤íƒ€! ì˜ˆ: í˜œí™”, ë™ëŒ€ë¬¸, í™”ì •, ê°•ë‚¨'); return; }
    animating=true; goBtn.disabled=true;
    startBGM();
    overlay.style.display='none';
    currentStation=startStation;
    currentLine=getLinesOf(currentStation)[0] || lineNames[0];
    const path=randomWalkPath(currentLine,currentStation);
    const last=path[path.length-1];
    const moved=await animatePath(path);
    await finale(last.st,moved);
    currentStation=last.st;
    currentLine=last.line;
    animating=false; goBtn.disabled=false;
  }

  goBtn.addEventListener('click', onStart);
  goBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
})();
</script>
</body>
</html>
