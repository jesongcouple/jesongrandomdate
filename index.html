<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="theme-color" content="#ff4d6d" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- iOS í™ˆí™”ë©´ ì•„ì´ì½˜ì€ manifestë³´ë‹¤ apple-touch-iconì„ ìš°ì„ í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ -->
<link rel="apple-touch-icon" href="./apple-touch-icon.png" />
<!-- ë¸Œë¼ìš°ì € íƒ­ ì•„ì´ì½˜(ì„¤ì¹˜í˜• ì•„ì´ì½˜ê³¼ ë³„ê°œ) -->
<link rel="icon" href="./icon-192.png" type="image/png" sizes="192x192" />
<link rel="icon" href="./icon-512.png" type="image/png" sizes="512x512" />
<title>ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</title>
<style>
:root{--main:#ff4d6d;--bg:#fff0f3;--ink:#c9184a;--stageWpx:320px;--stageHpx:560px;--splashWpx:320px;--splashHpx:560px;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;font-family:-apple-system,system-ui,sans-serif;}
html,body{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
*{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
svg,svg *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
img,svg{ -webkit-user-drag:none; user-drag:none; }
input,button,textarea,select{ -webkit-user-select:none; user-select:none; }

body{margin:0;background:var(--bg);}
.wrap{max-width:520px;margin:0 auto;padding:14px;}
.card{background:#fff;border:6px solid #ffccd5;border-radius:28px;padding:14px;box-shadow:0 14px 30px rgba(255,77,109,.18);}
.title{font-weight:900;color:var(--ink);font-size:20px;margin:0 0 14px;text-align:center;}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
input{flex:1;min-width:180px;padding:12px 14px;border-radius:18px;border:3px solid #ffccd5;font-size:16px;outline:none;text-align:center;}

/* === True Random mode: lock start input + sparkle text === */
.trueRandomInput{
  color:#ff4d6d !important;
  font-weight:1000 !important;
  letter-spacing:0.4px;
  border-color:#ff8fa3 !important;
  /* í…Œë‘ë¦¬ëŠ” ê¹œë¹¡ì´ì§€ ì•Šê³  ì€ì€í•˜ê²Œ ë¹›ë‚˜ê¸°ë§Œ */
  box-shadow: 0 0 0 3px rgba(255,77,109,0.18), 0 0 18px rgba(255,77,109,0.22);
  /* ë°˜ì§ì„ì€ ê¸€ìë§Œ */
  animation: trSparkle 1.1s ease-in-out infinite;
}
@keyframes trSparkle{
  0%{ text-shadow: 0 0 4px rgba(255,77,109,0.30), 0 0 10px rgba(255,77,109,0.18); }
  50%{ text-shadow: 0 0 8px rgba(255,77,109,0.55), 0 0 18px rgba(255,77,109,0.28); }
  100%{ text-shadow: 0 0 5px rgba(255,77,109,0.32), 0 0 12px rgba(255,77,109,0.20); }
}
button{padding:12px 16px;border:0;border-radius:999px;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:#fff;font-weight:900;font-size:16px;box-shadow:0 10px 18px rgba(255,77,109,.25);cursor:pointer;}
button:disabled{background:#ccc;box-shadow:none;cursor:default;}
.stageWrap{margin-top:12px;width:var(--stageWpx);height:var(--stageHpx);margin-left:auto;margin-right:auto;background:#fff8f9;border:2px solid #ffd6df;border-radius:22px;overflow:hidden;position:relative;}
.viewport{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;background:#fff8f9;position:relative;touch-action:pan-x pan-y;}
.viewport{scrollbar-width:none;-ms-overflow-style:none;}
.viewport::-webkit-scrollbar{width:0;height:0;display:none;}

svg{display:block;}
.lineStroke{stroke-width:22;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;filter:drop-shadow(0 10px 14px rgba(0,0,0,.10));}
.lineInner{stroke:#fff;stroke-width:7;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;}
.connector{stroke:#ffb3c1;stroke-width:5;stroke-linecap:round;opacity:.75;fill:none;}
.label{font-size:11px;font-weight:900;fill:#c9184a;opacity:1;}
.stationDot{fill:#fff;stroke:var(--main);stroke-width:4;opacity:1;}
.token{filter:drop-shadow(0 10px 12px rgba(0,0,0,.16));}
.token circle,.token rect{fill:var(--main);stroke:#fff;stroke-width:4;}
#hudRect{fill:white;stroke:#ffccd5;stroke-width:4;opacity:.94;}
#confetti{position:absolute;inset:0;pointer-events:none;z-index:20;}

#resultOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;}
#resultBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
#resultBox{position:relative;width:min(360px,86vw);background:#fff;border-radius:24px;padding:22px 26px;text-align:center;border:4px solid #ffccd5;box-shadow:0 20px 40px rgba(255,77,109,.25);overflow:hidden;}
#resultCanvas{position:absolute;inset:0;pointer-events:none;z-index:2;}
#resultContent{position:relative;z-index:3;}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;display:none;background:rgba(0,0,0,.85);color:#fff;padding:12px 14px;border-radius:14px;font-weight:900;font-size:11px;line-height:1.35;}

/* --- Splash (tap -> loading -> reveal) --- */
#startOverlay{
  position:fixed;
  inset:0;
  z-index:100000;
  background:var(--bg);
  opacity:1;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0; /* ì¹´ë“œì²˜ëŸ¼ ì‘ê²ŒëŠ” ì•ˆ ë³´ì´ë˜, ìŠ¤í¬ë¡¤/ë„˜ì¹¨ ë°©ì§€ìš© ìµœì†Œ ì—¬ë°± */
  touch-action:manipulation;
  user-select:none;
}
#startOverlay.fadeOut{ opacity:0; transition:opacity .55s ease; }

.splashStage{
  width:var(--splashWpx);
  height:var(--splashHpx);
  border-radius:0;
  overflow:hidden;
  border:0;
  background:var(--bg);
  position:relative;
}
#splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
#tapHintWrap, #splashLoading{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  text-align:center;
  width:100%;
  padding:0 14px;
}
#tapHint{
  font-size:18px;
  font-weight:1000;
  letter-spacing:0.5px;
  color:rgba(255,255,255,.96);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  animation:tapPulse 1.05s ease-in-out infinite;
}
@keyframes tapPulse{
  0%{ transform:scale(.98); opacity:.55; }
  45%{ transform:scale(1.04); opacity:1; }
  100%{ transform:scale(.98); opacity:.55; }
}
#splashLoading{
  font-size:20px;
  font-weight:1000;
  letter-spacing:1px;
  color:rgba(255,255,255,.95);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  display:none;
  line-height:1;
}
#splashLoading.show{ display:block; }
#splashLoading .dots::after{ content:""; animation:dots 1.05s steps(4,end) infinite; }
#splashLoading .blink{ animation:blink 0.55s steps(2,end) infinite; }
@keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:.25} }
@keyframes dots{ 0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""} }
#startOverlay.loading #splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
@keyframes loadingZoom{ 0%{ transform:scale(1); filter:saturate(1.05); } 50%{ transform:scale(1.02); filter:saturate(1.15); } 100%{ transform:scale(1); filter:saturate(1.05); } }

/* --- Mini settings button & modal --- */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:800;
  font-size:17px;
  line-height:1;
  box-shadow:0 6px 12px rgba(255,77,109,.18);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
}
.miniBtn:active{ transform:translateY(1px) scale(.99); }

#settingsOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9000;
}
#settingsOverlay.show{ display:flex; }
#settingsBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
}
#settingsBox{
  border:3px solid #ffd6df;
  position:relative;
  width:min(380px, 88vw);
  background:#fff;
  border-radius:24px;
  padding:20px 22px 18px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.settingsTitle{
  font-weight:1000;
  font-size:16px;
  color:#d6336c;
  text-align:center;
  margin-bottom:14px;
}
.settingsRow{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:12px 10px;
  border-radius:18px;
  background:#fff8f9;
  border:3px solid #ffccd5;
  margin-bottom:10px;
  text-align:center;
}

/* Combined min/max row (one box) */
.settingsRowCombined{ padding:14px 12px; }

#stopsRow.controlsDisabled{
  pointer-events:none;
}
#stopsRow.controlsDisabled .settingsLabel{
  opacity:.85;
}
#stopsRow.controlsDisabled .stepBtn,
#stopsRow.controlsDisabled .numInput{
  filter:saturate(.9);
}
.stopsGrid{
  width:100%;
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  align-items:center;
  justify-items:center;
}
.stopItem{ width:100%; display:flex; flex-direction:column; align-items:center; gap:8px; }
.stopItem .numInput{ width:78px; min-width:78px; }
.stopItem .stepBtn{ width:40px; height:40px; border-radius:14px; }

/* True random row: a bit darker / more present */
.settingsRowStrong{
  background:linear-gradient(180deg,#ffe3ea,#ffd2dc);
  border-color:#ff8fa3;
}
.settingsLabel{
  font-weight:900;
  font-size:13px;
  color:#d6336c;
  white-space:nowrap;
  width:100%;
  text-align:center;
}
.stepper{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}
.numInput{
  width:84px;
  min-width:84px;
  padding:10px 10px;
  border-radius:14px;
  border:2px solid #ffd6df;
  font-weight:1000;
  font-size:16px;
  text-align:center;
  outline:none;
}
.stepBtn{
  touch-action:manipulation;
  user-select:none;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:16px;
  line-height:1;
  box-shadow:0 10px 18px rgba(255,77,109,.18);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
}
.stepBtn:active{ transform:translateY(1px) scale(.99); }
.stepBtn:disabled{ opacity:.35; cursor:not-allowed; pointer-events:none; filter:grayscale(.1); }
.stepBtn:disabled:active{ transform:none; }

.settingsHint{
  margin:8px 2px 14px;
  font-weight:900;
  font-size:11px;
  color:#ff4d6d;
  text-align:center;
  opacity:.92;
}
.settingsActions{
  display:flex;
  justify-content:center;
  gap:10px;
}
.ghostBtn{
  padding:10px 16px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:#fff0f3;
  color:#d6336c;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
}
.solidBtn{
  padding:10px 18px;
  border-radius:999px;
  border:0;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
}


/* === Visual viewport height var (mobile Safari fix) === */
:root{ --vvh: 1vh; }
#startOverlay{ height: calc(var(--vvh) * 100); }
#splashStage{ height: calc(var(--vvh) * 100); width: 100%; }


/* === Settings UI tone override (softer) === */
.miniBtn{
  width:40px !important;
  height:40px !important;
  border-radius:12px !important;
  border:2px solid #ffd6df !important;
  background: rgba(255,240,243,.92) !important;
  color:#c9184a !important;
  box-shadow:0 6px 12px rgba(201,24,74,.12) !important;
  font-weight:900 !important;
}
.miniBtn:hover{ filter:none !important; }
.stepBtn{
  border:2px solid #ffd6df !important;
  background: linear-gradient(135deg,#ff8fa3,#ffb3c1) !important;
  box-shadow:0 6px 12px rgba(201,24,74,.10) !important;
}
#settingsBox{
  border:3px solid #ffd6df !important;
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 4px 8px rgba(201,24,74,.16),
    inset 0 1px 0 rgba(255,255,255,.7) !important;
}


/* === Mobile splash: fill the whole screen (no side gaps) === */
@media (max-width: 700px){
  #startOverlay{ padding:0 !important; }
  .splashStage{ width:100vw !important; height:calc(var(--vvh) * 100) !important; }
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}


/* === Settings button: deep pink 3D === */
.miniBtn{
  background: linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  border:2px solid #ffb3c1 !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}





/* === Settings button redraw (border + 3D, no mismatch) === */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:46px;
  height:46px;
  border-radius:16px;
  border:0 !important;
  background: linear-gradient(180deg,#ff7a9b 0%, #ff3d66 100%) !important;
  color:#fff !important;
  font-weight:900;
  font-size:18px;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
  box-shadow: 0 12px 18px rgba(201,24,74,.22);
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:16px;
  box-shadow:
    inset 0 0 0 3px rgba(255,204,213,.95),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.14);
  pointer-events:none;
}
.miniBtn::after{
  content:"";
  position:absolute;
  inset:4px;
  border-radius:12px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%);
  pointer-events:none;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98);
  box-shadow: 0 8px 12px rgba(201,24,74,.20);
}
@media (max-width:700px){
  .miniBtn{ right: calc(10px + env(safe-area-inset-right)); bottom: calc(10px + env(safe-area-inset-bottom)); }
}


/* === Settings button border redraw (perfect match) === */
.miniBtn{
  position:absolute !important;
  right:10px !important;
  bottom:10px !important;
  width:46px !important;
  height:46px !important;
  border-radius:16px !important;
  border:none !important;            /* border drawn by ::before */
  background:linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  cursor:pointer !important;
  z-index:30 !important;
  padding:0 !important;
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  border:3px solid rgba(255,204,213,.95);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    0 0 0 1px rgba(255,204,213,.15);
  pointer-events:none;
}
.miniBtn:active{
  transform:translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}



/* === Pan extra space: allow camera to truly center token (top+bottom) === */
#panTopPad{ height:120px; width:1px; }
#panBottomPad{ height:900px; width:1px; }


.row{position:relative;z-index:50;}


/* Hide native number input spinners (use our icon buttons instead) */
.numInput::-webkit-outer-spin-button,
.numInput::-webkit-inner-spin-button{
  -webkit-appearance: none;
  margin: 0;
}
.numInput{
  -moz-appearance: textfield;
  appearance: textfield;
}


/* === True Random Toggle Switch === */
.toggleSwitch{ position:relative; display:inline-flex; align-items:center; width:fit-content;  pointer-events:none; }
.toggleSwitch input{ position:absolute; opacity:0; width:1px; height:1px; }
.toggleTrack{
  display:inline-block;
  pointer-events:auto;
  touch-action:manipulation;
  width:78px; height:42px;
  border-radius:999px;
  background: linear-gradient(180deg,#ffe3ea 0%, #ffd6df 100%);
  border:3px solid #ffccd5;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.06);
  position:relative;
  transition: all .22s ease;
  cursor:pointer;
}
.toggleKnob{
  z-index:2;
  position:absolute; top:50%; left:4px;
  width:34px; height:34px;
  border-radius:999px;
  transform: translateY(-50%);
  background: linear-gradient(180deg,#ffffff 0%, #fff7f9 100%);
  border:2px solid rgba(255,204,213,.9);
  box-shadow: 0 8px 14px rgba(201,24,74,.14);
  transition: all .22s ease;
}
.toggleText{
  z-index:1;
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 9px;
  font-weight:1000;
  font-size:11px;
  letter-spacing:.5px;
  color: rgba(201,24,74,.45);
  pointer-events:none;
}
.toggleText span{ display:inline-block;  opacity:.55; transition:opacity .22s ease; min-width:28px; text-align:center; }
.toggleText .on{ opacity:.25; transform:translateX(2px); }
.toggleText .off{ opacity:.75; transform:translateX(-2px); }

.toggleSwitch input:checked ~ .toggleTrack{
  background: linear-gradient(135deg,#ff8fa3 0%, #ff4d6d 100%);
  border-color:#ffb3c1;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.07), 0 10px 18px rgba(201,24,74,.14);
}
.toggleSwitch input:checked ~ .toggleTrack .toggleKnob{
  z-index:2; left: calc(100% - 4px - 34px); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText{
  z-index:1; color: rgba(255,255,255,.88); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .on{ opacity:.95; }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .off{ opacity:.35; }

.hotPink{ color:#ff4d6d !important; font-weight:1000 !important; }



/* iOS audio resume notice */
#resumeNotice{position:fixed;left:50%;transform:translateX(-50%);bottom:110px;z-index:9999;padding:8px 12px;border-radius:12px;background:rgba(255,255,255,.92);color:#444;font-size:12px;box-shadow:0 8px 18px rgba(0,0,0,.12);display:none;pointer-events:none;}

/* === Sound control button (above settings) === */
.soundBtn{
  bottom:64px !important; /* above âš™ï¸ */
}

/* === Sound overlay (volume) === */
#audioOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9050; /* above settings (9000) */
}
#audioOverlay.show{ display:flex; }
#audioBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
}
#audioBox{
  position:relative;
  width:min(420px, 92vw);
  background:#fff;
  border-radius:26px;
  padding:18px 18px 16px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.audioTitle{
  font-weight:1000;
  font-size:18px;
  color:#d6336c;
  text-align:center;
  margin:2px 0 12px;
}
.audioTopActions{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:center;
  margin-bottom:10px;
}
.audioRoundBtn{
  width:46px;
  height:46px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:linear-gradient(180deg,#ffe3ea 0%, #ffd2dc 100%);
  box-shadow:
    0 10px 16px rgba(201,24,74,.18),
    inset 0 2px 0 rgba(255,255,255,.45),
    inset 0 -2px 0 rgba(0,0,0,.08);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:18px;
  cursor:pointer;
  user-select:none;
}
.audioRoundBtn:active{ transform:translateY(1px) scale(.98); }

.audioCard{
  width:100%;
  background:#fff8f9;
  border:3px solid #ffccd5;
  border-radius:20px;
  padding:12px 12px 14px;
  margin:10px 0;
}
.audioLabel{
  font-weight:1000;
  font-size:14px;
  color:#d6336c;
  text-align:center;
  margin-bottom:10px;
}
.audioRow{
  display:flex;
  align-items:center;
  gap:10px;
  width:100%;
}
.audioHint{
  width:26px;
  text-align:center;
  font-size:14px;
  opacity:.55;
  user-select:none;
}
.audioRange{
  flex:1 1 auto;
  width:100%;
  min-width:0;
  max-width:none;
  -webkit-appearance:none;
  appearance:none;
  height:8px;
  border-radius:999px;
  background:#e9ecef;
  outline:none;
}
.audioRange::-webkit-slider-thumb{
  -webkit-appearance:none;
  appearance:none;
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioRange::-moz-range-thumb{
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioCloseRow{
  display:flex;
  justify-content:center;
  margin-top:12px;
}
.audioCloseBtn{
  width:100%;
  padding:14px 16px;
  border-radius:999px;
  border:none;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:18px;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
  cursor:pointer;
}
.audioCloseBtn:active{ transform:translateY(1px) scale(.99); }


/* === Modal behavior: block background interaction when overlays are open === */
body.overlayOpen .wrap,
body.overlayOpen canvas{
  pointer-events:none;
}
#settingsOverlay,
#audioOverlay{
  pointer-events:auto;
}


/* Modal interaction blocker (prevents any background taps/drags) */
.modalBlocker{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0);
  z-index: 9998;
  display: none;
  touch-action: none;
}
body.overlayOpen .modalBlocker{ display:block; }
/* Ensure overlays are above blocker */
#settingsOverlay, #audioOverlay{ z-index: 10000; }


/* === FIX: range reaches visual edges (speaker + range + speaker via grid) === */
.sound-slider-wrap{
  display: grid !important;
  grid-template-columns: auto 1fr auto !important;
  align-items: center !important;
  column-gap: 8px !important;
  width: 100% !important;
}
.sound-slider-wrap input[type="range"]{
  width: 100% !important;
  min-width: 0 !important;
  margin: 0 !important;
}
/* Ensure rows don't shrink the range */
.audioRow{ width: 100% !important; }
.audioRange{
  width: 100% !important;
  max-width: none !important;
  min-width: 0 !important;
}

</style>
</head>

<body>

<!-- Splash -->
<div id="startOverlay" aria-label="ì‹œì‘ í™”ë©´" role="button" tabindex="0">
  <div class="splashStage">
    <img id="splashImg" src="./splash-bg.png" alt="ì œâ¤ï¸ì†¡ ëœë¤ë°ì´íŠ¸ ì‹œì‘ í™”ë©´" />
    <div id="tapHintWrap"><div id="tapHint">í™”ë©´ì„ í„°ì¹˜í•´ì£¼ì„¸ìš”</div></div>
    <div id="splashLoading" aria-live="polite"><span class="blink">ë¡œë”©ì¤‘</span><span class="dots"></span></div>
  </div>
</div>

<!-- Game UI -->
<div class="wrap">
  <div class="card">
    <h1 class="title">ì œâ€¢ì†¡ ëœë¤ë°ì´íŠ¸</h1>
    <div class="row">
      <input id="startInput" inputmode="text" autocomplete="off" spellcheck="false" placeholder="ì¶œë°œì—­ (ì˜ˆ: í˜œí™”)" />
      <button id="goBtn">ì¶œë°œ</button>
    </div>

    <div class="stageWrap">
      <div class="viewport" id="viewport">
        <div id="panTopPad" aria-hidden="true"></div>
        <svg id="map">
          <g id="mapShift">
          <g id="gLines"></g>
          <g id="gDots"></g>

          <!-- HUD -->
          <g id="hudG">
            <rect id="hudRect" x="-120" y="-40" rx="16" ry="16" width="240" height="74"></rect>
            <text id="hudLine1" x="0" y="-12" text-anchor="middle" dominant-baseline="middle" font-size="14" font-weight="900" fill="#c9184a">-</text>
            <text id="hudLine2" x="0" y="12" text-anchor="middle" dominant-baseline="middle" font-size="12" font-weight="900" fill="#ff4d6d">-</text>
          </g>

          <!-- Token -->
          <g id="token" class="token">
            <!-- head + body (refined) -->
            <circle cx="0" cy="-14" r="9"></circle>
            <rect x="-10" y="-2" width="20" height="24" rx="6" ry="6"></rect>
          </g>
                  </g>
        </svg>
        <div id="panBottomPad" aria-hidden="true"></div>
      </div>
      <canvas id="confetti"></canvas>

      <!-- Settings button (bottom-right) -->
      <button id="audioBtn" class="miniBtn soundBtn" type="button" aria-label="ìŒí–¥ ì„¤ì •">ğŸ”Š</button>
      <button id="settingsBtn" class="miniBtn" type="button" aria-label="ì´ë™ ì •ê±°ì¥ ì„¤ì •">âš™ï¸</button>
    </div>
  </div>
</div>

<!-- Settings overlay -->
<div id="settingsOverlay" aria-hidden="true">
  <div id="settingsBackdrop"></div>
  <div id="settingsBox" role="dialog" aria-modal="true" aria-label="í™˜ê²½ì„¤ì •">
    <div class="settingsTitle">í™˜ê²½ì„¤ì •</div>

    <!-- Combined: min/max stops in one box -->
    <div class="settingsRow settingsRowCombined" id="stopsRow">
      <div class="stopsGrid">
        <div class="stopItem">
          <div class="settingsLabel">ìµœì†Œ ì´ë™ì—­</div>
          <div class="stepper">
            <button type="button" class="stepBtn" data-step="min" data-delta="-1" aria-label="ìµœì†Œ ê°ì†Œ">â–¾</button>
            <input id="minStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" />
            <button type="button" class="stepBtn" data-step="min" data-delta="1" aria-label="ìµœì†Œ ì¦ê°€">â–´</button>
          </div>
        </div>
        <div class="stopItem">
          <div class="settingsLabel">ìµœëŒ€ ì´ë™ì—­</div>
          <div class="stepper">
            <button type="button" class="stepBtn" data-step="max" data-delta="-1" aria-label="ìµœëŒ€ ê°ì†Œ">â–¾</button>
            <input id="maxStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" value="25" />
            <button type="button" class="stepBtn" data-step="max" data-delta="1" aria-label="ìµœëŒ€ ì¦ê°€">â–´</button>
          </div>
        </div>
      </div>
    </div>

    <div class="settingsRow settingsRowStrong" id="trueRandomRow">
      <div class="settingsLabel hotPink">ì°ëœë¤ ëª¨ë“œ</div>
      <div class="stepper" style="gap:10px;">
        <div class="toggleSwitch" aria-label="ì°ëœë¤ ëª¨ë“œ í† ê¸€">
          <input id="trueRandomToggle" type="checkbox" />
          <span class="toggleTrack" id="trueRandomTrack" role="switch" tabindex="0" aria-checked="false" aria-label="ì°ëœë¤ ëª¨ë“œ">
            <span class="toggleText" aria-hidden="true"><span class="off">OFF</span><span class="on">ON</span></span>
            <span class="toggleKnob" aria-hidden="true"></span>
          </span>
        </div>
      </div>
    </div>
<div class="settingsActions">
      <button type="button" id="settingsCancel" class="ghostBtn">ì·¨ì†Œ</button>
      <button type="button" id="settingsOk" class="solidBtn">í™•ì¸</button>
    </div>
  </div>
</div>


<!-- Audio overlay -->
<div id="audioOverlay" aria-hidden="true">
  <div id="audioBackdrop"></div>
  <div id="audioBox" role="dialog" aria-modal="true" aria-label="ìŒí–¥ ì¡°ì ˆ">
    <div class="audioTitle">ìŒí–¥ ì¡°ì ˆ</div>

    <div class="audioTopActions">
      <button type="button" id="audioMuteBtn" class="audioRoundBtn" aria-label="ìŒì†Œê±°">ğŸ”‡</button>
      <button type="button" id="audioResetBtn" class="audioRoundBtn" aria-label="ì´ˆê¸°í™”">â†º</button>
    </div>

    <div class="audioCard">
      <div class="audioLabel">ì´ë™</div>
      <div class="audioRow">
        <span class="audioHint">ğŸ”ˆ</span>
        <input id="volMoveRange" class="audioRange" type="range" min="0" max="2000" value="1000" step="1" />
        <span class="audioHint">ğŸ”Š</span>
      </div>
    </div>

    <div class="audioCard">
      <div class="audioLabel">í™˜ìŠ¹</div>
      <div class="audioRow">
        <span class="audioHint">ğŸ”ˆ</span>
        <input id="volTransferRange" class="audioRange" type="range" min="0" max="5000" value="2500" step="1" />
        <span class="audioHint">ğŸ”Š</span>
      </div>
    </div>

    <div class="audioCard">
      <div class="audioLabel">ë„ì°©</div>
      <div class="audioRow">
        <span class="audioHint">ğŸ”ˆ</span>
        <input id="volArriveRange" class="audioRange" type="range" min="0" max="1000" value="500" step="1" />
        <span class="audioHint">ğŸ”Š</span>
      </div>
    </div>

    <div class="audioCloseRow">
      <button type="button" id="audioCloseBtn" class="audioCloseBtn">ë‹«ê¸°</button>
    </div>
  </div>
</div>


<!-- Result overlay -->
<div id="resultOverlay">
  <div id="resultBackdrop"></div>
  <div id="resultBox">
    <canvas id="resultCanvas"></canvas>
    <div id="resultContent">
      <div style="font-size:13px;font-weight:900;color:#777;">ìµœì¢… ë„ì°©</div>
      <div id="resultStation" style="margin-top:6px;font-size:26px;font-weight:900;color:#d6336c;"></div>
      <div id="resultCount" style="margin-top:10px;font-size:15px;font-weight:900;color:#ff4d6d;"></div>
      <button id="searchBtn" style="margin-top:12px;padding:10px 16px;border-radius:999px;border:none;background:#fff0f3;color:#d6336c;font-weight:900;font-size:14px;cursor:pointer;border:2px solid #ffccd5;">ë°ì´íŠ¸ì½”ìŠ¤ ì•Œì•„ë³´ê¸°ğŸ”</button>
      <button id="closeBtn" style="margin-top:14px;padding:10px 16px;border-radius:999px;border:none;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:white;font-weight:900;font-size:14px;cursor:pointer;">í™•ì¸ â¤ï¸</button>
    </div>
  </div>
</div>

<div id="err"></div>


  <audio id="sfxTransfer" src="" preload="auto"></audio>
<script>
let audioCtx = null;
let transferGain = null;
let transferSource = null;

  
// --- Transfer SFX: robust restart on iOS using AudioBuffer one-shots ---
let transferBuffer = null;
let transferOneShot = null;
let transferLoadStarted = false;

async function loadTransferBuffer(){
  try{
    if(transferLoadStarted) return;
    transferLoadStarted = true;
    if(!audioCtx) return;
    if(transferBuffer) return;
    const url = (typeof TRANSFER_SFX_URL !== 'undefined') ? TRANSFER_SFX_URL : 'transfer-loop.mp3';
    const res = await fetch(url, { cache: 'force-cache' });
    const arr = await res.arrayBuffer();
    // decodeAudioData returns a promise in modern browsers; in older it uses callbacks
    transferBuffer = await audioCtx.decodeAudioData(arr);
  }catch(e){
    // If decode fails, allow fallback to <audio> element
    transferBuffer = null;
  }
}
const TRANSFER_SFX_URL = new URL('transfer-loop.mp3', window.location.href).href;

function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

// Persistent settings keys
const LAST_STATION_KEY = "jesong_last_station";
const MIN_STOPS_KEY = "jesong_min_stops";
const MAX_STOPS_KEY = "jesong_max_stops";
const TRUE_RANDOM_KEY = "jesong_true_random";
const DEFAULT_FIRST_STATION = "ì„œìš¸ì—­";


(function(){
  const errEl=document.getElementById('err');
  function showErr(msg){
    errEl.textContent=msg;
    errEl.style.display='block';
    clearTimeout(showErr.__t);
    showErr.__t=setTimeout(()=>{ errEl.style.display='none'; }, 3200);
  }
  window.addEventListener('error',(e)=>showErr('JS ì—ëŸ¬: '+(e.message||'unknown')));
  window.addEventListener('unhandledrejection',(e)=>showErr('Promise ì—ëŸ¬: '+(e.reason?.message||e.reason||'unknown')));  // Responsive stage sizing (game + splash)
  function setStageSize(){
    const vv=window.visualViewport;
    const vw=(vv&&vv.width)||window.innerWidth;
    const vh=(vv&&vv.height)||window.innerHeight;

    const card=document.querySelector('.card');
    const title=document.querySelector('.title');
    const row=document.querySelector('.row');

    const wrapPad = 28; // .wrap padding (14*2)
    const maxW = Math.min(520, (card ? (card.clientWidth - 28) : (vw - wrapPad)));

    const titleH = title ? title.getBoundingClientRect().height : 0;
    const rowH   = row   ? row.getBoundingClientRect().height   : 0;
    const chrome = 34;

    const availableH = vh - (titleH + rowH) - chrome - 18;
    const maxH = Math.min(980, Math.max(480, availableH));

    // Game: keep as-is (no scroll on web)
    const HEIGHT_FACTOR = 0.92;
    const w = Math.max(300, Math.min(maxW, maxW));
    const h = Math.max(420, Math.min(maxH, maxH * HEIGHT_FACTOR));    // Splash: ì‹œì‘í™”ë©´ì€ ìŠ¤í”Œë˜ì‹œ ì´ë¯¸ì§€ ë¹„ìœ¨(9:16)ì„ ìœ ì§€í•˜ë©´ì„œ,
    // ì›¹ì—ì„œ 'í° í™”ë©´ 1ëŒ€'ê°€ ì¤‘ì•™ì— í¬ê²Œ ë³´ì´ë„ë¡(ìŠ¤í¬ë¡¤ ì—†ì´) ê°€ëŠ¥í•œ í•œ í¬ê²Œ ë§ì¶˜ë‹¤.
    // â€» ê²Œì„ ë¹„ìœ¨ì„ ë”°ë¼ê°€ë©´ ì‹œì‘í™”ë©´ì´ ì˜†ìœ¼ë¡œ ë„“ì–´ì ¸ì„œ(=ê°€ë¡œ ê³¼í™•ëŒ€) ì—¬ê¸°ì„œëŠ” ì´ë¯¸ì§€ ë¹„ìœ¨ì„ ê³ ì •í•œë‹¤.
    const splashRatio = 16/9; // height / width (ìŠ¤í”Œë˜ì‹œ ì›ë³¸ ë¹„ìœ¨)
    // ëª¨ë°”ì¼ì—ì„œëŠ” ë¹ˆê³µê°„ ì—†ê²Œ 'ë³´ì´ëŠ” í™”ë©´(visual viewport)'ì„ ê½‰ ì±„ìš°ê²Œ í•¨
    let splashW, splashH;

    // Mobile: fill the visible viewport (no blanks)
    if (vw <= 700){
      splashW = vw;
      splashH = vh;
    } else {
      // Desktop/web: keep centered 'phone screen' frame
      splashH = Math.min(vh, maxH);
      splashW = splashH / splashRatio;
      if (splashW > maxW){
        splashW = maxW;
        splashH = splashW * splashRatio;
      }
    }

    const root=document.documentElement;
    root.style.setProperty('--stageWpx', w.toFixed(2)+'px');
    root.style.setProperty('--stageHpx', h.toFixed(2)+'px');
    root.style.setProperty('--splashWpx', splashW.toFixed(2)+'px');
    root.style.setProperty('--splashHpx', splashH.toFixed(2)+'px');
  }

  function min(a,b,c){ return Math.min(a,b,c); }

  window.addEventListener('resize', setStageSize, {passive:true});
  window.addEventListener('orientationchange', setStageSize, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', setStageSize, {passive:true});
  setStageSize();

  // Splash: tap -> loading -> reveal
  const splash=document.getElementById('startOverlay');
  const hintWrap=document.getElementById('tapHintWrap');
  const loadingWrap=document.getElementById('splashLoading');
  let splashStarted=false;

  function removeSplash(){
    if(!splash) return;
    splash.classList.add('fadeOut');
    setTimeout(()=>{ try{ splash.remove(); } catch(e){ splash.style.display='none'; } }, 600);
  }

  function beginSplashLoading(){
    if(!splash || splashStarted) return;
    splashStarted=true;
    // prevent double taps during loading but keep initial tap working
    splash.style.pointerEvents='none';
    splash.classList.add('loading');
    if(hintWrap) hintWrap.style.display='none';
    if(loadingWrap) loadingWrap.classList.add('show');

    // Give some action: subtle tick every 240ms
    let ticks=0;
    const iv=setInterval(()=>{ ticks++; if(ticks>12) clearInterval(iv); else { try{ playTick(); }catch(e){} } }, 240);

    setTimeout(()=>{
      try{ clearInterval(iv); }catch(e){}
      removeSplash();
      // After splash disappears (fadeOut 600ms), force-center on the token.
      scheduleInitialCenter();
      setTimeout(()=>{ try{ snapCameraToTokenNow(); }catch(e){} }, 650);
    }, 3000);
  }

  if(splash){
    // iOS/Safari reliability: use pointerdown/touchstart (click can be delayed or swallowed)
    const onSplashGesture = (e)=>{
      // prevent accidental scrolling / selection during splash tap
      try{ e.preventDefault(); }catch(err){}
      beginSplashLoading();
    };
    splash.addEventListener('pointerdown', onSplashGesture, {passive:false});
    splash.addEventListener('touchstart', onSplashGesture, {passive:false});
    splash.addEventListener('click', (e)=>{ try{ e.preventDefault(); }catch(err){} beginSplashLoading(); }, {passive:false});
    splash.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') beginSplashLoading(); });
  }

  const DATA = {"1í˜¸ì„ ":["ì—°ì²œ","ì „ê³¡","ì²­ì‚°","ì†Œìš”ì‚°","ë™ë‘ì²œ","ì§€í–‰","ë•ì •","ë•ê³„","ì–‘ì£¼","ë…¹ì–‘","ê°€ëŠ¥","ì˜ì •ë¶€","íšŒë£¡","ë§ì›”ì‚¬","ë„ë´‰ì‚°","ë„ë´‰","ë°©í•™","ì°½ë™","ë…¹ì²œ","ì›”ê³„","ê´‘ìš´ëŒ€","ì„ê³„","ì‹ ì´ë¬¸","ì™¸ëŒ€ì•","íšŒê¸°","ì²­ëŸ‰ë¦¬","ì œê¸°ë™","ì‹ ì„¤ë™","ë™ë¬˜ì•","ë™ëŒ€ë¬¸","ì¢…ë¡œ5ê°€","ì¢…ë¡œ3ê°€","ì¢…ê°","ì‹œì²­","ì„œìš¸ì—­","ë‚¨ì˜","ìš©ì‚°","ë…¸ëŸ‰ì§„","ëŒ€ë°©","ì‹ ê¸¸","ì˜ë“±í¬","ì‹ ë„ë¦¼","êµ¬ë¡œ","êµ¬ì¼","ê°œë´‰","ì˜¤ë¥˜ë™","ì˜¨ìˆ˜","ì—­ê³¡","ì†Œì‚¬","ë¶€ì²œ","ì¤‘ë™","ìƒë™","ì†¡ë‚´","ë¶€ê°œ","ë¶€í‰","ë°±ìš´","ë™ì•”","ê°„ì„","ì£¼ì•ˆ","ë„í™”","ì œë¬¼í¬","ë„ì›","ë™ì¸ì²œ","ì¸ì²œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ë…ì‚°","ê¸ˆì²œêµ¬ì²­","ì„ìˆ˜","ê´€ì•…","ì•ˆì–‘","ëª…í•™","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ì˜ì™•","ì„±ê· ê´€ëŒ€","í™”ì„œ","ìˆ˜ì›","ì„¸ë¥˜","ë³‘ì ","ì„¸ë§ˆ","ì˜¤ì‚°ëŒ€","ì˜¤ì‚°","ì§„ìœ„","ì†¡íƒ„","ì„œì •ë¦¬","í‰íƒì§€ì œ","í‰íƒ","ì„±í™˜","ì§ì‚°","ë‘ì •","ì²œì•ˆ","ë´‰ëª…","ìŒìš©","ì•„ì‚°","íƒ•ì •","ë°°ë°©","ì˜¨ì–‘ì˜¨ì²œ","ì‹ ì°½"],"2í˜¸ì„ ":["ì‹œì²­","ì„ì§€ë¡œì…êµ¬","ì„ì§€ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì‹ ë‹¹","ìƒì™•ì‹­ë¦¬","ì™•ì‹­ë¦¬","í•œì–‘ëŒ€","ëšì„¬","ì„±ìˆ˜","ê±´ëŒ€ì…êµ¬","êµ¬ì˜","ê°•ë³€","ì ì‹¤ë‚˜ë£¨","ì ì‹¤","ì ì‹¤ìƒˆë‚´","ì¢…í•©ìš´ë™ì¥","ì‚¼ì„±","ì„ ë¦‰","ì—­ì‚¼","ê°•ë‚¨","êµëŒ€","ì„œì´ˆ","ë°©ë°°","ì‚¬ë‹¹","ë‚™ì„±ëŒ€","ì„œìš¸ëŒ€ì…êµ¬","ë´‰ì²œ","ì‹ ë¦¼","ì‹ ëŒ€ë°©","êµ¬ë¡œë””ì§€í„¸ë‹¨ì§€","ëŒ€ë¦¼","ì‹ ë„ë¦¼","ë¬¸ë˜","ì˜ë“±í¬êµ¬ì²­","ë‹¹ì‚°","í•©ì •","í™ëŒ€ì…êµ¬","ì‹ ì´Œ","ì´ëŒ€","ì•„í˜„","ì¶©ì •ë¡œ","ìš©ë‹µ","ì‹ ë‹µ","ìš©ë‘","ì‹ ì„¤ë™","ë„ë¦¼ì²œ","ì–‘ì²œêµ¬ì²­","ì‹ ì •ë„¤ê±°ë¦¬","ê¹Œì¹˜ì‚°"],"3í˜¸ì„ ":["ëŒ€í™”","ì£¼ì—½","ì •ë°œì‚°","ë§ˆë‘","ë°±ì„","ëŒ€ê³¡","í™”ì •","ì›ë‹¹","ì›í¥","ì‚¼ì†¡","ì§€ì¶•","êµ¬íŒŒë°œ","ì—°ì‹ ë‚´","ë¶ˆê´‘","ë…¹ë²ˆ","í™ì œ","ë¬´ì•…ì¬","ë…ë¦½ë¬¸","ê²½ë³µê¶","ì•ˆêµ­","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ3ê°€","ì¶©ë¬´ë¡œ","ë™ëŒ€ì…êµ¬","ì•½ìˆ˜","ê¸ˆí˜¸","ì˜¥ìˆ˜","ì••êµ¬ì •","ì‹ ì‚¬","ì ì›","ê³ ì†í„°ë¯¸ë„","êµëŒ€","ë‚¨ë¶€í„°ë¯¸ë„","ì–‘ì¬","ë§¤ë´‰","ë„ê³¡","ëŒ€ì¹˜","í•™ì—¬ìš¸","ëŒ€ì²­","ì¼ì›","ìˆ˜ì„œ","ê°€ë½ì‹œì¥","ê²½ì°°ë³‘ì›","ì˜¤ê¸ˆ"],"4í˜¸ì„ ":["ì§„ì ‘","ì˜¤ë‚¨","ë³„ë‚´ë³„ê°€ëŒ","ë‹¹ê³ ê°œ","ìƒê³„","ë…¸ì›","ì°½ë™","ìŒë¬¸","ìˆ˜ìœ ","ë¯¸ì•„","ë¯¸ì•„ì‚¬ê±°ë¦¬","ê¸¸ìŒ","ì„±ì‹ ì—¬ëŒ€ì…êµ¬","í•œì„±ëŒ€ì…êµ¬","í˜œí™”","ë™ëŒ€ë¬¸","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì¶©ë¬´ë¡œ","ëª…ë™","íšŒí˜„","ì„œìš¸ì—­","ìˆ™ëŒ€ì…êµ¬","ì‚¼ê°ì§€","ì‹ ìš©ì‚°","ì´ì´Œ","ë™ì‘","ì´ì‹ ëŒ€ì…êµ¬","ì‚¬ë‹¹","ë‚¨íƒœë ¹","ì„ ë°”ìœ„","ê²½ë§ˆê³µì›","ëŒ€ê³µì›","ê³¼ì²œ","ì •ë¶€ê³¼ì²œì²­ì‚¬","ì¸ë•ì›","í‰ì´Œ","ë²”ê³„","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸","ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„"],"5í˜¸ì„ ":["ë°©í™”","ê°œí™”ì‚°","ê¹€í¬ê³µí•­","ì†¡ì •","ë§ˆê³¡","ë°œì‚°","ìš°ì¥ì‚°","í™”ê³¡","ê¹Œì¹˜ì‚°","ì‹ ì •","ëª©ë™","ì˜¤ëª©êµ","ì–‘í‰","ì˜ë“±í¬êµ¬ì²­","ì˜ë“±í¬ì‹œì¥","ì‹ ê¸¸","ì—¬ì˜ë„","ì—¬ì˜ë‚˜ë£¨","ë§ˆí¬","ê³µë•","ì• ì˜¤ê°œ","ì¶©ì •ë¡œ","ì„œëŒ€ë¬¸","ê´‘í™”ë¬¸","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì²­êµ¬","ì‹ ê¸ˆí˜¸","í–‰ë‹¹","ì™•ì‹­ë¦¬","ë§ˆì¥","ë‹µì‹­ë¦¬","ì¥í•œí‰","êµ°ì","ì•„ì°¨ì‚°","ê´‘ë‚˜ë£¨","ì²œí˜¸","ê°•ë™","ê¸¸ë™","êµ½ì€ë‹¤ë¦¬","ëª…ì¼","ê³ ë•","ìƒì¼ë™","ê°•ì¼","ë¯¸ì‚¬","í•˜ë‚¨í’ì‚°","í•˜ë‚¨ì‹œì²­","í•˜ë‚¨ê²€ë‹¨ì‚°","ë‘”ì´Œë™","ì˜¬ë¦¼í”½ê³µì›","ë°©ì´","ì˜¤ê¸ˆ","ê°œë¡±","ê±°ì—¬","ë§ˆì²œ"],"6í˜¸ì„ ":["ì‘ì•”","ì—­ì´Œ","ë…ë°”ìœ„","ì—°ì‹ ë‚´","êµ¬ì‚°","ìƒˆì ˆ","ì¦ì‚°","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ì›”ë“œì»µê²½ê¸°ì¥","ë§ˆí¬êµ¬ì²­","ë§ì›","í•©ì •","ìƒìˆ˜","ê´‘í¥ì°½","ëŒ€í¥","ê³µë•","íš¨ì°½ê³µì›ì•","ì‚¼ê°ì§€","ë…¹ì‚¬í‰","ì´íƒœì›","í•œê°•ì§„","ë²„í‹°ê³ ê°œ","ì•½ìˆ˜","ì²­êµ¬","ì‹ ë‹¹","ë™ë¬˜ì•","ì°½ì‹ ","ë³´ë¬¸","ì•ˆì•”","ê³ ë ¤ëŒ€","ì›”ê³¡","ìƒì›”ê³¡","ëŒê³¶ì´","ì„ê³„","íƒœë¦‰ì…êµ¬","í™”ë‘ëŒ€","ë´‰í™”ì‚°","ì‹ ë‚´"],"7í˜¸ì„ ":["ì¥ì•”","ë„ë´‰ì‚°","ìˆ˜ë½ì‚°","ë§ˆë“¤","ë…¸ì›","ì¤‘ê³„","í•˜ê³„","ê³µë¦‰","íƒœë¦‰ì…êµ¬","ë¨¹ê³¨","ì¤‘í™”","ìƒë´‰","ë©´ëª©","ì‚¬ê°€ì •","ìš©ë§ˆì‚°","ì¤‘ê³¡","êµ°ì","ì–´ë¦°ì´ëŒ€ê³µì›","ê±´ëŒ€ì…êµ¬","ëšì„¬ìœ ì›ì§€","ì²­ë‹´","ê°•ë‚¨êµ¬ì²­","í•™ë™","ë…¼í˜„","ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ë‚´ë°©","ì´ìˆ˜","ë‚¨ì„±","ìˆ­ì‹¤ëŒ€ì…êµ¬","ìƒë„","ì¥ìŠ¹ë°°ê¸°","ì‹ ëŒ€ë°©ì‚¼ê±°ë¦¬","ë³´ë¼ë§¤","ì‹ í’","ëŒ€ë¦¼","ë‚¨êµ¬ë¡œ","ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ì² ì‚°","ê´‘ëª…ì‚¬ê±°ë¦¬","ì²œì™•","ì˜¨ìˆ˜","ê¹Œì¹˜ìš¸","ë¶€ì²œì¢…í•©ìš´ë™ì¥","ì¶˜ì˜","ì‹ ì¤‘ë™","ë¶€ì²œì‹œì²­","ìƒë™","ì‚¼ì‚°ì²´ìœ¡ê´€","êµ´í¬ì²œ","ë¶€í‰êµ¬ì²­","ìƒê°ˆ","ì‚°ê³¡","ì„ë‚¨"],"8í˜¸ì„ ":["ë³„ë‚´","ë‹¤ì‚°","ë™êµ¬ë¦‰","êµ¬ë¦¬","ì¥ìí˜¸ìˆ˜ê³µì›","ì•”ì‚¬ì—­ì‚¬ê³µì›","ì•”ì‚¬","ì²œí˜¸","ê°•ë™êµ¬ì²­","ëª½ì´Œí† ì„±","ì ì‹¤","ì„ì´Œ","ì†¡íŒŒ","ê°€ë½ì‹œì¥","ë¬¸ì •","ì¥ì§€","ë³µì •","ë‚¨ìœ„ë¡€","ì‚°ì„±","ë‚¨í•œì‚°ì„±ì…êµ¬","ë‹¨ëŒ€ì˜¤ê±°ë¦¬","ì‹ í¥","ì‹ ì´Œ","ìˆ˜ì§„","ëª¨ë€"],"9í˜¸ì„ ":["ê°œí™”","ê¹€í¬ê³µí•­","ê³µí•­ì‹œì¥","ì‹ ë°©í™”","ë§ˆê³¡ë‚˜ë£¨","ì–‘ì²œí–¥êµ","ê°€ì–‘","ì¦ë¯¸","ë“±ì´Œ","ì—¼ì°½","ì‹ ëª©ë™","ì„ ìœ ë„","ë‹¹ì‚°","êµ­íšŒì˜ì‚¬ë‹¹","ì—¬ì˜ë„","ìƒ›ê°•","ë…¸ëŸ‰ì§„","ë…¸ë“¤","í‘ì„","ë™ì‘","êµ¬ë°˜í¬","ì‹ ë°˜í¬","ê³ ì†í„°ë¯¸ë„","ì‚¬í‰","ì‹ ë…¼í˜„","ì–¸ì£¼","ì„ ì •ë¦‰","ì‚¼ì„±ì¤‘ì•™","ë´‰ì€ì‚¬","ì¢…í•©ìš´ë™ì¥","ì‚¼ì „","ì„ì´Œê³ ë¶„","ì„ì´Œ","ì†¡íŒŒë‚˜ë£¨","í•œì„±ë°±ì œ","ì˜¬ë¦¼í”½ê³µì›","ë‘”ì´Œì˜¤ë¥œ","ì¤‘ì•™ë³´í›ˆë³‘ì›"],"ê²½ì˜ì¤‘ì•™ì„ ":["ë¬¸ì‚°","íŒŒì£¼","ì›”ë¡±","ê¸ˆì´Œ","ê¸ˆë¦‰","ìš´ì •","ì•¼ë‹¹","íƒ„í˜„","ì¼ì‚°","í’ì‚°","ë°±ë§ˆ","ê³¡ì‚°","ëŒ€ê³¡","ëŠ¥ê³¡","í–‰ì‹ ","ê°•ë§¤","í™”ì „","ìˆ˜ìƒ‰","ë””ì§€í„¸ë¯¸ë””ì–´ì‹œí‹°","ê°€ì¢Œ","í™ëŒ€ì…êµ¬","ì„œê°•ëŒ€","ê³µë•","íš¨ì°½ê³µì›ì•","ìš©ì‚°","ì´ì´Œ","ì„œë¹™ê³ ","í•œë‚¨","ì˜¥ìˆ˜","ì‘ë´‰","ì™•ì‹­ë¦¬","ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","ì–‘ì›","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ë„ì‹¬","íŒ”ë‹¹","ìš´ê¸¸ì‚°","ì–‘ìˆ˜","ì‹ ì›","êµ­ìˆ˜","ì•„ì‹ ","ì˜¤ë¹ˆ","ì–‘í‰","ì›ë•","ìš©ë¬¸","ì§€í‰"],"ì‹ ë¶„ë‹¹ì„ ":["ì‹ ì‚¬","ë…¼í˜„","ì‹ ë…¼í˜„","ê°•ë‚¨","ì–‘ì¬","ì–‘ì¬ì‹œë¯¼ì˜ìˆ²","ì²­ê³„ì‚°ì…êµ¬","íŒêµ","ì •ì","ë¯¸ê¸ˆ","ë™ì²œ","ìˆ˜ì§€êµ¬ì²­","ì„±ë³µ","ìƒí˜„","ê´‘êµì¤‘ì•™","ê´‘êµ"],"ìˆ˜ì¸ë¶„ë‹¹ì„ ":["ì²­ëŸ‰ë¦¬","íšŒê¸°","ì¤‘ë‘","ìƒë´‰","ë§ìš°","êµ¬ë¦¬","ë„ë†","ì–‘ì •","ë•ì†Œ","ì™•ì‹­ë¦¬","ì„œìš¸ìˆ²","ì••êµ¬ì •ë¡œë°ì˜¤","ê°•ë‚¨êµ¬ì²­","ì„ ì •ë¦‰","ì„ ë¦‰","í•œí‹°","ë„ê³¡","êµ¬ë£¡","ê°œí¬ë™","ëŒ€ëª¨ì‚°ì…êµ¬","ìˆ˜ì„œ","ë³µì •","ê°€ì²œëŒ€","íƒœí‰","ëª¨ë€","ì•¼íƒ‘","ì´ë§¤","ì„œí˜„","ìˆ˜ë‚´","ì •ì","ë¯¸ê¸ˆ","ì˜¤ë¦¬","ì£½ì „","ë³´ì •","êµ¬ì„±","ì‹ ê°ˆ","ê¸°í¥","ìƒê°ˆ","ì²­ëª…","ì˜í†µ","ë§í¬","ë§¤íƒ„ê¶Œì„ ","ìˆ˜ì›ì‹œì²­","ë§¤êµ","ìˆ˜ì›","ê³ ìƒ‰","ì˜¤ëª©ì²œ","ì–´ì²œ","ì•¼ëª©","ì‚¬ë¦¬","í•œëŒ€ì•","ì¤‘ì•™","ê³ ì”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„","ë‹¬ì›”","ì›”ê³¶","ì†Œë˜í¬êµ¬","ì¸ì²œë…¼í˜„","í˜¸êµ¬í¬","ë‚¨ë™ì¸ë”ìŠ¤íŒŒí¬","ì›ì¸ì¬","ì—°ìˆ˜","ì†¡ë„","í•™ìµ","ì¸í•˜ëŒ€","ìˆ­ì˜","ì‹ í¬","ì¸ì²œ"]};

  // Audio: NO BGM, only SFX
  let sfxGain=null;

  // === Sound settings (volume) ===
  const VOL_MUTED_KEY = "jesong_vol_muted";
  const VOL_MOVE_KEY = "jesong_vol_move_pct";
  const VOL_TRANSFER_KEY = "jesong_vol_transfer_pct";
  const VOL_ARRIVE_KEY = "jesong_vol_arrive_pct";

  let isMuted = false;
  let volMovePct = 1000;     // 0~2000
  let volTransferPct = 2500; // 0~5000
  let volArrivePct = 500;   // 0~1000

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function loadSoundSettings(){
    try{
      isMuted = (localStorage.getItem(VOL_MUTED_KEY)||"0") === "1";
      const m = parseInt(localStorage.getItem(VOL_MOVE_KEY)||"100",10);
      const t = parseInt(localStorage.getItem(VOL_TRANSFER_KEY)||"100",10);
      const a = parseInt(localStorage.getItem(VOL_ARRIVE_KEY)||"100",10);
      volMovePct = clamp(Number.isFinite(m)?m:1000, 0, 2000);
      volTransferPct = clamp(Number.isFinite(t)?t:2500, 0, 5000);
      volArrivePct = clamp(Number.isFinite(a)?a:500, 0, 1000);
    }catch(e){}
  }
  function saveSoundSettings(){
    try{
      localStorage.setItem(VOL_MUTED_KEY, isMuted ? "1" : "0");
      localStorage.setItem(VOL_MOVE_KEY, String(volMovePct));
      localStorage.setItem(VOL_TRANSFER_KEY, String(volTransferPct));
      localStorage.setItem(VOL_ARRIVE_KEY, String(volArrivePct));
    }catch(e){}
  }
  function volMove(){ return (isMuted ? 0 : (volMovePct/100)); }
  function volTransfer(){ return (isMuted ? 0 : (volTransferPct/100)); }
  function volArrive(){ return (isMuted ? 0 : (volArrivePct/100)); }

  function applyTransferGain(){
    try{
      if(transferGain) transferGain.gain.value = 0.01 * volTransfer();
    }catch(e){}
    try{
      // If <audio> fallback is used
      if(typeof sfxTransfer !== "undefined" && sfxTransfer) sfxTransfer.volume = 0.01 * volTransfer();
    }catch(e){}
  }

  loadSoundSettings();

  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(!sfxGain){ sfxGain = audioCtx.createGain(); sfxGain.gain.value=0.18; sfxGain.connect(audioCtx.destination); }
  }
  function startBGM(){ ensureAudio(); }
  function playTick(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    const f=audioCtx.createBiquadFilter();
    o.type='square'; o.frequency.value=1500;
    f.type='bandpass'; f.frequency.value=1100; f.Q.value=9;
    g.gain.value=0.0001;
    o.connect(f).connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.18*volMove(), now+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.06);
    o.stop(now+0.07);
    const o2=audioCtx.createOscillator();
    const g2=audioCtx.createGain();
    o2.type='sine'; o2.frequency.value=420;
    g2.gain.value=0.0001;
    o2.connect(g2).connect(sfxGain);
    o2.start(now+0.018);
    g2.gain.linearRampToValueAtTime(0.07*volMove(), now+0.03);
    g2.gain.exponentialRampToValueAtTime(0.0001, now+0.16);
    o2.stop(now+0.17);
  }
  function playDing(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.type='sine'; o.frequency.value=880;
    g.gain.value=0.0001;
    o.connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.14*volMove(), now+0.02);
    o.frequency.linearRampToValueAtTime(1175, now+0.14);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.42);
    o.stop(now+0.43);
  }
  function playFanfare(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const g=audioCtx.createGain();
    g.gain.value=0.0001;
    g.connect(sfxGain);
    const o1=audioCtx.createOscillator();
    const o2=audioCtx.createOscillator();
    o1.type='square'; o2.type='square';
    o1.connect(g); o2.connect(g);
    const seq=[523.25,659.25,783.99,1046.5];
    const dur=0.10;
    o1.start(now); o2.start(now);
    seq.forEach((f,i)=>{ o1.frequency.setValueAtTime(f, now+i*dur); o2.frequency.setValueAtTime(f*0.5, now+i*dur); });
    g.gain.linearRampToValueAtTime(0.18*volArrive(), now+0.02);
    g.gain.linearRampToValueAtTime(0.12*volArrive(), now+0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, now+seq.length*dur+0.12);
    o1.stop(now+seq.length*dur+0.15);
    o2.stop(now+seq.length*dur+0.15);
  }

  function formatStation(s){ s=String(s).trim().replace(/ì—­$/,''); return s+'ì—­'; }
  function normalizeName(s){ return String(s).trim().replace(/ì—­$/,'').replace(/\s+/g,''); }

  // Build line data (line-aware)
  function cleanLine(arr){
    const out=[];
    for(let i=0;i<arr.length;i++){
      const s=String(arr[i]).trim();
      if(!s) continue;
      if(out.length && out[out.length-1]===s) continue;
      out.push(s);
    }
    return out;
  }
  const subwayData={};
  const lineNames=Object.keys(DATA);
  for(const line of lineNames) subwayData[line]=cleanLine(DATA[line]);

  const lineIndex={};
  for(const line of lineNames){
    lineIndex[line]={};
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++) lineIndex[line][arr[i]]=i;
  }
  const stationLines=new Map();
  for(const line of lineNames){
    for(const st of subwayData[line]){
      if(!stationLines.has(st)) stationLines.set(st,new Set());
      stationLines.get(st).add(line);
    }
  }
  const getLinesOf=(st)=>stationLines.get(st)?Array.from(stationLines.get(st)):[];

  const getNextOnLine=(line,st,dir)=>{
    const idx=lineIndex[line][st];
    if(idx===undefined) return null;
    const arr=subwayData[line];
    const ni=idx+dir;
    if(ni<0||ni>=arr.length) return null;
    return arr[ni];
  };

  const allStations=Array.from(stationLines.keys());

  // Load saved movement settings
  try{
    const ms = parseInt(localStorage.getItem(MIN_STOPS_KEY)||'',10);
    const mx = parseInt(localStorage.getItem(MAX_STOPS_KEY)||'',10);
    if(Number.isFinite(ms)) minStops = Math.max(1, Math.min(99, ms));
    if(Number.isFinite(mx)) maxStops = Math.max(1, Math.min(99, mx));
    if(minStops>maxStops) [minStops,maxStops] = [maxStops,minStops];
  }catch(e){}


  // Layout (no x-averaging)
  const yStep=90, xStep=22, marginX=90, marginY=90;
  const pos=new Map();
  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const y=marginY + li*yStep;
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++){
      const st=arr[i];
      const x=marginX + i*xStep;
      pos.set(line+'::'+st, {x:x,y:y});
    }
  }

  // Draw SVG
  const viewport=document.getElementById('viewport');
  const map=document.getElementById('map');
  const gLines=document.getElementById('gLines');
  const gDots=document.getElementById('gDots');
  const token=document.getElementById('token');

  // --- Camera follow (stable): keep token centered without jitter (step-based + smoothing) ---
  const viewportEl = document.getElementById('viewport');

    let isAutoScroll = false;
// User can drag the view freely; after a short pause, camera returns to token center.
  if(viewportEl){
    const GRACE_MS = 1200; // time after last interaction before recenter
    const markUserPan = () => {
            if(isAutoScroll) return;
userPanUntil = Date.now() + GRACE_MS;
      if(recenterTimer) clearTimeout(recenterTimer);
      recenterTimer = setTimeout(() => {
        // Once user stops, snap back to token center (even if not animating)
        followTokenStable(true);
        setTimeout(()=>followTokenStable(true), 60);
      }, GRACE_MS + 20);
    };

    viewportEl.addEventListener('pointerdown', markUserPan, {passive:true});
    viewportEl.addEventListener('pointermove', markUserPan, {passive:true});
    window.addEventListener('pointerup', markUserPan, {passive:true});

    viewportEl.addEventListener('touchstart', markUserPan, {passive:true});
    viewportEl.addEventListener('touchmove', markUserPan, {passive:true});
    window.addEventListener('touchend', markUserPan, {passive:true});

    viewportEl.addEventListener('wheel', markUserPan, {passive:true});
  }

  let followPending = false;
  let userPanUntil = 0; // timestamp until which we don't auto-center (user is dragging)
  let recenterTimer = null;


  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  // Camera offset: user wants the person token to be **dead center**.
  const CAMERA_OFFSET_Y = 0;

  function scheduleInitialCenter(){
    // iOS Safari: run a few times after layout settles
    requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} });
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 120);
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 320);
  }

  // Snap camera to token immediately (used after teleport / after splash removal)
  function snapCameraToTokenNow(){
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }


  function followTokenStable(force){
    if(followPending) return;
    followPending = true;
    requestAnimationFrame(()=>{
      followPending = false;

      // overlays guard
      const startOverlayEl = document.getElementById('startOverlay');
      const settingsOverlayEl = document.getElementById('settingsOverlay');
      if(startOverlayEl){
        // While splash is fading out, allow camera to run so map becomes visible immediately.
        const cs = getComputedStyle(startOverlayEl);
        const fading = startOverlayEl.classList.contains('fadeOut');
        if(!fading && cs.display !== 'none' && cs.visibility !== 'hidden' && !startOverlayEl.classList.contains('hidden')) return;
      }


  // Snap camera to token immediately (useful right after setting station via input)
  function snapCameraToTokenNow(){
    // 2 frames only, once per teleport -> no noticeable stutter
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }
      if(settingsOverlayEl && settingsOverlayEl.classList.contains('show')) return;

      if(!viewportEl || !token) return;
      if(!force && Date.now() < userPanUntil) return;

      const vp = viewportEl.getBoundingClientRect();
      const tr = token.getBoundingClientRect();

      // token center in scroll-content coordinates
      const tokenCx = (tr.left - vp.left) + viewportEl.scrollLeft + tr.width/2;
      const tokenCy = (tr.top  - vp.top ) + viewportEl.scrollTop  + tr.height/2;

      const vpW = viewportEl.clientWidth;
      const vpH = viewportEl.clientHeight;

      const targetLeft = clamp(tokenCx - vpW/2, 0, viewportEl.scrollWidth - vpW);
      const targetTop  = clamp(tokenCy - vpH/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - vpH);

      isAutoScroll = true;
      viewportEl.scrollLeft = targetLeft;
      viewportEl.scrollTop  = targetTop;
      requestAnimationFrame(()=>{ isAutoScroll = false; });

      // one more settle frame for iOS timing
      requestAnimationFrame(()=>{
        const vp2 = viewportEl.getBoundingClientRect();
        const tr2 = token.getBoundingClientRect();
        const tokenCx2 = (tr2.left - vp2.left) + viewportEl.scrollLeft + tr2.width/2;
        const tokenCy2 = (tr2.top  - vp2.top ) + viewportEl.scrollTop  + tr2.height/2;
        const tL2 = clamp(tokenCx2 - viewportEl.clientWidth/2, 0, viewportEl.scrollWidth - viewportEl.clientWidth);
        const tT2 = clamp(tokenCy2 - viewportEl.clientHeight/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - viewportEl.clientHeight);
        isAutoScroll = true;
        viewportEl.scrollLeft = tL2;
        viewportEl.scrollTop  = tT2;
        requestAnimationFrame(()=>{ isAutoScroll = false; });
      });
    });
  }



  const hudG=document.getElementById('hudG');
  const HUD_OFFSET_Y = 68; // adjusted: closer to head, avoid clipping

  const hudLine1=document.getElementById('hudLine1');
  const hudLine2=document.getElementById('hudLine2');

  const LINE_COLORS={"1í˜¸ì„ ":"#1e88e5","2í˜¸ì„ ":"#2e7d32","3í˜¸ì„ ":"#f9a825","4í˜¸ì„ ":"#039be5","5í˜¸ì„ ":"#8e24aa","6í˜¸ì„ ":"#6d4c41","7í˜¸ì„ ":"#7b1fa2","8í˜¸ì„ ":"#d81b60","9í˜¸ì„ ":"#b59a00","ê²½ì˜ì¤‘ì•™ì„ ":"#00838f","ì‹ ë¶„ë‹¹ì„ ":"#c62828","ìˆ˜ì¸ë¶„ë‹¹ì„ ":"#f06292"};
  const lineColor=(n)=>LINE_COLORS[n]||"#ff4d6d";
  function svgEl(tag, attrs){
    const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  let maxLen=0;
  // Extra top padding so the token can be centered even when starting near the top lines.
  // (Otherwise scrollTop clamps to 0 and the token appears too low.)
  const PAD_TOP = 700;
  const PAD_BOTTOM = 900;
  const mapShift = document.getElementById('mapShift');
  for(const line of lineNames) maxLen=Math.max(maxLen, subwayData[line].length);
  const W=Math.max(1800, marginX + maxLen*xStep + 140);
  const H=Math.max(1100, marginY + lineNames.length*yStep + 140);
  map.setAttribute('width', String(W));
  map.setAttribute('height', String(H + PAD_TOP + PAD_BOTTOM));
  map.setAttribute('viewBox', '0 ' + (-PAD_TOP) + ' ' + W + ' ' + (H + PAD_TOP + PAD_BOTTOM));
  if(mapShift) mapShift.setAttribute('transform', 'translate(0,'+PAD_TOP+')');
for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const arr=subwayData[line];
    let d='';
    for(let i=0;i<arr.length;i++){
      const p=pos.get(line+'::'+arr[i]);
      d += (i===0 ? ('M '+p.x+' '+p.y) : (' L '+p.x+' '+p.y));
    }
    gLines.appendChild(svgEl('path', {d:d, class:'lineStroke', stroke: lineColor(line)}));
    gLines.appendChild(svgEl('path', {d:d, class:'lineInner'}));
    const label=svgEl('text', {x:'16', y:String(marginY + li*yStep + 5), class:'label'});
    label.textContent=line;
    gLines.appendChild(label);
  }

  stationLines.forEach((set, st)=>{
    const lines=Array.from(set);
    if(lines.length<2) return;
    const pts=[];
    for(const l of lines){ const p=pos.get(l+'::'+st); if(p) pts.push(p); }
    pts.sort((a,b)=>a.y-b.y);
    if(pts.length<2) return;
    let d='M '+pts[0].x+' '+pts[0].y;
    for(let i=1;i<pts.length;i++) d += ' L '+pts[i].x+' '+pts[i].y;
    gLines.appendChild(svgEl('path', {d:d, class:'connector'}));
  });

  stationLines.forEach((set, st)=>{
    if(set.size<2) return;
    for(const line of set){
      const p=pos.get(line+'::'+st);
      if(!p) continue;
      gDots.appendChild(svgEl('circle', {cx:String(p.x), cy:String(p.y), r:'4', class:'stationDot'}));
    }
  });

  // Drag-to-pan
  (function enableDragPan(){
    let isDown=false, startX=0, startY=0, sl=0, st=0;
    viewport.addEventListener('pointerdown',(e)=>{
      isDown=true; viewport.setPointerCapture(e.pointerId);
      startX=e.clientX; startY=e.clientY;
      sl=viewport.scrollLeft; st=viewport.scrollTop;
    });
    viewport.addEventListener('pointermove',(e)=>{
      if(!isDown) return;
      viewport.scrollLeft = sl - (e.clientX - startX);
      viewport.scrollTop  = st - (e.clientY - startY);
    });
    viewport.addEventListener('pointerup',()=>{ isDown=false; });
    viewport.addEventListener('pointercancel',()=>{ isDown=false; });
    // Set initial scroll so default view stays the same (but you can drag down to see more top)
})();

  // Confetti
  const confCanvas=document.getElementById('confetti');
  const confCtx=confCanvas.getContext('2d');
  function resizeCanvasTo(el, canvas, ctx){
    const r=el.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height};
  }
  function burstConfettiOn(canvas, ctx, w, h){
    if(canvas.__raf) cancelAnimationFrame(canvas.__raf);
    const colors=["#ff4d6d","#ff85a2","#ffd6e0","#c9184a","#ffb3c1","#ffe3ea"];
    const pieces=[];
    const count=190;
    for(let i=0;i<count;i++) pieces.push({x:w*0.5,y:h*0.32,vx:(Math.random()-0.5)*9,vy:-Math.random()*11-7,g:0.22+Math.random()*0.18,w:4+Math.random()*5,h:3+Math.random()*5,a:Math.random()*Math.PI,va:(Math.random()-0.5)*0.25,c:colors[Math.floor(Math.random()*colors.length)],life:0,max:170+Math.random()*70});
    function tick(){
      ctx.clearRect(0,0,w,h);
      let alive=0;
      for(const p of pieces){
        p.life++; if(p.life<p.max) alive++;
        p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.va;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.a);
        ctx.globalAlpha=Math.max(0,1-p.life/p.max);
        ctx.fillStyle=p.c;
        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }
      ctx.globalAlpha=1;
      if(alive>0) canvas.__raf=requestAnimationFrame(tick);
      else ctx.clearRect(0,0,w,h);
    }
    tick();
  }
  resizeCanvasTo(viewport, confCanvas, confCtx);
  window.addEventListener('resize', ()=>{ resizeCanvasTo(viewport, confCanvas, confCtx); });

  // Movement helpers
  // Camera policy (IMPORTANT):
  // - Person token must stay *dead center* of the map viewport.
  // - User can drag/pan anytime; while dragging we don't fight.
  // - After dragging ends, we gently return to token.
  // We reuse the existing followTokenStable() logic above to avoid conflicting camera systems.
  function setTokenXY(x,y, smooth){
    token.setAttribute('transform','translate('+x+','+y+')');
    hudG.setAttribute('transform','translate('+x+','+(y-HUD_OFFSET_Y)+')');

    // If smooth=false (snap moments like first render / arrival), force-center once.
    // Otherwise keep centering every frame (but do not fight the user while dragging).
    try{ followTokenStable(!smooth); }catch(e){}
  }

  function setTokenAt(line, st, smooth){
    const p=pos.get(line+'::'+st);
    if(!p) return;
    setTokenXY(p.x,p.y,smooth);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
  function moveSegment(lineA, stA, lineB, stB){
    const a=pos.get(lineA+'::'+stA);
    const b=pos.get(lineB+'::'+stB);
    if(!a||!b) return Promise.resolve();
    const d=dist(a,b);
    const duration=Math.max(240, Math.min(650, d*6.5));
    const start=performance.now();
    return new Promise(res=>{
      function tick(t){
        const p=Math.min(1,(t-start)/duration);
        const e=p<0.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
        setTokenXY(a.x+(b.x-a.x)*e, a.y+(b.y-a.y)*e, true);
        if(p<1) requestAnimationFrame(tick); else res();
      }
      requestAnimationFrame(tick);
    });
  }

  // Path generator: transfer only at interchange, stop at terminal, no reverse
  let minStops = 1;
  let maxStops = 25;
  let trueRandomMode = false;
  // Always start with true-random OFF on initial load
  trueRandomMode = false;
  try{ localStorage.setItem(TRUE_RANDOM_KEY, '0'); }catch(e){}  
  // ------------------------------
  // Pathfinding (ìµœì  ê²½ë¡œ: ìµœì†Œ ì´ë™ì—­ + ë¶ˆí•„ìš” í™˜ìŠ¹ ìµœì†Œí™”)
  // ------------------------------
  // Build station adjacency (neighbors along each line)
  // IMPORTANT: We do NOT treat each line's station array as a single continuous chain when the line has branches.
  // Instead, we build an explicit adjacency list (stationNeighbors) and patch known branch-breaks so iOS/Android/PC all compute the same *real* shortest-stop routes.
  const stationNeighbors = new Map(); // station -> Set(neighborStation)
  const addEdge = (a,b)=>{
    if(!a||!b||a===b) return;
    if(!stationNeighbors.has(a)) stationNeighbors.set(a, new Set());
    if(!stationNeighbors.has(b)) stationNeighbors.set(b, new Set());
    stationNeighbors.get(a).add(b);
    stationNeighbors.get(b).add(a);
  };

  // 1) ê¸°ë³¸: ê° í˜¸ì„ ì˜ ì¸ì ‘ ì—­(ë°°ì—´ì—ì„œ ë°”ë¡œ ì•/ë’¤)ë§Œ edgeë¡œ ì¶”ê°€
  lineNames.forEach(line => {
    const arr = subwayData[line];
    for(let i=1;i<arr.length;i++){
      const a = arr[i-1];
      const b = arr[i];
      // Branch patches for Line 1 (ìˆ˜ë„ê¶Œ 1í˜¸ì„ ì€ ë¶„ê¸°ê°€ ë§ì•„ì„œ, ë‹¨ì¼ ë°°ì—´ì„ ê·¸ëŒ€ë¡œ ì‡ìœ¼ë©´ ê°€ì§œ ì—°ê²°ì´ ìƒê¹€)
      if(line==='1í˜¸ì„ '){
        // (1) ì¸ì²œ(ê²½ì¸ì„  ì¢…ì ) ë‹¤ìŒì— ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€ë¡œ 'ì í”„'í•˜ëŠ” ê°€ì§œ ì—°ê²° ì°¨ë‹¨
        if((a==='ì¸ì²œ' && b==='ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€') || (a==='ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€' && b==='ì¸ì²œ')) continue;
        // (2) 1í˜¸ì„  ë°ì´í„°ì— ì„ì—¬ìˆëŠ” 4í˜¸ì„  êµ¬ê°„(ê¸ˆì •â†’ì‚°ë³¸â€¦) ê°€ì§œ ì—°ê²° ì°¨ë‹¨
        if((a==='ê¸ˆì •' && b==='ì‚°ë³¸') || (a==='ì‚°ë³¸' && b==='ê¸ˆì •')) continue;
        // (3) ì˜¤ì´ë„ ì´í›„ ì˜ì™•ìœ¼ë¡œ ì í”„í•˜ëŠ” ê°€ì§œ ì—°ê²° ì°¨ë‹¨
        if((a==='ì˜¤ì´ë„' && b==='ì˜ì™•') || (a==='ì˜ì™•' && b==='ì˜¤ì´ë„')) continue;
      }
      addEdge(a,b);
    }
  });

  // 2) 1í˜¸ì„  ë¶„ê¸° ë³´ì •: êµ¬ë¡œâ†”ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€(ê²½ë¶€ì„  ë°©í–¥)ëŠ” ì‹¤ì œ ì¸ì ‘ì—­ì¸ë°,
  //    ìœ„ì˜ ì›ë³¸ ë°°ì—´ì—ì„  'ì¸ì²œ ì§€ì„ ' ë’¤ì— ë¶™ì–´ìˆì–´ ì—°ê²°ì´ ë¹ ì ¸ìˆê¸° ë•Œë¬¸ì— ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•œë‹¤.
  addEdge('êµ¬ë¡œ','ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€');


  function bfsDistances(start){
    const q=[start];
    const dist=new Map([[start,0]]);
    for(let qi=0; qi<q.length; qi++){
      const cur=q[qi];
      const d=dist.get(cur);
      const ns=stationNeighbors.get(cur);
      if(!ns) continue;
      ns.forEach(n=>{
        if(!dist.has(n)){
          dist.set(n,d+1);
          q.push(n);
        }
      });
    }
    return dist;
  }

  // Dijkstra with lexicographic cost: (stops, transfers)
  // State is (station, line). Move along same line adds 1 stop. Transfer changes line adds 1 transfer (0 stop).
  // We minimize **stops first**, and only if stops are equal, we minimize transfers.
  function bestRoute(startStation, endStation){
    const startLines = getLinesOf(startStation);
    const endLines = getLinesOf(endStation);
    if(!startLines.length || !endLines.length) return null;

    const pq=[];
    const key=(st,line)=>st+"@@"+line;
    const best=new Map();     // key -> [stops, transfers]
    const prev=new Map();     // key -> previous key
    const prevStep=new Map(); // key -> {st,line}

    function push(st,line,stops,transfers,fromKey){
      const k=key(st,line);
      const cur=best.get(k);
      if(cur){
        if(stops>cur[0] || (stops===cur[0] && transfers>=cur[1])) return;
      }
      best.set(k,[stops,transfers]);
      if(fromKey){
        prev.set(k,fromKey);
        prevStep.set(k,{st,line});
      }
      pq.push([stops,transfers,st,line]);
    }

    // init: allow starting on any line at startStation with 0/0
    startLines.forEach(line=>push(startStation,line,0,0,null));

    // poor man's priority queue: sort each pop (small graph so OK)
    while(pq.length){
      pq.sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
      const [stops,transfers,st,line]=pq.shift();
      const k=key(st,line);
      const cur=best.get(k);
      if(!cur || cur[0]!==stops || cur[1]!==transfers) continue;

      if(st===endStation && endLines.includes(line)){
        // reconstruct
        const path=[];
        let kk=k;
        while(kk){
          const [station, ln] = kk.split("@@");
          path.push({line: ln, st: station});
          kk = prev.get(kk);
        }
        path.reverse();
        // compress any accidental duplicates (same station+line)
        const out=[];
        for(const step of path){
          const last=out[out.length-1];
          if(last && last.st===step.st && last.line===step.line) continue;
          out.push(step);
        }
        return out;
      }

      // 1) move to neighbors along same line
      const idxMap = lineIndex[line];
      const arr = subwayData[line];
      const idx = idxMap ? idxMap[st] : undefined;
      if(idx!==undefined){
        if(idx>0){
          const n=arr[idx-1];
          push(n,line,stops+1,transfers,k);
        }
        if(idx<arr.length-1){
          const n=arr[idx+1];
          push(n,line,stops+1,transfers,k);
        }
      }

      // 2) transfer at same station
      const linesHere = getLinesOf(st).filter(l=>l!==line);
      for(const nl of linesHere){
        push(st,nl,stops,transfers+1,k);
      }
    }

    // If we couldn't reach with line-matching end, allow endStation on any line (still minimal)
    // Find best among endStation states
    let bestEndKey=null, bestCost=null;
    for(const ln of endLines){
      const k=key(endStation,ln);
      const c=best.get(k);
      if(c && (!bestCost || c[0]<bestCost[0] || (c[0]==bestCost[0] && c[1]<bestCost[1]))){
        bestCost=c; bestEndKey=k;
      }
    }
    if(!bestEndKey) return null;
    const path=[];
    let kk=bestEndKey;
    while(kk){
      const [station, ln] = kk.split("@@");
      path.push({line: ln, st: station});
      kk = prev.get(kk);
    }
    path.reverse();
    const out=[];
    for(const step of path){
      const last=out[out.length-1];
      if(last && last.st===step.st && last.line===step.line) continue;
      out.push(step);
    }
    return out;
  }

  // Compatibility alias: returns {path} where path is bestRoute (min stops, then min transfers)
  function dijkstraMinTransferStops(startStation, endStation){
    var p = bestRoute(startStation, endStation);
    return { path: p || [] };
  }


  // Pick a random destination within [minStops, maxStops] stops, then compute best route to it.
  
  // Pick a random destination within [minStops, maxStops] stops from start (by BFS distance),
  // then compute an optimal route prioritizing: (1) minimum transfers, (2) minimum stops.
  
  // Pick a destination whose *actual route stops* (path length - 1) falls within [minStops, maxStops].
  // Route is optimized by: (1) minimum transfers, (2) minimum stops.
  function planOptimalTrip(startStation){
    const dist = bfsDistances(startStation);
    const candidates = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d === undefined) continue;
      if(st !== startStation && d >= minStops && d <= maxStops) candidates.push(st);
    }

    // Shuffle candidates to keep it random but within constraints
    for(let i=candidates.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = candidates[i]; candidates[i]=candidates[j]; candidates[j]=tmp;
    }

    function routeStops(path){
      if(!path || !path.length) return 0;
      let s=0;
      for(let i=1;i<path.length;i++){ if(path[i].st !== path[i-1].st) s++; }
      return s;
    }

    // 1) Try strict: find a dest whose optimized route also fits the stop-range.
    for(const dest of candidates){
      const best = dijkstraMinTransferStops(startStation, dest);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops >= minStops && stops <= maxStops){
        return { dest, path };
      }
    }

    // 2) Fallback: if none fits (rare due to transfer-priority), pick the closest route <= maxStops
    let bestPick = null;
    for(const st of allStations){
      if(st === startStation) continue;
      const best = dijkstraMinTransferStops(startStation, st);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops > 0 && stops <= maxStops){
        if(!bestPick || stops > bestPick.stops){
          bestPick = { dest: st, path, stops };
        }
      }
    }
    if(bestPick) return { dest: bestPick.dest, path: bestPick.path };

    // 3) Absolute fallback: any reachable station
    const reachable = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d !== undefined && st !== startStation) reachable.push(st);
    }
    const dest = reachable.length ? pick(reachable) : startStation;
    const best = dijkstraMinTransferStops(startStation, dest);
    return { dest, path: (best && best.path) ? best.path : [] };
  }

function randomWalkPath(startLine, startStation){
    let curLine = startLine;

    const idx = lineIndex[curLine][startStation];
    const arr = subwayData[curLine];

    // ì¢…ì ì—ì„œ ì¶œë°œí•˜ë©´ ë¬´ì¡°ê±´ ì¢…ì  ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì¶œë°œ
    let dir;
    if (idx === 0) dir = 1;
    else if (idx === arr.length - 1) dir = -1;
    else dir = Math.random() < 0.5 ? -1 : 1;

    const stepsPlanned = randInt(minStops, maxStops);
    const path = [{ line: curLine, st: startStation }];
    let curSt = startStation;

    for (let step = 1; step <= stepsPlanned; step++) {
      const linesAtCur = getLinesOf(curSt);
      if (linesAtCur.length >= 2) {
        const remain = stepsPlanned - step + 1;
        const nearEnd = remain <= 6;
        const pTransfer = nearEnd ? 0.55 : 0.22;
        if (Math.random() < pTransfer) {
          const choices = linesAtCur.filter(l => l !== curLine);
          if (choices.length) {
            curLine = pick(choices);

            // í™˜ìŠ¹ í›„ì—ë„ ì¢…ì ì´ë©´ ë°©í–¥ ë‹¤ì‹œ ë³´ì •
            const newIdx = lineIndex[curLine][curSt];
            const newArr = subwayData[curLine];
            if (newIdx === 0) dir = 1;
            else if (newIdx === newArr.length - 1) dir = -1;
          }
        }
      }

      const nextSt = getNextOnLine(curLine, curSt, dir);
      if (!nextSt) break;

      curSt = nextSt;
      path.push({ line: curLine, st: curSt });
    }

    return path;
  }

  // Result overlay
  const overlay=document.getElementById('resultOverlay');
  const resultStation=document.getElementById('resultStation');
  const resultCount=document.getElementById('resultCount');
  const resultBox=document.getElementById('resultBox');
  const resultCanvas=document.getElementById('resultCanvas');
  const resultCtx=resultCanvas.getContext('2d');

  document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; });
  document.getElementById('searchBtn').addEventListener('click', ()=>{
    const station = (resultStation.textContent || '').trim(); // includes 'ì—­'
    const query = encodeURIComponent(station + " ë°ì´íŠ¸ì½”ìŠ¤");
    window.open("https://search.naver.com/search.naver?query=" + query, "_blank");
  });

  function showResultOverlay(stationName,totalMoved){
    resultStation.textContent = formatStation(stationName);
    if(typeof totalMoved === 'number' && isFinite(totalMoved)){
      resultCount.textContent = 'ì´ ' + totalMoved + 'ì •ê±°ì¥ ì´ë™';
    } else {
      resultCount.textContent = '';
      // ì°ëœë¤ ëª¨ë“œì—ì„œëŠ” ì •ê±°ì¥ ìˆ˜ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ
    }
    overlay.style.display='flex';
    const dims = resizeCanvasTo(resultBox, resultCanvas, resultCtx);
    burstConfettiOn(resultCanvas, resultCtx, dims.w, dims.h);
    playFanfare();
  }

  // Init
  const startInput=document.getElementById('startInput');
  const goBtn=document.getElementById('goBtn');

  try{ localStorage.removeItem(LAST_STATION_KEY); }catch(e){}
  let currentStation = (allStations.includes(DEFAULT_FIRST_STATION) ? DEFAULT_FIRST_STATION : (allStations[0] || DEFAULT_FIRST_STATION));
let currentLine = getLinesOf(currentStation)[0] || lineNames[0];
  startInput.value=currentStation;
  // Force initial dead-center on the person token.
  setTokenAt(currentLine,currentStation,false);
    try{ snapCameraToTokenNow(); }catch(e){}
  // Ensure initial camera is centered on token (after layout settles)
  requestAnimationFrame(()=>requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} }));

  scheduleInitialCenter();
  hudLine1.textContent=formatStation(currentStation);
  hudLine2.textContent='ì´ë™: 0ì •ê±°ì¥';
  let animating=false;

  // --- Transfer SFX (loop while transferring) ---
  let isTransferring = false;
  let audioPrimed = false;
  const sfxTransfer = document.getElementById('sfxTransfer');
  if(sfxTransfer){
    try{ sfxTransfer.src = TRANSFER_SFX_URL; sfxTransfer.load(); }catch(e){}
    try{ sfxTransfer.volume = 0.01 * volTransfer(); }catch(e){}
    try{ sfxTransfer.muted = false; }catch(e){}
  }
  if(sfxTransfer){
    sfxTransfer.loop = false;
    sfxTransfer.volume = 0.01;
    sfxTransfer.preload = 'auto';
  }

  function primeAudio(){
    // iOS: unlock audio on first user gesture
    if(audioPrimed) return;
    if(!sfxTransfer) { audioPrimed = true; return; }
    audioPrimed = true;
    try{
      sfxTransfer.pause();
      sfxTransfer.currentTime = 0;
      sfxTransfer.muted = true;
      const p = sfxTransfer.play();
      // once a play is allowed, immediately stop and unmute
      Promise.resolve(p).then(()=>{
        try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
        sfxTransfer.muted = false;
      }).catch(()=>{
        // even if it fails, keep unmuted; future plays after gesture may work
        sfxTransfer.muted = false;
      });
    }catch(e){
      try{ sfxTransfer.muted = false; }catch(_e){}
    }

  // Also prime WebAudio so iOS volume control via GainNode is guaranteed
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC && !audioCtx) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.01 * volTransfer();
      // kick off decode early
      if(!transferBuffer) loadTransferBuffer();
    }
  }catch(e){}
}

  // --- audio resume notice (reuse error toast style) ---
  function showResumeNotice(){
    showErr("í™”ë©´ì„ í•œ ë²ˆ í„°ì¹˜í•˜ë©´ ì†Œë¦¬ê°€ ë‹¤ì‹œ ì¬ìƒë©ë‹ˆë‹¤.");
  }
  function hideResumeNotice(){ /* toast auto-hides */ }

// --- iOS background/foreground audio resume fix ---
  // iOS Safari/WebView may suspend or silently drop audio when the page is backgrounded.
  // When returning, sound can stay silent until a new user gesture.
  // We show a small notice (only when likely needed) and arm a one-time resume on the next touch/pointer.
  let _resumeArmed = false;
  let _bgAt = 0;

  function armAudioResumeOnNextGesture(){
    if(_resumeArmed) return;
    _resumeArmed = true;
    const resume = ()=>{
      _resumeArmed = false;
      try{ hideResumeNotice(); }catch(e){}

      // Try hard to re-unlock audio on iOS after background.
      // 1) Resume (or recreate) AudioContext
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(AC && !audioCtx) audioCtx = new AC();
        if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
      }catch(e){}

      // 2) Prime HTMLAudio elements again (iOS can drop the media pipeline after long background)
      try{
        if(sfxTransfer){
          try{ sfxTransfer.pause(); }catch(e){}
          try{ sfxTransfer.currentTime = 0; }catch(e){}
          // Reload helps after long background
          try{ sfxTransfer.load(); }catch(e){}
          // A short play attempt (muted) can re-unlock
          try{
            const prevMuted = sfxTransfer.muted;
            sfxTransfer.muted = true;
            const pp = sfxTransfer.play();
            Promise.resolve(pp).then(()=>{
              try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
              sfxTransfer.muted = prevMuted;
            }).catch(()=>{ sfxTransfer.muted = prevMuted; });
          }catch(e){}
        }
      }catch(e){}

      // 3) Prime once more if needed
      try{ if(!audioPrimed){ primeAudio(); } }catch(e){}

      // If a transfer SFX was in progress when we backgrounded, restart it.
      try{ if(isTransferring){ startTransferSound(); } }catch(e){}
    };
    const opts = { once:true, capture:true, passive:true };
    document.addEventListener('pointerdown', resume, opts);
    document.addEventListener('touchstart', resume, opts);
    document.addEventListener('mousedown', resume, opts);
  }

  function onAppForeground(bgMs){
    // bgMs: how long we were in background (ms)
    let shouldShow = false;
    try{
      // If AudioContext is actually suspended, we definitely need a touch.
      if(audioCtx && audioCtx.state === 'suspended') shouldShow = true;
    }catch(e){}

    // Some iOS cases keep audioCtx 'running' but audio is still muted after long background.
    // If we were away for a while and the app is/was playing movement SFX, prompt a touch anyway.
    try{
      // After a long background (e.g., watching a video), iOS may drop audio even if AudioContext isn't 'suspended'.
      // In that case, always prompt for a single touch to re-unlock audio.
      if(!shouldShow && bgMs && bgMs >= 8000) shouldShow = true;
    }catch(e){}

    if(shouldShow){
      try{ showResumeNotice(); }catch(e){}
    }
    try{ armAudioResumeOnNextGesture(); }catch(e){}
  }

  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      _bgAt = Date.now();
    }else{
      const bgMs = _bgAt ? (Date.now() - _bgAt) : 0;
      _bgAt = 0;
      onAppForeground(bgMs);
    }
  });
  window.addEventListener('pageshow', ()=>{ onAppForeground(9000); });


  function startTransferSound(){
  if(!sfxTransfer) return;
  if(!audioPrimed) primeAudio();

  isTransferring = true;

  
  try{ applyTransferGain(); }catch(e){}
// Ensure WebAudio volume path exists (works reliably on iOS)
  let usingWebAudio = false;
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx && AC) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }

    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.01;
      usingWebAudio = true;
      // Kick off preload (don't await)
      try{ if(!transferBuffer) loadTransferBuffer(); }catch(e){}
    }
  }catch(e){}

  // Preferred: play decoded AudioBuffer from time 0 every time (no Safari currentTime quirks)
  if(usingWebAudio && transferBuffer){
    try{
      // stop any previous one-shot immediately
      try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
      transferOneShot = audioCtx.createBufferSource();
      transferOneShot.buffer = transferBuffer;
      transferOneShot.connect(transferGain);
      transferOneShot.start(0);
      transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
      return;
    }catch(e){
      // fall through to <audio> fallback
    }
  }



  // If WebAudio is available but the buffer isn't decoded yet, wait and then play (avoid iOS <audio> volume quirks)
  if(usingWebAudio && !transferBuffer){
    try{
      loadTransferBuffer().then(()=>{
        try{
          if(!isTransferring) return;
          if(!audioCtx || !transferGain || !transferBuffer) return;
          try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
          transferOneShot = audioCtx.createBufferSource();
          transferOneShot.buffer = transferBuffer;
          transferOneShot.connect(transferGain);
          transferOneShot.start(0);
          transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
        }catch(e){}
      });
      return;
    }catch(e){}
  }
  // Fallback: <audio> element restart (only when WebAudio isn't available)
  if(usingWebAudio){ return; }

  // Fallback: <audio> element restart (less reliable on iOS, but better than silence)
  try{
    // If WebAudio isn't in use, apply element volume
    if(!usingWebAudio){ try{ sfxTransfer.volume = 0.01; }catch(e){} }

    sfxTransfer.muted = false;
    try{ sfxTransfer.loop = false; }catch(e){}
    try{ sfxTransfer.pause(); }catch(e){}

    const doPlay = ()=>{
      try{
        const p = sfxTransfer.play();
        if(p && p.catch) p.catch(()=>{});
      }catch(e){}
    };

    try{
      const onSeeked = ()=>{ doPlay(); };
      sfxTransfer.addEventListener('seeked', onSeeked, { once:true });
      try{ sfxTransfer.currentTime = 0; }catch(e){}
      setTimeout(doPlay, 100);
    }catch(e){
      try{ sfxTransfer.currentTime = 0; }catch(_){}
      doPlay();
    }
  }catch(e){}
}

  function stopTransferSound(){
  if(!sfxTransfer) return;
  isTransferring = false;

  // Stop WebAudio one-shot if used
  try{
    if(transferOneShot){
      try{ transferOneShot.stop(0); }catch(e){}
      transferOneShot = null;
    }
  }catch(e){}

  // Also stop <audio> fallback (harmless if not used)
  try{
    try{ sfxTransfer.loop = false; }catch(e){}
    sfxTransfer.pause();
    try{ sfxTransfer.currentTime = 0; }catch(e){}
  }catch(e){}
}
  
  // === Audio UI ===
  const audioBtn = document.getElementById('audioBtn');

  // Block all background interactions while any overlay is open
  const modalBlocker = document.getElementById('modalBlocker');
  if(modalBlocker){
    ['pointerdown','touchstart','touchmove','click'].forEach(ev=>{
      modalBlocker.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
    });
  }

  const audioOverlay = document.getElementById('audioOverlay');
  const audioBackdrop = document.getElementById('audioBackdrop');
  const audioCloseBtn = document.getElementById('audioCloseBtn');

  const volMoveRange = document.getElementById('volMoveRange');
  const volTransferRange = document.getElementById('volTransferRange');
  const volArriveRange = document.getElementById('volArriveRange');
  const audioMuteBtn = document.getElementById('audioMuteBtn');
  const audioResetBtn = document.getElementById('audioResetBtn');

  function syncAudioUI(){
    if(volMoveRange) volMoveRange.value = String(volMovePct);
    if(volTransferRange) volTransferRange.value = String(volTransferPct);
    if(volArriveRange) volArriveRange.value = String(volArrivePct);
    // keep icons stable; muted state is stored, no extra text
    try{ audioMuteBtn.style.opacity = isMuted ? '0.75' : '1'; }catch(e){}
  }


  function setOverlayState(isOpen){
    document.body.classList.toggle('overlayOpen', !!isOpen);
    const mb = document.getElementById('modalBlocker');
    if(mb) mb.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  }

  function openAudio(){
    if(!audioOverlay) return;
    syncAudioUI();
    audioOverlay.classList.add('show');
    setOverlayState(true);
    audioOverlay.setAttribute('aria-hidden','false');
  }
  function closeAudio(){
    if(!audioOverlay) return;
    audioOverlay.classList.remove('show');
    setOverlayState(false);
    audioOverlay.setAttribute('aria-hidden','true');
  }

  function previewMove(){ try{ playDing(); }catch(e){} }
  function previewArrive(){ try{ playFanfare(); }catch(e){} }
  function previewTransfer(){
    try{
      startTransferSound();
      setTimeout(()=>{ try{ stopTransferSound(); }catch(e){} }, 220);
    }catch(e){}
  }

  function onRangeCommit(kind){
    saveSoundSettings();
    // apply transfer gain immediately if it is currently active
    if(kind==='transfer'){ applyTransferGain(); }
    // preview once on release/change
    if(kind==='move') previewMove();
    else if(kind==='transfer') previewTransfer();
    else if(kind==='arrive') previewArrive();
  }

  if(audioBtn){
    audioBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); });
    audioBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); }, {passive:false});
  }
  if(audioBackdrop){
    audioBackdrop.addEventListener('click', closeAudio);
  }
  if(audioCloseBtn){
    audioCloseBtn.addEventListener('click', closeAudio);
  }

  if(audioMuteBtn){
    audioMuteBtn.addEventListener('click', ()=>{
      isMuted = !isMuted;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
    });
  }

  if(audioResetBtn){
    audioResetBtn.addEventListener('click', ()=>{
      isMuted = false;
      volMovePct = 1000;
      volTransferPct = 2500;
      volArrivePct = 500;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
      // preview a tiny ding so user knows it worked
      try{ playDing(); }catch(e){}
    });
  }

  if(volMoveRange){
    volMoveRange.addEventListener('input', ()=>{ volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 2000); });
    volMoveRange.addEventListener('change', ()=>{ volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 2000); onRangeCommit('move'); });
  }
  if(volTransferRange){
    volTransferRange.addEventListener('input', ()=>{ volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000); });
    volTransferRange.addEventListener('change', ()=>{ volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000); onRangeCommit('transfer'); });
  }
  if(volArriveRange){
    volArriveRange.addEventListener('input', ()=>{ volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 1000); });
    volArriveRange.addEventListener('change', ()=>{ volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 1000); onRangeCommit('arrive'); });
  }

  // Initial UI sync (values already loaded)
  syncAudioUI();


  // Settings UI (min/max stops)
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsBackdrop = document.getElementById('settingsBackdrop');
  const minStopsInputEl = document.getElementById('minStopsInput');
  const maxStopsInputEl = document.getElementById('maxStopsInput');
  const trueRandomToggle = document.getElementById('trueRandomToggle');
  const settingsOk = document.getElementById('settingsOk');
  const settingsCancel = document.getElementById('settingsCancel');

  function updateTrueRandomUI(){
    const on = !!(trueRandomToggle && trueRandomToggle.checked);

    // Fully disable the min/max range controls when True Random is ON
    const stopsRowEl = document.getElementById('stopsRow');
    if(stopsRowEl){
      stopsRowEl.classList.toggle('controlsDisabled', on);
      stopsRowEl.setAttribute('aria-disabled', on ? 'true' : 'false');
    }

    // Also set disabled attributes for accessibility
    [minStopsInputEl, maxStopsInputEl].forEach(el=>{
      if(!el) return;
      el.disabled = on;
      el.style.opacity = on ? '0.45' : '1';
    });
    document.querySelectorAll('.stepBtn').forEach(btn=>{
      if(!btn) return;
      btn.disabled = on;
      btn.style.opacity = on ? '0.35' : '1';
    });

    // Slightly dim the stop row (visual)
    if(stopsRowEl){ stopsRowEl.style.opacity = on ? '0.55' : '1'; }
  }

  function updateStartInputForMode(){
    try{
      if(trueRandomMode){
        startInput.classList.add('trueRandomInput');
        startInput.value = 'ì°ëœë¤ ëª¨ë“œ';
        startInput.setAttribute('readonly','');
        // prevent keyboard / touches
        startInput.style.pointerEvents = 'none';
      }else{
        startInput.classList.remove('trueRandomInput');
        startInput.removeAttribute('readonly');
        startInput.style.pointerEvents = 'auto';
        // restore to last/ current station name
        startInput.value = currentStation || '';
      }
    }catch(e){}
  }

  function clampInt(v, lo, hi){
    v = parseInt(String(v||'').trim(), 10);
    if(!Number.isFinite(v)) return lo;
    return Math.max(lo, Math.min(hi, v));
  }
  function openSettings(){
    if(animating) return;
    minStopsInputEl.value = String(minStops);
    maxStopsInputEl.value = String(maxStops);
    if(trueRandomToggle){
      trueRandomToggle.checked = !!trueRandomMode;
    }
    updateTrueRandomUI();
    settingsOverlay.classList.add('show');
    setOverlayState(true);
    settingsOverlay.setAttribute('aria-hidden','false');
    try{ playTick(); }catch(e){}
    setTimeout(()=>{ try{ (trueRandomMode ? settingsOk : minStopsInputEl).focus(); }catch(e){} }, 40);
  }
  function closeSettings(){
    settingsOverlay.classList.remove('show');
    setOverlayState(false);
    settingsOverlay.setAttribute('aria-hidden','true');
  }
  function applySettings(){
    var minEl = document.getElementById('minStopsInput');
    var maxEl = document.getElementById('maxStopsInput');

    var newMin = parseInt(minEl && minEl.value ? minEl.value : '', 10);
    var newMax = parseInt(maxEl && maxEl.value ? maxEl.value : '', 10);

    if(!isFinite(newMin)) newMin = 6;
    if(!isFinite(newMax)) newMax = 25;

    newMin = Math.min(99, Math.max(1, newMin));
    newMax = Math.min(99, Math.max(1, newMax));

    if(newMax < newMin){
      newMax = newMin;
      if(maxEl) maxEl.value = String(newMax);
    }

    // Save true random toggle
    if(trueRandomToggle){
      trueRandomMode = !!trueRandomToggle.checked;
      try{ localStorage.setItem(TRUE_RANDOM_KEY, trueRandomMode ? '1' : '0'); }catch(e){}
    }

    if(!trueRandomMode){
      minStops = newMin;
      maxStops = newMax;
      try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
      try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
    }

    updateTrueRandomUI();
    updateStartInputForMode();
    closeSettings();
    try{ playDing(); }catch(e){}
  }

  if(settingsBtn){
    settingsBtn.addEventListener('click', openSettings);
    settingsBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); openSettings(); }, {passive:false});
  }
  if(settingsBackdrop){
    settingsBackdrop.addEventListener('click', closeSettings);
  }
  if(settingsCancel){
    settingsCancel.addEventListener('click', closeSettings);
  }
  if(settingsOk){
    settingsOk.addEventListener('click', applySettings);
  }

  if(trueRandomToggle){
    trueRandomToggle.addEventListener('change', ()=>{ try{ playTick(); }catch(e){} try{ const tr=document.getElementById('trueRandomTrack'); if(tr) tr.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} updateTrueRandomUI(); });

    // Make only the switch itself clickable (avoid row-wide label hit areas)
    const trueRandomTrack = document.getElementById('trueRandomTrack');
    const syncSwitchAria = ()=>{ try{ trueRandomTrack.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} };
    syncSwitchAria();
    if(trueRandomTrack){
      trueRandomTrack.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        trueRandomToggle.checked = !trueRandomToggle.checked;
        syncSwitchAria();
        trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
      });
      trueRandomTrack.addEventListener('keydown', (e)=>{
        if(e.key==='Enter' || e.key===' '){
          e.preventDefault();
          trueRandomToggle.checked = !trueRandomToggle.checked;
          syncSwitchAria();
          trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
        }
      });
    }

  }

  // Apply initial mode effects to the start input (after we have UI refs).
  updateStartInputForMode();

  // Step buttons
  document.querySelectorAll('.stepBtn').forEach(btn=>{
    const doStep = ()=>{
      if(btn.disabled) return;
      if(typeof trueRandomMode!=='undefined' && trueRandomMode) return;
      const which = btn.getAttribute('data-step');
      const delta = parseInt(btn.getAttribute('data-delta')||'0',10) || 0;
      if(which === 'min'){
        const next = clampInt(minStopsInputEl.value,1,99) + delta;
        minStopsInputEl.value = String(clampInt(next,1,99));
      } else {
        const next = clampInt(maxStopsInputEl.value,1,99) + delta;
        maxStopsInputEl.value = String(clampInt(next,1,99));
      }
      try{ playTick(); }catch(e){}
    };

    // Prevent double-tap / bubbling into the map viewport
    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); });
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); }, {passive:false});
    btn.addEventListener('dblclick', (e)=>{ e.preventDefault(); });
  });

  // Enter = apply, ESC = close
  settingsOverlay && settingsOverlay.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape') closeSettings();
    if(e.key === 'Enter') applySettings();
  });


  function findStartStation(input){
    const q=normalizeName(input);
    for(const s of allStations) if(normalizeName(s)===q) return s;
    return null;
  }

  async function animatePath(path){
    let moved=0;
    for(let i=0;i<path.length;i++){
      const cur=path[i];
      hudLine1.textContent=formatStation(cur.st);
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';
      if(i===0){
        // Teleport to start: snap camera immediately so it follows from the first segment
        setTokenAt(cur.line,cur.st,false);
        try{ snapCameraToTokenNow(); }catch(e){}
        await sleep(180);
        continue;
      }
      const prev=path[i-1];
            if(prev.line !== cur.line){ startTransferSound(); }
      await moveSegment(prev.line,prev.st,cur.line,cur.st);
      if(prev.line !== cur.line){ stopTransferSound(); }

      // Count only actual station-to-station moves. Transfers at the same station do NOT count as a stop.
      if(prev.st !== cur.st){
        moved++;
      }
      hudLine2.textContent='ì´ë™: '+moved+'ì •ê±°ì¥';

      playTick();
      await sleep(160);
      const remain=(path.length-1)-i;
      const t=Math.max(0,6-remain);
      const jitter=Math.floor(Math.random()*180);
      const curve=t===0 ? 1 : (1 + 0.14*t*t);
      let ms=(380 + jitter)*curve;
      if(remain<=2) ms += 260;
      await sleep(ms);
    }
    return moved;
  }

  async function trueRandomWarpTo(destStation){
    // Warp around randomly for a fixed duration, then stop at destination.
    // NOTE: This is purely for fun (ì°ëœë¤), so it doesn't follow line order.
    const DURATION_MS = 16500; // ì´ 16.5ì´ˆ ì›Œí”„ ì• ë‹ˆë©”ì´ì…˜ (ìª¼ëŠ”ë§› ìˆê²Œ ì¡°ê¸ˆ ë” ê¸¸ê²Œ)
    const WARPS = 24;          // ì í”„ íšŸìˆ˜ (ë„ˆë¬´ ë¹½ë¹½í•˜ì§€ ì•Šê²Œ)

    // Create a slowdown schedule whose intervals sum to DURATION_MS.
    // Start fast, end slow (quadratic ease-out style).
    const minInterval = 160;
    const maxInterval = 1150;
    const raw = [];
    let rawSum = 0;
    for(let i=0;i<WARPS;i++){
      const t = (WARPS<=1) ? 1 : (i/(WARPS-1));
      const e = Math.pow(t, 1.7); // ë¶€ë“œëŸ¬ìš´ ê°ì† (ì´ˆë°˜ ë„ˆë¬´ ë¹ ë¥¸ ì›Œí”„ ë°©ì§€)
      const v = minInterval + (maxInterval - minInterval) * e;
      raw.push(v);
      rawSum += v;
    }
    const scale = DURATION_MS / rawSum;

    for(let i=0;i<WARPS;i++){
      const isLast = (i === WARPS-1);
      // pick a random station (avoid dest until the very last warp)
      let st = destStation;
      if(!isLast){
        for(let tries=0; tries<10; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== destStation){ st = cand; break; }
        }
      }

      const lines = getLinesOf(st);
      const ln = lines.length ? lines[Math.floor(Math.random()*lines.length)] : (lineNames[0]||'');
      setTokenAt(ln, st, false);
      // Keep station name updating (including final stop). Only the 2nd line stays uniform.
      hudLine1.textContent = formatStation(st);
      hudLine2.textContent = 'ì›Œí”„ì¤‘..';
      try{ playTick(); }catch(e){}

      // scaled interval + tiny randomness (kept small so total stays ~16.5s)
      const jitter = isLast ? 0 : (Math.random()*40);
      const delay = Math.max(20, Math.floor(raw[i] * scale + jitter));
      await sleep(delay);
    }

    // Ensure camera is centered once we land.
    try{ snapCameraToTokenNow(); }catch(e){}
    // ì‚´ì§ ì •ì°©í•˜ëŠ” ëŠë‚Œ
    await sleep(180);
  }

  async function finale(targetStation,totalMoved){
    // Keep HUD consistent at arrival (no 'ì›Œí”„ì¤‘..' flash).
    try{ hudLine1.textContent = formatStation(targetStation); }catch(e){}
    try{
      if(typeof totalMoved === 'number'){
        hudLine2.textContent = 'ì´ë™: ' + totalMoved + 'ì •ê±°ì¥';
      } else {
        hudLine2.textContent = 'ì›Œí”„ì¤‘..';
      }
    }catch(e){}
    stopTransferSound();
    playDing();
    const dims = resizeCanvasTo(viewport, confCanvas, confCtx);
    burstConfettiOn(confCanvas, confCtx, dims.w, dims.h);
    showResultOverlay(targetStation,totalMoved);
  }

  async function onStart(){
    if(animating) return;
    if(trueRandomMode){
      // True random: pick a random start AND destination from the whole map.
      animating=true; goBtn.disabled=true;
      primeAudio();
      startBGM();
      overlay.style.display='none';

      // Pick random start
      let startStation = currentStation;
      if(allStations.length){
        startStation = allStations[Math.floor(Math.random()*allStations.length)] || currentStation;
      }
      currentStation = startStation;
      currentLine = (getLinesOf(currentStation)[0] || lineNames[0]);
      setTokenAt(currentLine, currentStation, false);
      try{ snapCameraToTokenNow(); }catch(e){}
      try{ hudLine1.textContent = formatStation(currentStation); }catch(e){}
      try{ hudLine2.textContent = 'ì›Œí”„ì¤‘..'; }catch(e){}

      // Pick random destination (not the same as start)
      let dest = startStation;
      if(allStations.length>1){
        for(let tries=0; tries<40; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== startStation){ dest = cand; break; }
        }
      }

      await trueRandomWarpTo(dest);
      // Hold on the destination briefly so it doesn't feel like it "pops".
      await sleep(650);
      await finale(dest, null);
      currentStation=dest;
      currentLine=getLinesOf(currentStation)[0] || currentLine;
      try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
      animating=false; goBtn.disabled=false;
      return;
    }

    const startStation=findStartStation(startInput.value);
    if(!startStation){ showErr('ì¶œë°œì—­ ì˜¤íƒ€! ì˜ˆ: í˜œí™”, ë™ëŒ€ë¬¸, ì„œìš¸ì—­, ê°•ë‚¨'); return; }


    // If the user sets a stop range that is impossible from this start station (in terms of
    // *minimum-stops* graph distance), clamp it and clearly ì•ˆë‚´í•œë‹¤.
    try{
      const dist = bfsDistances(startStation);
      let maxPossible = 0;
      dist.forEach((v)=>{ if(v>maxPossible) maxPossible = v; });
      if(Number.isFinite(maxPossible) && maxPossible > 0){
        if(maxStops > maxPossible){
          maxStops = maxPossible;
          if(minStops > maxStops) minStops = maxStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('ì¶œë°œì—­ ê¸°ì¤€ ìµœëŒ€ ì´ë™ ê°€ëŠ¥ ì •ê±°ì¥ ìˆ˜(' + maxPossible + 'ì—­)ë¥¼ ì ìš©í–ˆìŠµë‹ˆë‹¤.');
        } else if(minStops > maxPossible){
          minStops = maxPossible;
          if(maxStops < minStops) maxStops = minStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('ì¶œë°œì—­ ê¸°ì¤€ ìµœëŒ€ ì´ë™ ê°€ëŠ¥ ì •ê±°ì¥ ìˆ˜(' + maxPossible + 'ì—­)ë¥¼ ì ìš©í–ˆìŠµë‹ˆë‹¤.');
        }
      }
    }catch(e){}

    animating=true; goBtn.disabled=true;
    primeAudio();
    startBGM();
    overlay.style.display='none';
    currentStation=startStation;
    currentLine=getLinesOf(currentStation)[0] || lineNames[0];
    const plan = planOptimalTrip(currentStation);
    const path = (plan && plan.path) ? plan.path : [];
    if(!path.length || !path[0] || !path[0].st){
      alert('ê²½ë¡œë¥¼ ì°¾ì§€ ëª»í–ˆì–´ ã… ã…  (ì¶œë°œ/ë„ì°© ì—­ì„ ë‹¤ì‹œ í™•ì¸í•´ì¤˜)');
      animating=false; goBtn.disabled=false;
      return;
    }

    // update currentLine to the route's starting line (could change if station belongs to multiple lines)
    currentLine = (path[0] && path[0].line) ? path[0].line : currentLine;
    const last=path[path.length-1];
    const moved=await animatePath(path);
    // Arrived: pause briefly before showing the result so it feels intentional.
    hudLine1.textContent = formatStation(last.st);
    hudLine2.textContent = 'ì´ë™: ' + moved + 'ì •ê±°ì¥';
    await sleep(650);
    await finale(last.st,moved);
    currentStation=last.st;
    currentLine=last.line;
    try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
    animating=false; goBtn.disabled=false;
  }

  goBtn.addEventListener('click', onStart);
  goBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
})();

// === VisualViewport height fix (prevents top blank on mobile Safari) ===
(function setupVvh(){
  const setVvh = () => {
    const vv = window.visualViewport;
    const h = vv ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--vvh', (h * 0.01) + 'px');
  };
  setVvh();
  window.addEventListener('resize', setVvh);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', setVvh);
})();</script>

<script>
// Prevent text selection, callout, and dragging (mobile friendly)
(()=>{
  const prevent = (e)=>{ try{ e.preventDefault(); }catch(_){} };
  document.addEventListener('selectstart', prevent, {passive:false});
  document.addEventListener('dragstart', prevent, {passive:false});
  document.addEventListener('contextmenu', prevent, {passive:false});
  document.addEventListener('gesturestart', prevent, {passive:false});
  document.addEventListener('dblclick', (e)=>{
    // avoid double-tap selection on some browsers
    prevent(e);
  }, {passive:false});
})();
</script>

  <div id="resumeNotice">í™”ë©´ì„ í•œ ë²ˆ í„°ì¹˜í•˜ë©´ ì†Œë¦¬ê°€ ë‹¤ì‹œ ì¬ìƒë©ë‹ˆë‹¤.</div>
  <div id="modalBlocker" class="modalBlocker" aria-hidden="true"></div>
</body>
</html>
