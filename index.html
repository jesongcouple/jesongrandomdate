<!-- BUILD_BUTTON_UI_V1 -->
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="theme-color" content="#ff4d6d" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- iOS ÌôàÌôîÎ©¥ ÏïÑÏù¥ÏΩòÏùÄ manifestÎ≥¥Îã§ apple-touch-iconÏùÑ Ïö∞ÏÑ†ÌïòÎäî Í≤ΩÏö∞Í∞Ä ÎßéÏùå -->
<link rel="apple-touch-icon" href="./apple-touch-icon.png" />
<!-- Î∏åÎùºÏö∞Ï†Ä ÌÉ≠ ÏïÑÏù¥ÏΩò(ÏÑ§ÏπòÌòï ÏïÑÏù¥ÏΩòÍ≥º Î≥ÑÍ∞ú) -->
<link rel="icon" href="./icon-192.png" type="image/png" sizes="192x192" />
<link rel="icon" href="./icon-512.png" type="image/png" sizes="512x512" />
<title>Ï†ú‚Ä¢ÏÜ° ÎûúÎç§Îç∞Ïù¥Ìä∏</title>
<style>
:root{--main:#ff4d6d;--bg:#fff0f3;--ink:#c9184a;--stageWpx:320px;--stageHpx:560px;--splashWpx:320px;--splashHpx:560px;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;font-family:-apple-system,system-ui,sans-serif;}
html,body{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
*{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
svg,svg *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
img,svg{ -webkit-user-drag:none; user-drag:none; }
input,button,textarea,select{ -webkit-user-select:none; user-select:none; }

body{margin:0;background:var(--bg);}
.wrap{max-width:520px;margin:0 auto;padding:14px;}
.card{background:#fff;border:6px solid #ffccd5;border-radius:28px;padding:14px;box-shadow:0 14px 30px rgba(255,77,109,.18);}
.title{font-weight:900;color:var(--ink);font-size:20px;margin:0 0 14px;text-align:center;}
.row{display:flex;
  align-items:center;
  justify-content:center;
  ex;gap:10px;align-items:center;flex-wrap:wrap;}
input{flex:1;min-width:180px;padding:12px 14px;border-radius:18px;border:3px solid #ffccd5;font-size:16px;outline:none;text-align:center;}

/* === True Random mode: lock start input + sparkle text === */
.trueRandomInput{
  color:#ff4d6d !important;
  font-weight:1000 !important;
  letter-spacing:0.4px;
  border-color:#ff8fa3 !important;
  /* ÌÖåÎëêÎ¶¨Îäî ÍπúÎπ°Ïù¥ÏßÄ ÏïäÍ≥† ÏùÄÏùÄÌïòÍ≤å ÎπõÎÇòÍ∏∞Îßå */
  box-shadow: 0 0 0 3px rgba(255,77,109,0.18), 0 0 18px rgba(255,77,109,0.22);
  /* Î∞òÏßùÏûÑÏùÄ Í∏ÄÏûêÎßå */
  animation: trSparkle 1.1s ease-in-out infinite;
}
@keyframes trSparkle{
  0%{ text-shadow: 0 0 4px rgba(255,77,109,0.30), 0 0 10px rgba(255,77,109,0.18); }
  50%{ text-shadow: 0 0 8px rgba(255,77,109,0.55), 0 0 18px rgba(255,77,109,0.28); }
  100%{ text-shadow: 0 0 5px rgba(255,77,109,0.32), 0 0 12px rgba(255,77,109,0.20); }
}
button{padding:12px 16px;border:0;border-radius:999px;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:#fff;font-weight:900;font-size:16px;box-shadow:0 10px 18px rgba(255,77,109,.25);cursor:pointer;}
button:disabled{background:#ccc;box-shadow:none;cursor:default;}
.stageWrap{margin-top:12px;width:var(--stageWpx);height:var(--stageHpx);margin-left:auto;margin-right:auto;background:#fff8f9;border:2px solid #ffd6df;border-radius:22px;overflow:hidden;position:relative;}
.viewport{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;background:#fff8f9;position:relative;touch-action:pan-x pan-y;}
.viewport{scrollbar-width:none;-ms-overflow-style:none;}
.viewport::-webkit-scrollbar{width:0;height:0;display:none;}

svg{display:block;}
.lineStroke{stroke-width:22;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;filter:drop-shadow(0 10px 14px rgba(0,0,0,.10));}
.lineInner{stroke:#fff;stroke-width:7;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;}
.connector{stroke:#ffb3c1;stroke-width:5;stroke-linecap:round;opacity:.75;fill:none;}
.label{font-size:11px;font-weight:900;fill:#c9184a;opacity:1;}
.stationDot{fill:#fff;stroke:var(--main);stroke-width:4;opacity:1;}
.token{filter:drop-shadow(0 10px 12px rgba(0,0,0,.16));}
.token circle,.token rect{fill:var(--main);stroke:#fff;stroke-width:4;}
#hudRect{fill:white;stroke:#ffccd5;stroke-width:4;opacity:.94;}
#confetti{position:absolute;inset:0;pointer-events:none;z-index:20;}

#resultOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;}
#resultBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
#resultBox{position:relative;width:min(360px,86vw);background:#fff;border-radius:24px;padding:22px 26px;text-align:center;border:4px solid #ffccd5;box-shadow:0 20px 40px rgba(255,77,109,.25);overflow:hidden;}
#resultCanvas{position:absolute;inset:0;pointer-events:none;z-index:2;}
#resultContent{position:relative;z-index:3;}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;display:none;background:rgba(0,0,0,.85);color:#fff;padding:12px 14px;border-radius:14px;font-weight:900;font-size:11px;line-height:1.35;}

/* --- Splash (tap -> loading -> reveal) --- */
#startOverlay{
  position:fixed;
  inset:0;
  z-index:100000;
  background:var(--bg);
  opacity:1;
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  padding:0; /* Ïπ¥ÎìúÏ≤òÎüº ÏûëÍ≤åÎäî Ïïà Î≥¥Ïù¥Îêò, Ïä§ÌÅ¨Î°§/ÎÑòÏπ® Î∞©ÏßÄÏö© ÏµúÏÜå Ïó¨Î∞± */
  touch-action:manipulation;
  user-select:none;
}
#startOverlay.fadeOut{ opacity:0; transition:opacity .55s ease; }

.splashStage{
  width:var(--splashWpx);
  height:var(--splashHpx);
  border-radius:0;
  overflow:hidden;
  border:0;
  background:var(--bg);
  position:relative;
}
#splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
/* 63ÎπåÎî© Ï£ºÎ≥Ä: ÏïÑÏ£º ÏïΩÌïú Î∞òÏßùÎ∞òÏßù */
.splashTwinkles{
  position:absolute;
  right:18%;
  bottom:22%;
  width:140px;
  height:220px;
  z-index:2;
  pointer-events:none;
  filter: drop-shadow(0 6px 10px rgba(255,255,255,.15));
}
.splashTwinkles i{
  position:absolute;
  width:7px;
  height:7px;
  border-radius:50%;
  background:rgba(255,255,255,.9);
  opacity:0;
  transform:scale(.6);
  animation:splashTwinkle 2.8s ease-in-out infinite;
}
.splashTwinkles i:nth-child(1){ left:52px; top:32px;  animation-delay:.1s;  width:6px; height:6px; }
.splashTwinkles i:nth-child(2){ left:88px; top:72px;  animation-delay:1.0s; width:7px; height:7px; }
.splashTwinkles i:nth-child(3){ left:36px; top:104px; animation-delay:1.7s; width:5px; height:5px; }
.splashTwinkles i:nth-child(4){ left:98px; top:140px; animation-delay:.6s;  width:6px; height:6px; }
.splashTwinkles i:nth-child(5){ left:64px; top:168px; animation-delay:2.2s; width:5px; height:5px; }

@keyframes splashTwinkle{
  0%{ opacity:0; transform:scale(.6); }
  35%{ opacity:1; transform:scale(1); }
  70%{ opacity:.35; transform:scale(.85); }
  100%{ opacity:0; transform:scale(.6); }
}

#tapHintWrap, #splashLoading{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  text-align:center;
  width:100%;
  padding:0 14px;
}
#tapHint{
  font-size:18px;
  font-weight:1000;
  letter-spacing:0.5px;
  color:rgba(255,255,255,.96);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  animation:tapPulse 1.05s ease-in-out infinite;
}
@keyframes tapPulse{
  0%{ transform:scale(.98); opacity:.55; }
  45%{ transform:scale(1.04); opacity:1; }
  100%{ transform:scale(.98); opacity:.55; }
}
#splashLoading{
  font-size:20px;
  font-weight:1000;
  letter-spacing:1px;
  color:rgba(255,255,255,.95);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  display:none;
  line-height:1;
}
#splashLoading.show{ display:block; }
#splashLoading .dots::after{ content:""; animation:dots 1.05s steps(4,end) infinite; }
#splashLoading .blink{ animation:blink 0.55s steps(2,end) infinite; }
@keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:.25} }
@keyframes dots{ 0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""} }
#startOverlay.loading #splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
@keyframes loadingZoom{ 0%{ transform:scale(1); filter:saturate(1.05); } 50%{ transform:scale(1.02); filter:saturate(1.15); } 100%{ transform:scale(1); filter:saturate(1.05); } }

/* --- Mini settings button & modal --- */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:800;
  font-size:17px;
  line-height:1;
  box-shadow:0 6px 12px rgba(255,77,109,.18);
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
}
.miniBtn:active{ transform:translateY(1px) scale(.99); }

#settingsOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9000;
}
#settingsOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
#settingsBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);
}
#settingsBox{
  border:3px solid #ffd6df;
  position:relative;
  width:min(380px, 88vw);
  background:#fff;
  border-radius:24px;
  padding:20px 22px 18px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.settingsTitle{
  font-weight:1000;
  font-size:16px;
  color:#d6336c;
  text-align:center;
  margin-bottom:14px;
}
.settingsRow{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:12px 10px;
  border-radius:18px;
  background:#fff8f9;
  border:3px solid #ffccd5;
  margin-bottom:10px;
  text-align:center;
}

/* Combined min/max row (one box) */
.settingsRowCombined{ padding:14px 12px; }

#stopsRow.controlsDisabled{
  pointer-events:none;
}
#stopsRow.controlsDisabled .settingsLabel{
  opacity:.85;
}
#stopsRow.controlsDisabled .stepBtn,
#stopsRow.controlsDisabled .numInput{
  filter:saturate(.9);
}
.stopsGrid{
  width:100%;
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  align-items:center;
  justify-items:center;
}
.stopItem{ width:100%; display:flex;
  align-items:center;
  justify-content:center;
  ex; flex-direction:column; align-items:center; gap:8px; }
.stopItem .numInput{ width:78px; min-width:78px; }
.stopItem .stepBtn{ width:40px; height:40px; border-radius:14px; }

/* True random row: a bit darker / more present */
.settingsRowStrong{
  background:linear-gradient(180deg,#ffe3ea,#ffd2dc);
  border-color:#ff8fa3;
}
.settingsLabel{
  font-weight:900;
  font-size:13px;
  color:#d6336c;
  white-space:nowrap;
  width:100%;
  text-align:center;
}
.stepper{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  gap:8px;
}
.numInput{
  width:84px;
  min-width:84px;
  padding:10px 10px;
  border-radius:14px;
  border:2px solid #ffd6df;
  font-weight:1000;
  font-size:16px;
  text-align:center;
  outline:none;
}
.stepBtn{
  touch-action:manipulation;
  user-select:none;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:16px;
  line-height:1;
  box-shadow:0 10px 18px rgba(255,77,109,.18);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
}
.stepBtn:active{ transform:translateY(1px) scale(.99); }
.stepBtn:disabled{ opacity:.35; cursor:not-allowed; pointer-events:none; filter:grayscale(.1); }
.stepBtn:disabled:active{ transform:none; }

.settingsHint{
  margin:8px 2px 14px;
  font-weight:900;
  font-size:11px;
  color:#ff4d6d;
  text-align:center;
  opacity:.92;
}
.settingsActions{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  justify-content:center;
  gap:10px;
}
.ghostBtn{
  padding:10px 16px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:#fff0f3;
  color:#d6336c;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
}
.solidBtn{
  padding:10px 18px;
  border-radius:999px;
  border:0;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
}


/* === Visual viewport height var (mobile Safari fix) === */
:root{ --vvh: 1vh; }
#startOverlay{ height: calc(var(--vvh) * 100); }
#splashStage{ height: calc(var(--vvh) * 100); width: 100%; }


/* === Settings UI tone override (softer) === */
.miniBtn{
  width:40px !important;
  height:40px !important;
  border-radius:12px !important;
  border:2px solid #ffd6df !important;
  background: rgba(255,240,243,.92) !important;
  color:#c9184a !important;
  box-shadow:0 6px 12px rgba(201,24,74,.12) !important;
  font-weight:900 !important;
}
.miniBtn:hover{ filter:none !important; }
.stepBtn{
  border:2px solid #ffd6df !important;
  background: linear-gradient(135deg,#ff8fa3,#ffb3c1) !important;
  box-shadow:0 6px 12px rgba(201,24,74,.10) !important;
}
#settingsBox{
  border:3px solid #ffd6df !important;
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 4px 8px rgba(201,24,74,.16),
    inset 0 1px 0 rgba(255,255,255,.7) !important;
}


/* === Mobile splash: fill the whole screen (no side gaps) === */
@media (max-width: 700px){
  #startOverlay{ padding:0 !important; }
  .splashStage{ width:100vw !important; height:calc(var(--vvh) * 100) !important; }
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}


/* === Settings button: deep pink 3D === */
.miniBtn{
  background: linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  border:2px solid #ffb3c1 !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}





/* === Settings button redraw (border + 3D, no mismatch) === */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:46px;
  height:46px;
  border-radius:16px;
  border:0 !important;
  background: linear-gradient(180deg,#ff7a9b 0%, #ff3d66 100%) !important;
  color:#fff !important;
  font-weight:900;
  font-size:18px;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
  box-shadow: 0 12px 18px rgba(201,24,74,.22);
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:16px;
  box-shadow:
    inset 0 0 0 3px rgba(255,204,213,.95),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.14);
  pointer-events:none;
}
.miniBtn::after{
  content:"";
  position:absolute;
  inset:4px;
  border-radius:12px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%);
  pointer-events:none;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98);
  box-shadow: 0 8px 12px rgba(201,24,74,.20);
}
@media (max-width:700px){
  .miniBtn{ right: calc(10px + env(safe-area-inset-right)); bottom: calc(10px + env(safe-area-inset-bottom)); }
}


/* === Settings button border redraw (perfect match) === */
.miniBtn{
  position:absolute !important;
  right:10px !important;
  bottom:10px !important;
  width:46px !important;
  height:46px !important;
  border-radius:16px !important;
  border:none !important;            /* border drawn by ::before */
  background:linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
  display:flex;
  align-items:center;
  justify-content:center;
  ex !important;
  align-items:center !important;
  justify-content:center !important;
  cursor:pointer !important;
  z-index:30 !important;
  padding:0 !important;
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  border:3px solid rgba(255,204,213,.95);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    0 0 0 1px rgba(255,204,213,.15);
  pointer-events:none;
}
.miniBtn:active{
  transform:translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}



/* === Pan extra space: allow camera to truly center token (top+bottom) === */
#panTopPad{ height:120px; width:1px; }
#panBottomPad{ height:900px; width:1px; }


.row{position:relative;z-index:50;}


/* Hide native number input spinners (use our icon buttons instead) */
.numInput::-webkit-outer-spin-button,
.numInput::-webkit-inner-spin-button{
  -webkit-appearance: none;
  margin: 0;
}
.numInput{
  -moz-appearance: textfield;
  appearance: textfield;
}


/* === True Random Toggle Switch === */
.toggleSwitch{ position:relative; display:inline-flex; align-items:center; width:fit-content;  pointer-events:none; }
.toggleSwitch input{ position:absolute; opacity:0; width:1px; height:1px; }
.toggleTrack{
  display:inline-block;
  pointer-events:auto;
  touch-action:manipulation;
  width:78px; height:42px;
  border-radius:999px;
  background: linear-gradient(180deg,#ffe3ea 0%, #ffd6df 100%);
  border:3px solid #ffccd5;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.06);
  position:relative;
  transition: all .22s ease;
  cursor:pointer;
}
.toggleKnob{
  z-index:2;
  position:absolute; top:50%; left:4px;
  width:34px; height:34px;
  border-radius:999px;
  transform: translateY(-50%);
  background: linear-gradient(180deg,#ffffff 0%, #fff7f9 100%);
  border:2px solid rgba(255,204,213,.9);
  box-shadow: 0 8px 14px rgba(201,24,74,.14);
  transition: all .22s ease;
}
.toggleText{
  z-index:1;
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  ex; align-items:center; justify-content:space-between;
  padding:0 9px;
  font-weight:1000;
  font-size:11px;
  letter-spacing:.5px;
  color: rgba(201,24,74,.45);
  pointer-events:none;
}
.toggleText span{ display:inline-block;  opacity:.55; transition:opacity .22s ease; min-width:28px; text-align:center; }
.toggleText .on{ opacity:.25; transform:translateX(2px); }
.toggleText .off{ opacity:.75; transform:translateX(-2px); }

.toggleSwitch input:checked ~ .toggleTrack{
  background: linear-gradient(135deg,#ff8fa3 0%, #ff4d6d 100%);
  border-color:#ffb3c1;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.07), 0 10px 18px rgba(201,24,74,.14);
}
.toggleSwitch input:checked ~ .toggleTrack .toggleKnob{
  z-index:2; left: calc(100% - 4px - 34px); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText{
  z-index:1; color: rgba(255,255,255,.88); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .on{ opacity:.95; }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .off{ opacity:.35; }

.hotPink{ color:#ff4d6d !important; font-weight:1000 !important; }



/* iOS audio resume notice */
#resumeNotice{position:fixed;left:50%;transform:translateX(-50%);bottom:110px;z-index:9999;padding:8px 12px;border-radius:12px;background:rgba(255,255,255,.92);color:#444;font-size:12px;box-shadow:0 8px 18px rgba(0,0,0,.12);display:none;pointer-events:none;}

/* === Sound control button (above settings) === */
.soundBtn{
  bottom:64px !important; /* above ‚öôÔ∏è */
}

/* === Sound overlay (volume) === */
#audioOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9050; /* above settings (9000) */
}
#audioOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
#audioBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);
}
#audioBox{
  position:relative;
  width:min(420px, 92vw);
  background:#fff;
  border-radius:26px;
  padding:18px 18px 16px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.audioTitle{
  font-weight:1000;
  font-size:18px;
  color:#d6336c;
  text-align:center;
  margin:2px 0 12px;
}
.audioTopActions{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  gap:10px;
  justify-content:center;
  align-items:center;
  margin-bottom:10px;
}
.audioRoundBtn{
  width:46px;
  height:46px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:linear-gradient(180deg,#ffe3ea 0%, #ffd2dc 100%);
  box-shadow:
    0 10px 16px rgba(201,24,74,.18),
    inset 0 2px 0 rgba(255,255,255,.45),
    inset 0 -2px 0 rgba(0,0,0,.08);
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  font-size:18px;
  cursor:pointer;
  user-select:none;
}
.audioRoundBtn:active{ transform:translateY(1px) scale(.98); }

.audioCard{
  width:100%;
  background:#fff8f9;
  border:3px solid #ffccd5;
  border-radius:20px;
  padding:12px 12px 14px;
  margin:10px 0;
}
.audioLabel{
  font-weight:1000;
  font-size:14px;
  color:#d6336c;
  text-align:center;
  margin-bottom:10px;
}
.audioRow{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  gap:10px;
  width:100%;
}
.audioHint{
  width:26px;
  text-align:center;
  font-size:14px;
  opacity:.55;
  user-select:none;
}
.audioRange{
  flex:1 1 auto;
  width:100%;
  min-width:0;
  max-width:none;
  -webkit-appearance:none;
  appearance:none;
  height:8px;
  border-radius:999px;
  background:#e9ecef;
  outline:none;
}
.audioRange::-webkit-slider-thumb{
  -webkit-appearance:none;
  appearance:none;
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioRange::-moz-range-thumb{
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioCloseRow{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  justify-content:center;
  margin-top:12px;
}
.audioCloseBtn{
  width:100%;
  padding:14px 16px;
  border-radius:999px;
  border:none;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:18px;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
  cursor:pointer;
}
.audioCloseBtn:active{ transform:translateY(1px) scale(.99); }


/* === Modal behavior: block background interaction when overlays are open === */
body.overlayOpen .wrap,
body.overlayOpen canvas{
  pointer-events:none;
}
#settingsOverlay,
#audioOverlay{
  pointer-events:auto;
}


/* Modal interaction blocker (prevents any background taps/drags) */
.modalBlocker{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0);
  z-index: 9998;
  display: none;
  touch-action: none;
}
body.overlayOpen .modalBlocker{ display:block; }
/* Ensure overlays are above blocker */
#settingsOverlay, #audioOverlay{ z-index: 10000; }


/* === FIX: range reaches visual edges (speaker + range + speaker via grid) === */
.sound-slider-wrap{
  display: grid !important;
  grid-template-columns: auto 1fr auto !important;
  align-items: center !important;
  column-gap: 8px !important;
  width: 100% !important;
}
.sound-slider-wrap input[type="range"]{
  width: 100% !important;
  min-width: 0 !important;
  margin: 0 !important;
}
/* Ensure rows don't shrink the range */
.audioRow{ width: 100% !important; }
.audioRange{
  width: 100% !important;
  max-width: none !important;
  min-width: 0 !important;
}


/* === FIX: iOS range track end-gaps (custom range in audio overlay only) === */
#audioOverlay input[type="range"]{
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  padding: 0;
}
#audioOverlay input[type="range"]::-webkit-slider-runnable-track{
  height: 6px;
  border-radius: 999px;
  background: rgba(0,0,0,0.18);
}
#audioOverlay input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 3px 10px rgba(0,0,0,0.18);
  margin-top: -6px;
}
/* Firefox */
#audioOverlay input[type="range"]::-moz-range-track{
  height: 6px;
  border-radius: 999px;
  background: rgba(0,0,0,0.18);
}
#audioOverlay input[type="range"]::-moz-range-thumb{
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  border: none;
  box-shadow: 0 3px 10px rgba(0,0,0,0.18);
}
#audioOverlay .audioRange{ margin:0 !important; }


/* === UX: make audio sliders easier to grab (bigger hit area) === */
#audioOverlay input[type="range"]{
  height: 34px;
  touch-action: pan-x;
}
#audioOverlay input[type="range"]::-webkit-slider-thumb{
  width: 24px;
  height: 24px;
  margin-top: -9px; /* re-center on 6px track */
}
#audioOverlay input[type="range"]::-moz-range-thumb{
  width: 24px;
  height: 24px;
}


/* === UX: clearer mute button on/off state === */
.audioIconBtn.isOn{
  background: rgba(255,77,109,0.32) !important;
  box-shadow: 0 6px 14px rgba(255,77,109,0.22) !important;
}


/* === FINAL POLISH: remove iOS range focus/box outlines === */
#audioOverlay input[type="range"]{
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background-clip: padding-box !important;
}
#audioOverlay input[type="range"]:focus,
#audioOverlay input[type="range"]:focus-visible{
  outline: none !important;
  box-shadow: none !important;
}


#resumeNotice{display:none!important;}

/* === Pause overlay (forces one tap to resume after background) === */
.pauseOverlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 12000;
  background: rgba(255,77,109,0.04); /* very light pink veil */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
.pauseOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
.pauseCard{
  width: 100%;
  max-width: none;
  padding: 0 18px;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
  text-align: center;
}
.pauseTitle{
  font-weight: 800;
  font-size: 18px;
  margin-bottom: 14px;
}
.pauseHint{
  margin-top: 14px;
  font-size: 13px;
  opacity: 0.75;
}



/* Pause play button (flat) */
.pausePlayBtn{
  width: 88px;
  height: 88px;
  border-radius: 50%;
  border: none;
  background: rgba(255,215,225,0.95); /* Îî∏Í∏∞Ïö∞Ïú†Îπõ */
  box-shadow: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.pausePlayBtn:active{ transform: scale(0.98); }
.pausePlayBtn .tri{
  display:block;
  width: 0;
  height: 0;
  border-top: 14px solid transparent;
  border-bottom: 14px solid transparent;
  border-left: 22px solid rgba(255,90,120,1); /* Ï∞êÌïëÌÅ¨ */
  margin-left: 6px;
}


/* === SAFETY: pause overlay must NEVER block screen unless .show === */
.pauseOverlay{
  display: flex !important;
  opacity: 0 !important;
  visibility: hidden !important;
  pointer-events: none !important;
}
.pauseOverlay.show{
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
}



.pauseTitle{
  font-weight: 800;
}
.pauseHint{
  opacity: 0.9;
}



.pauseTitle{
  font-weight: 800;
}
.pauseHint{
  opacity: 0.95;
}


/* === Pause play button: stronger pink circle === */
.pausePlayBtn{
  background: rgba(255, 180, 195, 0.98) !important;
}


/* === Pause overlay text: solid hot pink, no stroke/shadow === */
.pauseTitle,
.pauseHint{
  color: rgba(255, 85, 120, 1);
  text-shadow: none !important;
  -webkit-text-stroke: 0 !important;
}
.pauseTitle{
  font-weight: 800;
}
.pauseHint{
  opacity: 0.95;
}


/* === Pause overlay text: make hint bold as well === */
.pauseHint{
  font-weight: 700;
}


/* === Global scroll lock: prevent body/pink background bounce (keep #viewport scroll) === */
html, body{
  height: 100%;
  overflow: hidden;          /* page scroll off */
  overscroll-behavior: none; /* prevent bounce on supported browsers */
}
/* iOS: reduce outer layer dragging */
body{
  position: fixed;
  width: 100%;
}


/* === Archive button (above sound) === */
.archiveBtn{
  bottom:118px !important; /* above üîä */
}

/* === Archive overlay (full-screen) === */
#archiveOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:stretch;
  justify-content:stretch;
  z-index:11000; /* above settings/audio */
}
#archiveOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
#archiveBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.92);
  backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);
}
#archiveBox{
  position:relative;
  z-index:2;
  width:100%;
  height:100%;
  background:#fff;
  padding:0;
  box-sizing:border-box;
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
.archiveTop{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:6px 0 12px;
}
.archiveTitle{
  font-weight:1000;
  font-size:18px;
  color:#d6336c;
}
.archiveTopBtns{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  gap:8px;
  flex-wrap:wrap;
  justify-content:flex-end;
}
#archiveList{
  flex:1 1 auto;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  padding:12px 10px;
  background:#fff;
  border:none;
  box-shadow:none;
}
.archiveItem{
  background:#fff8f9;
  border:3px solid #ffccd5;
  border-radius:18px;
  padding:12px;
  margin-bottom:10px;
  display:grid;
  grid-template-columns:26px 1fr auto;
  gap:10px;
  align-items:start;
}
.archiveItem .meta{
  font-weight:1000;
  color:#c9184a;
  font-size:13px;
  margin-bottom:6px;
}
.archiveItem .txt{
  font-weight:900;
  color:#444;
  font-size:13px;
  white-space:pre-wrap;
}
.archiveItem .miniActions{ display:flex;
  align-items:center;
  justify-content:center;
  ex; gap:8px; }
.archiveBtnGhost{
  padding:10px 14px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:#fff0f3;
  color:#d6336c;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
}
.archiveBtnSolid{
  padding:10px 14px;
  border-radius:999px;
  border:none;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
}

/* === Memory overlay (record) === */
#memoryOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:11500;
}
#memoryOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
#memoryBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);
}
#memoryBox{
  position:relative;
  width:min(420px, 92vw);
  background:#fff;
  border-radius:26px;
  padding:18px 18px 16px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.memoryTitle{
  font-weight:1000;
  font-size:18px;
  color:#d6336c;
  text-align:center;
  margin:2px 0 12px;
}
.memoryMeta{
  font-weight:900;
  font-size:12px;
  color:#777;
  text-align:center;
  margin-bottom:10px;
}
.memoryField{
  width:100%;
  background:#fff8f9;
  border:3px solid #ffccd5;
  border-radius:20px;
  padding:12px 12px 14px;
  margin:10px 0;
}
.memoryLabel{
  font-weight:1000;
  font-size:14px;
  color:#d6336c;
  text-align:center;
  margin-bottom:10px;
}
.memoryInput, .memoryTextarea{
  width:100%;
  border:2px solid #ffd6df;
  border-radius:14px;
  padding:10px 10px;
  font-weight:1000;
  font-size:14px;
  outline:none;
  box-sizing:border-box;
}
.memoryTextarea{ min-height:90px; resize:none; }
.memoryActions{ display:flex;
  align-items:center;
  justify-content:center;
  ex; gap:10px; margin-top:10px; }
.memoryActions .archiveBtnGhost, .memoryActions .archiveBtnSolid{ flex:1; }


/* === PIN overlay (4-digit) === */
#pinOverlay{
  position:fixed; inset:0; display:none; align-items:center; justify-content:center;
  z-index:13000;
}
#pinOverlay.show{ display:flex;
  align-items:center;
  justify-content:center;
  ex; }
#pinBackdrop{
  position:absolute; inset:0;
  background:rgba(255,240,243,.60);
  backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);
}
#pinBox{
  position:relative; z-index:2;
  width:min(420px, 92vw);
  background:#fff;
  border-radius:26px;
  padding:18px 18px 16px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
}
.pinTitle{
  font-weight:1000; font-size:18px; color:#d6336c; text-align:center;
  margin:2px 0 8px;
}
.pinSub{
  font-weight:900; font-size:12px; color:#777; text-align:center;
  margin:0 0 12px;
}
.pinDots{
  display:flex;
  align-items:center;
  justify-content:center;
  ex; justify-content:center; gap:10px; margin:8px 0 14px;
}
.pinDot{
  width:14px; height:14px; border-radius:50%;
  border:2px solid #ffb3c1; background:transparent;
}
.pinDot.filled{ background:#ff4d6d; border-color:#ff4d6d; }
.pinPad{
  display:grid; grid-template-columns:repeat(3, 1fr); gap:10px;
  margin-top:8px;
}
.pinKey{
  height:54px;
  border-radius:18px;
  border:3px solid #ffccd5;
  background:#fff8f9;
  color:#d6336c;
  font-weight:1000;
  font-size:18px;
  box-shadow:0 10px 18px rgba(255,77,109,.10);
  cursor:pointer;
}
.pinKey:active{ transform:translateY(1px) scale(.99); }
.pinKey.muted{ opacity:.65; }
.pinActions{
  display:flex;
  align-items:center;
  justify-content:center;
  ex; gap:10px; margin-top:12px;
}
.pinActions .archiveBtnGhost, .pinActions .archiveBtnSolid{ flex:1; }


/* === Fancy Memory Card (share) v2 === */

.destSticker{background: linear-gradient(135deg,#ff5a82,#ff3d66) !important;}
.shareTitle{margin-top:64px !important;}

.shareCardWrap{
  width:720px; height:1280px; /* 9:16 */
  padding:64px 54px;
  background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.85), rgba(255,255,255,0) 55%),
              radial-gradient(circle at 80% 15%, rgba(255,255,255,.55), rgba(255,255,255,0) 45%),
              linear-gradient(180deg, #fff0f6 0%, #ffe8ef 55%, #fff6f9 100%);
  position:relative;
  font-family:-apple-system,system-ui,sans-serif;
}
.shareCard{
  background: rgba(255,255,255,.94);

  width:100%; height:100%;
  background: rgba(255,255,255,.92);
  border-radius:46px;
  border:6px solid rgba(255,204,213,.9);
  box-shadow: 0 30px 70px rgba(201,24,74,.16);
  position:relative;
  overflow:hidden;
  padding:56px 46px 44px;
}
.shareCard:before{
  content:"";
  position:absolute; inset:-40px -40px auto auto;
  width:280px; height:280px;
  background: radial-gradient(circle at 30% 30%, rgba(255,77,109,.22), rgba(255,77,109,0) 60%);
  transform: rotate(10deg);
}
.shareSticker{
  position:absolute;
  left:42px; top:38px;
  display:inline-flex; align-items:center; gap:10px;
  padding:14px 18px;
  border-radius:999px;
  background: linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:white;
  font-weight:1000;
  letter-spacing:.5px;
  box-shadow:0 16px 28px rgba(255,77,109,.20);
  transform: rotate(-2deg);
}
.shareSticker .spark{font-size:18px; opacity:.95}
.shareTitle{
  margin-top:92px;
  font-weight:1000;
  color:#c9184a;
  font-size:38px;
  letter-spacing:-.5px;
}
.shareMeta{
  margin-top:18px;
  display:flex;
  align-items:center;
  justify-content:center;
  ex; gap:14px; flex-wrap:wrap;
}
.shareChip{
  padding:10px 14px;
  border-radius:999px;
  background:#fff0f3;
  border:3px solid rgba(255,204,213,.95);
  color:#d6336c;
  font-weight:1000;
  font-size:22px;
}
.shareBlock{
  margin-top:38px;
  background:#fff8f9;
  border:4px solid rgba(255,204,213,.95);
  border-radius:34px;
  padding:26px 24px;
  position:relative;
}
.shareBlock:before{
  content:"";
  position:absolute;
  left:26px; top:-18px;
  width:62px; height:36px;
  background: rgba(255,179,193,.55);
  border:3px solid rgba(255,204,213,.95);
  border-radius:14px;
  transform: rotate(-6deg);
}
.shareLabel{
  font-weight:1000;
  color:#d6336c;
  font-size:22px;
  margin-bottom:16px;
  display:flex;
  align-items:center;
  justify-content:center;
  ex; align-items:center; gap:10px;
}
.shareText{
  font-weight:1000;
  color:#444;
  font-size:30px;
  line-height:1.25;
  white-space:pre-wrap;
  word-break:keep-all;
}
.shareDoodles{
  position:absolute;
  right:28px;
  bottom:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  ex; gap:10px;
  opacity:.9;
}
.shareDoodles span{
  display:inline-flex;
  width:44px; height:44px;
  border-radius:16px;
  align-items:center; justify-content:center;
  background: rgba(255,240,243,.9);
  border:3px solid rgba(255,204,213,.95);
  box-shadow:0 12px 18px rgba(201,24,74,.10);
  font-size:22px;
  transform: rotate(2deg);
}

.shareScallop{
  position:absolute;
  left:26px; right:26px; top:22px;
  height:22px;
  background:
    radial-gradient(circle at 12px 0px, rgba(255,179,193,.95) 10px, transparent 11px) 0 0/24px 24px repeat-x;
  opacity:.75;
}
.shareSparkles{
  position:absolute;
  inset:0;
  pointer-events:none;
}
.shareSparkles i{
  position:absolute;
  width:14px; height:14px;
  border-radius:4px;
  background: rgba(255,179,193,.55);
  transform: rotate(45deg);
  box-shadow: 0 10px 16px rgba(201,24,74,.08);
  opacity:.75;
}
.shareSparkles i:nth-child(1){ left:70px; top:170px; width:10px; height:10px; opacity:.55;}
.shareSparkles i:nth-child(2){ right:88px; top:210px; width:12px; height:12px; opacity:.55;}
.shareSparkles i:nth-child(3){ left:110px; top:310px; width:9px; height:9px; opacity:.45;}
.shareSparkles i:nth-child(4){ right:120px; top:360px; width:10px; height:10px; opacity:.5;}
.shareTitle{
  margin-top:84px !important;
  font-size:56px !important;
  letter-spacing:-1px;
}
.shareMeta{ margin-top:20px !important; }

.shareCornerHeart{
  position:absolute;
  left:-16px; bottom:-16px;
  width:170px; height:170px;
  background: radial-gradient(circle at 40% 40%, rgba(255,77,109,.22), rgba(255,77,109,0) 65%);
  transform: rotate(12deg);
}


/* === SVG doodle icons === */
.svgIcon{ width:28px; height:28px; display:block; }
.svgIcon *{ vector-effect:non-scaling-stroke; }
.svgStickerIcon{ width:22px; height:22px; }
.svgStroke{ stroke: rgba(201,24,74,.55); stroke-width:3.2; stroke-linecap:round; stroke-linejoin:round; fill:none; }
.svgFillStar{ fill: rgba(255,186,86,.95); stroke: rgba(201,24,74,.35); stroke-width:2.2; }
.svgFillHeart{ fill: rgba(255,77,109,.92); stroke: rgba(201,24,74,.35); stroke-width:2.2; }
.svgFillFlower{ fill: rgba(255,179,193,.95); stroke: rgba(201,24,74,.25); stroke-width:2.2; }
.svgDot{ fill: rgba(201,24,74,.55); }


/* === Archive layout v2 === */
/* === Archive scroll fix v3 === */

#archiveBox{
  padding: 14px 14px calc(92px + env(safe-area-inset-bottom)) !important;
}
.archiveHeader{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:calc(22px + env(safe-area-inset-top)) 0 22px;
  min-height:124px;
  background:var(--bg);
  border-bottom:1px solid rgba(255,204,213,.95);
}
.archiveTitle{
  width:100%;
  text-align:center !important;
  font-weight:1000;
  font-size:20px;
  color:#d6336c;
  letter-spacing:-0.2px;
  white-space:nowrap;
}
.archiveCloseBtn{
  position:absolute;
  right: calc(16px + env(safe-area-inset-right));
  top:   calc(16px + env(safe-area-inset-top));
  width:44px;
  height:44px;
  border-radius:14px;
  border:none;
  background:#ff3d66;
  color:#fff;
  font-weight:1000;
  font-size:20px;
  line-height:1;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:20050; /* above overlays */
}
.archiveCloseBtn:active{ transform:translateY(1px) scale(.99); }
#archiveList{
  height: 100% !important;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  padding-right: 4px;
}

.archiveBottomBar{
  flex:0 0 auto;
  display:flex;
  gap:10px;
  justify-content:center;
  padding:14px 12px calc(14px + env(safe-area-inset-bottom));
  background:#fff;
  border-top:1px solid rgba(255,204,213,.95);
}

.archiveBottomBar{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  gap:10px;
  justify-content:center;
  align-items:center;
}
.archiveBottomBtn{
  flex: 1 1 0;
  max-width: 220px;
  padding: 12px 10px;
  border-radius: 999px;
  border: 3px solid rgba(255,255,255,.55);
  background: rgba(255,255,255,.92);
  color:#c9184a;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow: 0 10px 16px rgba(0,0,0,.12);
}
.archiveBottomBtn:active{ transform:translateY(1px) scale(.99); }


/* === Archive scroll fix v3 overrides === */
#archiveBox{
  display:flex;
  align-items:center;
  justify-content:center;
  ex !important;
  flex-direction:column !important;
  height:100% !important;
  padding: 14px 14px 0 !important;
}
.archiveHeader{ flex:0 0 auto; }
#archiveList{
  flex:1 1 auto !important;
  height:auto !important;
  overflow:auto !important;
  padding-right:4px;
  padding-bottom: 14px;
}
.archiveBottomBar{
  position: sticky !important;
  left:auto !important;
  right:auto !important;
  bottom: 0 !important;
  width: calc(100% + 28px);
  margin-left: -14px;
  margin-right: -14px;
  flex:0 0 auto;
}


/* === Archive UI refresh === */
#archiveBox{
  display:flex;
  align-items:stretch;
  justify-content:flex-start;
  ex;
  flex-direction:column;
  height:100%;
  padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
}
#archiveList{
  width:100%;
  flex:1 1 auto;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  padding:10px 6px;
  background:#fff8f9;
  border:4px solid #ffccd5;
  border-radius:22px;
  margin-top:12px;
}
.archiveBottomBar{
  position:relative !important;
  left:auto !important;
  right:auto !important;
  bottom:auto !important;
  width:100% !important;
  margin:12px 0 0 0 !important;
  border-radius:22px;
}


/* === Share Card v3 (clean+kitch) === */
.shareCardWrap{ width:720px; height:1280px; padding:56px 44px; background: linear-gradient(180deg,#fff0f3 0%, #ffe8ef 55%, #fff6f9 100%); }
.shareCard{
  width:100%; height:100%;
  background: rgba(255,255,255,.95);
  border-radius:48px;
  border:6px solid rgba(255,204,213,.95);
  box-shadow: 0 26px 60px rgba(201,24,74,.14);
  padding:54px 44px 44px;
  position:relative;
  overflow:hidden;
}
.shareTitle{
  font-size:58px;
  font-weight:1000;
  color:#c9184a;
  letter-spacing:-1px;
  line-height:1.05;
}
.shareBadge{
  margin-top:16px;
  display:inline-flex;
  align-items:center;
  gap:10px;
  padding:12px 16px;
  border-radius:999px;
  background:#fff0f3;
  border:3px solid rgba(255,204,213,.95);
  color:#d6336c;
  font-weight:1000;
  font-size:22px;
}
.shareBlock{
  margin-top:26px;
  background:#fff8f9;
  border:4px solid rgba(255,204,213,.95);
  border-radius:34px;
  padding:22px 22px;
}
.shareLabel{ font-size:22px; font-weight:1000; color:#d6336c; margin-bottom:12px; display:flex;
  align-items:center;
  justify-content:center;
  ex; align-items:center; gap:10px; }
.shareText{ font-size:32px; font-weight:1000; color:#333; line-height:1.25; white-space:pre-wrap; word-break:keep-all; }
.shareTape{
  position:absolute;
  top:26px; right:30px;
  width:110px; height:42px;
  border-radius:14px;
  background: rgba(255,179,193,.55);
  border:3px solid rgba(255,204,213,.95);
  transform: rotate(8deg);
}
.shareDot{
  position:absolute;
  width:14px; height:14px;
  border-radius:7px;
  background: rgba(255,77,109,.18);
}
.shareDot.d1{ left:34px; top:120px;}
.shareDot.d2{ right:46px; top:190px;}
.shareDot.d3{ left:88px; bottom:180px;}
.shareDot.d4{ right:90px; bottom:260px;}


/* === Archive BottomBar Slim === */
.archiveBottomBar{
  padding: 10px 10px calc(10px + env(safe-area-inset-bottom)) !important;
}
.archiveBottomBtn{
  height: 54px !important;
  padding: 10px 12px !important;
  font-size: 14px !important;
  line-height: 1.05 !important;
  border-radius: 999px !important;
}
.archiveBottomBtn span{ display:block; }


/* === Archive Item Align (Soft 3D) === */
.archiveItem{
  display:grid !important;
  grid-template-columns: 34px 1fr 92px !important;
  align-items:center !important;

  /* soft 3D card feel */
  background: rgba(255,240,245,.92);
  border: 2px solid rgba(255,205,215,.95);
  border-radius: 26px;
  box-shadow:
    0 6px 14px rgba(201,24,74,.08),
    0 1px 0 rgba(255,255,255,.75) inset,
    0 -2px 6px rgba(201,24,74,.05) inset;
}
.archiveItem input[type="checkbox"]{
  width:24px; height:24px;
  border-radius:8px;
}
.archiveInfo{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  flex-direction:column;
  justify-content:center;
  gap:6px;
  min-height: 88px;
}
.archiveInfo .date{ font-weight:1000; color:#c9184a; font-size:18px; line-height:1.1; }
.archiveInfo .time{ font-weight:900; color:#333; font-size:15px; line-height:1.1; }
.archiveInfo .dest{ font-weight:900; color:#333; font-size:15px; line-height:1.1; }
.archiveActions{
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  flex-direction:column;
  gap:10px;
  justify-content:center;
  align-items:flex-end;
}
.archiveActions .archiveBtnGhost{
  width:92px;
  padding:10px 0;
  font-size:14px;
}


/* === Share Card v4 Heart (kitch & clean) === */
.shareCardWrap{ width:720px; height:1280px; padding:44px; background: linear-gradient(180deg,#ffe9f0 0%, #fff6f9 60%, #ffe9f0 100%); }
.shareCard{
  width:100%; height:100%;
  border-radius:54px;
  background: rgba(255,255,255,.92);
  border:7px solid rgba(255,180,195,.85);
  box-shadow: 0 28px 70px rgba(201,24,74,.14);
  padding:48px 44px 44px;
  position:relative;
  overflow:hidden;
}
.shareFrame{
  position:absolute; inset:16px;
  border-radius:44px;
  border:5px solid rgba(255,204,213,.55);
  pointer-events:none;
}
.shareSpark{
  position:absolute;
  width:16px;height:16px;
  border-radius:4px;
  background: rgba(255,77,109,.18);
  transform: rotate(45deg);
  opacity:.8;
}
.shareSpark.s1{ left:54px; top:120px; width:14px; height:14px; opacity:.55;}
.shareSpark.s2{ left:88px; top:170px; width:10px; height:10px; opacity:.45;}
.shareSpark.s3{ right:70px; top:130px; width:14px; height:14px; opacity:.55;}
.shareSpark.s4{ right:104px; top:190px; width:10px; height:10px; opacity:.45;}

.shareHeart{
  width:100%;
  height:240px;
  background: #fff;
  border-radius: 120px;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  box-shadow: 0 22px 46px rgba(201,24,74,.10);
  border:5px dashed rgba(255,180,195,.65);
}
.shareHeart:before{
  content:"";
  position:absolute;
  width:100%;
  height:100%;
  inset:0;
  border-radius:120px;
  background: radial-gradient(circle at 30% 30%, rgba(255,179,193,.18), rgba(255,179,193,0) 60%);
  pointer-events:none;
}
.shareTitle{
  font-size:68px;
  font-weight:1000;
  color:#c9184a;
  letter-spacing:-1px;
  line-height:1.05;
  text-align:center;
}

.shareDateBadge{
  position:absolute;
  right:40px;
  top:240px;
  transform: translateY(-30px);
  background:#fff0f3;
  border:4px solid rgba(255,180,195,.75);
  border-radius:26px;
  padding:14px 18px;
  font-weight:1000;
  color:#d6336c;
  font-size:22px;
  box-shadow:0 18px 34px rgba(201,24,74,.12);
}

.shareGrid{
  margin-top:34px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:18px;
}
.sharePanel{
  background:#fff8f9;
  border:4px solid rgba(255,204,213,.75);
  border-radius:34px;
  padding:22px;
  min-height: 420px;
}
.shareLabel{ font-size:22px; font-weight:1000; color:#d6336c; margin-bottom:14px; display:flex;
  align-items:center;
  justify-content:center;
  ex; align-items:center; gap:10px; }
.shareText{ font-size:30px; font-weight:1000; color:#333; line-height:1.25; white-space:pre-wrap; word-break:keep-all; }
.sharePanel.memo{ grid-column: 1 / -1; min-height: 470px; }


/* === BottomBar NoWrap v8 === */
.archiveBottomBar{
  padding: 10px 10px calc(10px + env(safe-area-inset-bottom)) !important;
}
.archiveBottomBtn{
  height: 52px !important;
  padding: 10px 8px !important;
  font-size: 12px !important;
  line-height: 1 !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  letter-spacing: -0.2px !important;
}
#archiveImportBtn{ font-size:12px !important; }
#archivePinBtn{ font-size:12px !important; }
#archiveDeleteSelected{ font-size:12px !important; }


/* === Share Card v8 Clean (kitch, stable layout) === */
.shareCardWrap{
  width:720px; height:1280px;
  padding:44px;
  background: linear-gradient(180deg,#ffe9f0 0%, #fff6f9 60%, #ffe9f0 100%);
}
.shareCard{
  width:100%; height:100%;
  border-radius:54px;
  background: rgba(255,255,255,.92);
  border:7px solid rgba(255,180,195,.85);
  box-shadow: 0 28px 70px rgba(201,24,74,.14);
  padding:40px 40px 40px;
  position:relative;
  overflow:hidden;
}
.shareFrame{
  position:absolute; inset:16px;
  border-radius:44px;
  border:5px solid rgba(255,204,213,.55);
  pointer-events:none;
}
.shareHeart{
  width:100%;
  height:240px;
  background:#fff;
  border-radius:120px;
  border:5px dashed rgba(255,180,195,.65);
  box-shadow: 0 22px 46px rgba(201,24,74,.10);
  display:flex;
  align-items:center;
  justify-content:center;
  ex;
  align-items:center;
  justify-content:center;
  padding:0 30px;
  position:relative;
}
.shareTitle{
  font-size:64px;
  font-weight:1000;
  color:#c9184a;
  letter-spacing:-1px;
  line-height:1.05;
  text-align:center;
  max-width:100%;
  word-break:keep-all;
}
.shareDateBadge{
  position:absolute;
  right:22px;
  top:214px; /* sits on heart edge */
  transform: translateY(-50%);
  background:#fff0f3;
  border:4px solid rgba(255,180,195,.75);
  border-radius:26px;
  padding:12px 16px;
  font-weight:1000;
  color:#d6336c;
  font-size:20px;
  box-shadow:0 18px 34px rgba(201,24,74,.12);
  max-width: 420px;
  white-space: nowrap;
}
.shareGrid{
  margin-top:28px;
  display:grid;
  grid-template-columns: 1fr;
  gap:18px;
}
.sharePanel{
  background:#fff8f9;
  border:4px solid rgba(255,204,213,.75);
  border-radius:34px;
  padding:22px;
}
.sharePanel.places{ min-height: 260px; }
.sharePanel.memo{ min-height: 520px; }
.shareLabel{ font-size:22px; font-weight:1000; color:#d6336c; margin-bottom:14px; display:flex;
  align-items:center;
  justify-content:center;
  ex; align-items:center; gap:10px; }
.shareText{ font-size:32px; font-weight:1000; color:#333; line-height:1.25; white-space:pre-wrap; word-break:keep-all; }


/* === Share Card v9 FIX === */
.shareCardV9{
  width:100%; height:100%;
  border-radius:54px !important;
  background: rgba(255,255,255,.92) !important;
  border:7px solid rgba(255,180,195,.85) !important;
  box-shadow: 0 28px 70px rgba(201,24,74,.14) !important;
  padding:40px 40px 40px !important;
  position:relative !important;
  overflow:hidden !important;
}
.shareHeartV9{
  width:100% !important;
  height:240px !important;
  background:#fff !important;
  border-radius:120px !important;
  border:5px dashed rgba(255,180,195,.65) !important;
  box-shadow: 0 22px 46px rgba(201,24,74,.10) !important;
  display:flex;
  align-items:center;
  justify-content:center;
  ex !important;
  align-items:center !important;
  justify-content:center !important;
  padding:0 30px !important;
  position:relative !important;
}
.shareGridV9{
  margin-top:28px !important;
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:18px !important;
}
.sharePanelV9{ background:#fff8f9 !important; border:4px solid rgba(255,204,213,.75) !important; border-radius:34px !important; padding:22px !important; }
.sharePanelV9.places{ min-height: 260px !important; }
.sharePanelV9.memo{ min-height: 520px !important; }
.shareDateBadge{
  right:22px !important;
  top:214px !important;
  transform: translateY(-50%) !important;
  z-index:3 !important;
}
.shareTitle{ z-index:2 !important; }



/* === FIX: Archive buttons always clickable (edit/copy/share) === */
.archiveItem{ position:relative !important; }
.archiveItem input.archChk{ position:relative !important; z-index:2 !important; }
.archiveActions{ position:relative !important; z-index:5 !important; pointer-events:auto !important; }
.archiveActions button{ pointer-events:auto !important; }


/* === Share Frame (PNG) for Instagram Story 1080x1920 === */
.memFrameCapture{
  width:1080px;
  height:1920px;
  position:relative;
  overflow:hidden;
  background:#ffd7e2; /* fallback */
  font-family:-apple-system,system-ui,sans-serif;
}
.memFrameWrap{
  width:1080px;
  height:1920px;
  padding:0 !important;
  margin:0 !important;
  background:transparent !important;
  overflow:hidden !important;
}
.memFrameImg{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
}
.memSlot{
  position:absolute;
  box-sizing:border-box;
  color:#c9184a;
  font-weight:1000;
  letter-spacing:-0.4px;
  text-align:center;
  white-space:pre-wrap;
  word-break:keep-all;
  line-height:1.12;
}
.memTitle{
  left:120px;
  top:352px;           /* ‚Üì Îçî ÏïÑÎûò */
  width:840px;
  height:300px;        /* ÌïòÌä∏ Ï§ëÏïô ÏòÅÏó≠ */
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:84px;
  text-align:center;
  padding:0 40px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.memDate{
  left:140px;
  top:828px;           /* ‚Üì Ï°∞Í∏à Îçî ÏïÑÎûò */
  width:800px;
  height:120px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:26px;
  text-align:center;
  padding:0 30px;
  color:#c9184a;
  font-weight:1000;
}
.memPlaces{
  left:120px;
  top:968px;           /* ‚Üì ÏÇ¥Ïßù Îçî ÏïÑÎûò */
  width:840px;
  height:260px;
  font-size:32px;
  text-align:left;
  padding:44px 30px 22px;   /* ‚Üì ÌÖçÏä§Ìä∏Î•º Ï°∞Í∏à Îçî ÏïÑÎûò */
  color:#c9184a;
  font-weight:1000;
  line-height:1.25;
  white-space:pre-wrap;
  word-break:break-word;
  overflow:hidden;
  text-shadow:none;
}
.memMemo{
  left:120px;
  top:1310px;          /* ‚Üì Îçî ÏïÑÎûò */
  width:840px;
  height:640px;
  font-size:32px;
  text-align:left;
  padding:44px 30px 22px;   /* ‚Üì ÌÖçÏä§Ìä∏Î•º Ï°∞Í∏à Îçî ÏïÑÎûò */
  color:#c9184a;
  font-weight:1000;
  line-height:1.25;
  white-space:pre-wrap;
  word-break:break-word;
  overflow:hidden;
  text-shadow:none;
}


/* === Import overlay (share code) === */
#importOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:11800;}
#importOverlay.show{display:flex;
  align-items:center;
  justify-content:center;
  ex;}
#importBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.60);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);}
#importBox{position:relative;z-index:2;width:min(420px,92vw);background:#fff;border-radius:26px;padding:18px 18px 16px;border:4px solid #ffccd5;box-shadow:0 22px 46px rgba(255,77,109,.26);text-align:center;}
.importTitle{font-weight:1000;font-size:18px;color:#d6336c;margin:2px 0 8px;}
.importDesc{font-weight:900;font-size:12px;color:#777;margin:0 0 12px;line-height:1.35;}
.importField{width:100%;background:#fff8f9;border:3px solid #ffccd5;border-radius:20px;padding:12px 12px 14px;margin:10px 0;text-align:left;}
.importLabel{font-weight:1000;font-size:14px;color:#d6336c;text-align:center;margin-bottom:10px;}
.importInput,.importTextarea{width:100%;border:2px solid #ffd6df;border-radius:14px;padding:10px 10px;font-weight:900;font-size:14px;outline:none;box-sizing:border-box;text-align:center;}
.importTextarea{min-height:90px;resize:none;text-align:left;}
.importNotice{
  margin:8px 2px 0;
  font-size:12px;
  line-height:1.35;
  font-weight:900;
  color:#c94a4a;
  text-align:left;
}
.importActions{display:flex;
  align-items:center;
  justify-content:center;
  ex;gap:10px;margin-top:12px;justify-content:center;}
.importActions button{flex:1;}


/* === FIX17: ensure overlays accept pointer events on iOS === */
#archiveOverlay.show, #memoryOverlay.show, #pinOverlay.show, #importOverlay.show, #codeOverlay.show, #settingsOverlay.show, #audioOverlay.show{
  pointer-events:auto !important;
}
#archiveOverlay, #memoryOverlay, #pinOverlay, #importOverlay, #codeOverlay, #settingsOverlay, #audioOverlay{
  pointer-events:none;
}


/* === Archive: widen list box slightly + hide scrollbar === */
#archiveBox{ padding-left:10px !important; padding-right:10px !important; }
#archiveList{ scrollbar-width:none; -ms-overflow-style:none; }
#archiveList::-webkit-scrollbar{ width:0; height:0; display:none; }


/* === Archive List Box: no shadow (3D applies per item) === */
#archiveList{ box-shadow:none !important; background:transparent !important; }

/* === Ensure archive action buttons always clickable on iOS === */
.archiveActions{ position:relative; z-index:5; pointer-events:auto; }
.archiveBtnGhost{ position:relative; z-index:6; pointer-events:auto; }

/* === PATCH29: Archive overlay background match + wider list === */
#archiveBox{ background: var(--bg) !important; }
#archiveBackdrop{ background: rgba(255,240,243,.92) !important; }
#archiveList{ padding: 8px 2px !important; }

/* === PATCH29: Share Code overlay (per-archive, fixed code + copy button) === */
#codeOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:11950;}
#codeOverlay.show{display:flex;}
#codeBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.60);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);}
#codeBox{position:relative;z-index:2;width:min(440px,92vw);background:#fff;border-radius:26px;padding:18px 18px 16px;border:4px solid #ffccd5;box-shadow:0 22px 46px rgba(255,77,109,.26);text-align:center;}
.codeTitle{font-weight:1000;font-size:18px;color:#d6336c;margin:2px 0 8px;}
.codeDesc{font-weight:900;font-size:12px;color:#777;margin:0 0 12px;line-height:1.35;}
.codeField{width:100%;background:#fff8f9;border:3px solid #ffccd5;border-radius:20px;padding:12px 12px 14px;margin:10px 0;position:relative;}
.codeLabel{font-weight:1000;font-size:14px;color:#d6336c;text-align:center;margin-bottom:10px;}
.codeValue{
  width:100%;
  max-height:160px;
  overflow-y:auto;
  border:2px solid #ffd6df;
  border-radius:14px;
  padding:12px 12px;
  font-weight:900;
  font-size:12px;
  line-height:1.25;
  color:#333;
  text-align:left;
  white-space:pre-wrap;
  word-break:break-all;
  user-select:text;
  -webkit-user-select:text;
  -webkit-overflow-scrolling:touch;
}
.codeCopyBtn{
  position:absolute;
  right:10px;
  top:10px;
  width:44px;
  height:44px;
  border-radius:14px;
  border:3px solid #ffccd5;
  background:#fff;
  color:#d6336c;
  font-weight:1000;
  font-size:18px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow:0 10px 16px rgba(201,24,74,.12);
}
.codeCopyBtn:active{ transform:translateY(1px) scale(.99); }
.codeActions{display:flex;gap:10px;margin-top:12px;}
.codeActions button{flex:1;}


/* === FIX34: Archive 3-section background (pink/white/pink) === */
#archiveBox{ background: var(--bg) !important; }
.archiveHeader{
  background: var(--bg) !important;
  border-bottom: 1px solid rgba(255,204,213,.70) !important;
}
#archiveList{
  background:#fff !important;
  border:none !important;
  border-radius:0 !important;
  margin-top:0 !important;
  box-shadow:none !important;
  padding: 12px 10px !important;
}
.archiveBottomBar{
  background: var(--bg) !important;
  border-top: 1px solid rgba(255,204,213,.70) !important;
  border-radius:0 !important;
  margin:0 !important;
}


/* === FIXED36: Archive background (pink / white / pink) + middle full-width === */
#archiveBox{ background: var(--bg) !important; padding: 0 !important; }
.archiveHeader{ background: var(--bg) !important; border-bottom: 2px solid rgba(255,61,102,.55) !important; padding: 12px 0 10px !important; }
#archiveList{
  background: #fff !important;
  border: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  width: 100vw !important;
  margin-left: calc(50% - 50vw) !important;
  margin-right: calc(50% - 50vw) !important;
  padding: 14px 14px 18px !important;
}
.archiveBottomBar{
  background: var(--bg) !important;
  border-top: 2px solid rgba(255,61,102,.55) !important;
  width: 100% !important;
  margin: 0 !important;
  border-radius: 0 !important;
  padding: 12px 12px calc(12px + env(safe-area-inset-bottom)) !important;
}


/* === FIX: Copy button always on top, solid background === */
.copyBtn, .codeCopyBtn, #codeCopyBtn {
  position: absolute !important;
  z-index: 10 !important;
  background: #ffffff !important;
  border: 2px solid #ffccd5 !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.12) !important;
}

</style>
</head>

<body>

<!-- Splash -->
<div id="startOverlay" aria-label="ÏãúÏûë ÌôîÎ©¥" role="button" tabindex="0">
  <div class="splashStage">
    <img id="splashImg" src="./splash_bg.jpg" alt="Ï†ú‚ù§Ô∏èÏÜ° ÎûúÎç§Îç∞Ïù¥Ìä∏ ÏãúÏûë ÌôîÎ©¥" />
    <div id="splashTitleWrap"><img id="splashTitle" src="./splash_title.PNG" alt="ÎëêÍ∑ºÎëêÍ∑º ÎûúÎç§Îç∞Ïù¥Ìä∏ ÌÉÄÏù¥ÌãÄ" /></div>
    <div id="citySparkles" aria-hidden="true"></div>
    <div class="splashTwinkles" aria-hidden="true">
      <i></i><i></i><i></i><i></i><i></i>
    </div>
    <div id="tapHintWrap"><div id="tapHint">ÌôîÎ©¥ÏùÑ ÌÑ∞ÏπòÌï¥Ï£ºÏÑ∏Ïöî</div></div>
    <div id="splashLoading" aria-live="polite"><span class="blink">Î°úÎî©Ï§ë</span><span class="dots"></span></div>
  </div>
</div>

<!-- Game UI -->
<div class="wrap">
  <div class="card">
    <h1 class="title">Ï†ú‚Ä¢ÏÜ° ÎûúÎç§Îç∞Ïù¥Ìä∏</h1>
    <div class="row">
      <input id="startInput" inputmode="text" autocomplete="off" spellcheck="false" placeholder="Ï∂úÎ∞úÏó≠ (Ïòà: ÌòúÌôî)" />
      <button id="goBtn">Ï∂úÎ∞ú</button>
    </div>

    <div class="stageWrap">
      <div class="viewport" id="viewport">
        <div id="panTopPad" aria-hidden="true"></div>
        <svg id="map">
          <g id="mapShift">
          <g id="gLines"></g>
          <g id="gDots"></g>

          <!-- HUD -->
          <g id="hudG">
            <rect id="hudRect" x="-120" y="-40" rx="16" ry="16" width="240" height="74"></rect>
            <text id="hudLine1" x="0" y="-12" text-anchor="middle" dominant-baseline="middle" font-size="14" font-weight="900" fill="#c9184a">-</text>
            <text id="hudLine2" x="0" y="12" text-anchor="middle" dominant-baseline="middle" font-size="12" font-weight="900" fill="#ff4d6d">-</text>
          </g>

          <!-- Token -->
          <g id="token" class="token">
            <!-- head + body (refined) -->
            <circle cx="0" cy="-14" r="9"></circle>
            <rect x="-10" y="-2" width="20" height="24" rx="6" ry="6"></rect>
          </g>
                  </g>
        </svg>
        <div id="panBottomPad" aria-hidden="true"></div>
      </div>
      <canvas id="confetti"></canvas>

      <!-- Settings button (bottom-right) -->
      <button id="archiveBtn" class="miniBtn archiveBtn" type="button" aria-label="Ï∂îÏñµ Î≥¥Í¥ÄÌï®">üìö</button>
      <button id="audioBtn" class="miniBtn soundBtn" type="button" aria-label="ÏùåÌñ• ÏÑ§Ï†ï">üîä</button>
      <button id="settingsBtn" class="miniBtn" type="button" aria-label="Ïù¥Îèô Ï†ïÍ±∞Ïû• ÏÑ§Ï†ï">‚öôÔ∏è</button>
    </div>
  </div>
</div>

<!-- Settings overlay -->
<div id="settingsOverlay" aria-hidden="true">
  <div id="settingsBackdrop"></div>
  <div id="settingsBox" role="dialog" aria-modal="true" aria-label="ÌôòÍ≤ΩÏÑ§Ï†ï">
    <div class="settingsTitle">ÌôòÍ≤ΩÏÑ§Ï†ï</div>

    <!-- Combined: min/max stops in one box -->
    <div class="settingsRow settingsRowCombined" id="stopsRow">
      <div class="stopsGrid">
        <div class="stopItem">
          <div class="settingsLabel">ÏµúÏÜå Ïù¥ÎèôÏó≠</div>
          <div class="stepper">
            <button type="button" class="stepBtn" data-step="min" data-delta="-1" aria-label="ÏµúÏÜå Í∞êÏÜå">‚ñæ</button>
            <input id="minStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" />
            <button type="button" class="stepBtn" data-step="min" data-delta="1" aria-label="ÏµúÏÜå Ï¶ùÍ∞Ä">‚ñ¥</button>
          </div>
        </div>
        <div class="stopItem">
          <div class="settingsLabel">ÏµúÎåÄ Ïù¥ÎèôÏó≠</div>
          <div class="stepper">
            <button type="button" class="stepBtn" data-step="max" data-delta="-1" aria-label="ÏµúÎåÄ Í∞êÏÜå">‚ñæ</button>
            <input id="maxStopsInput" class="numInput" type="number" inputmode="numeric" min="1" max="99" value="25" />
            <button type="button" class="stepBtn" data-step="max" data-delta="1" aria-label="ÏµúÎåÄ Ï¶ùÍ∞Ä">‚ñ¥</button>
          </div>
        </div>
      </div>
    </div>

    <div class="settingsRow settingsRowStrong" id="trueRandomRow">
      <div class="settingsLabel hotPink">Ï∞êÎûúÎç§ Î™®Îìú</div>
      <div class="stepper" style="gap:10px;">
        <div class="toggleSwitch" aria-label="Ï∞êÎûúÎç§ Î™®Îìú ÌÜ†Í∏Ä">
          <input id="trueRandomToggle" type="checkbox" />
          <span class="toggleTrack" id="trueRandomTrack" role="switch" tabindex="0" aria-checked="false" aria-label="Ï∞êÎûúÎç§ Î™®Îìú">
            <span class="toggleText" aria-hidden="true"><span class="off">OFF</span><span class="on">ON</span></span>
            <span class="toggleKnob" aria-hidden="true"></span>
          </span>
        </div>
      </div>
    </div>
<div class="settingsActions">
      <button type="button" id="settingsCancel" class="ghostBtn">Ï∑®ÏÜå</button>
      <button type="button" id="settingsOk" class="solidBtn">ÌôïÏù∏</button>
    </div>
  </div>
</div>


<!-- Audio overlay -->
<div id="audioOverlay" aria-hidden="true">
  <div id="audioBackdrop"></div>
  <div id="audioBox" role="dialog" aria-modal="true" aria-label="ÏùåÌñ• Ï°∞Ï†à">
    <div class="audioTitle">ÏùåÌñ• Ï°∞Ï†à</div>

    <div class="audioTopActions">
      <button type="button" id="audioMuteBtn" class="audioRoundBtn" aria-label="ÏùåÏÜåÍ±∞">üîá</button>
      <button type="button" id="audioResetBtn" class="audioRoundBtn" aria-label="Ï¥àÍ∏∞Ìôî">‚Ü∫</button>
    </div>

    <div class="audioCard">
      <div class="audioLabel">Ïù¥Îèô</div>
      <div class="audioRow">
        <span class="audioHint">üîà</span>
        <input id="volMoveRange" class="audioRange" type="range" min="0" max="1200" value="600" step="1" />
        <span class="audioHint">üîä</span>
      </div>
    </div>

    <div class="audioCard">
      <div class="audioLabel">ÌôòÏäπ</div>
      <div class="audioRow">
        <span class="audioHint">üîà</span>
        <input id="volTransferRange" class="audioRange" type="range" min="0" max="5000" value="2500" step="1" />
        <span class="audioHint">üîä</span>
      </div>
    </div>

    <div class="audioCard">
      <div class="audioLabel">ÎèÑÏ∞©</div>
      <div class="audioRow">
        <span class="audioHint">üîà</span>
        <input id="volArriveRange" class="audioRange" type="range" min="0" max="800" value="400" step="1" />
        <span class="audioHint">üîä</span>
      </div>
    </div>

    <div class="audioCard">
      <div class="audioLabel">Î≤ÑÌäº</div>
      <div class="audioRow">
        <span class="audioHint">üîà</span>
        <input id="volUiRange" class="audioRange" type="range" min="0" max="5000" value="2500" step="1" />
        <span class="audioHint">üîä</span>
      </div>
    </div>

    <div class="audioCloseRow">
      <button type="button" id="audioCloseBtn" class="audioCloseBtn">Îã´Í∏∞</button>
    </div>
  </div>
</div>
<!-- Archive overlay (full screen) -->
<div id="archiveOverlay" aria-hidden="true">
  <div id="archiveBackdrop"></div>
  <div id="archiveBox" role="dialog" aria-modal="true" aria-label="Ï∂îÏñµ Î≥¥Í¥ÄÌï®">
    <div class="archiveHeader">
      <div class="archiveTitle">Ï∂îÏñµ Î≥¥Í¥ÄÌï®</div>
      <button type="button" id="archiveClose" class="archiveCloseBtn" aria-label="Îã´Í∏∞">‚úï</button>
    </div>

    <div id="archiveList"></div>

    <div class="archiveBottomBar" aria-label="Î≥¥Í¥ÄÌï® Î©îÎâ¥">
      <button type="button" id="archiveImportBtn" class="archiveBottomBtn">ÏΩîÎìú Í∞ÄÏ†∏Ïò§Í∏∞</button>
      <button type="button" id="archivePinBtn" class="archiveBottomBtn">ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω</button>
      <button type="button" id="archiveDeleteSelected" class="archiveBottomBtn">ÏÑ†ÌÉù ÏÇ≠Ï†ú</button>
    </div>
  </div>
</div>

<!-- Memory overlay (record) -->
<div id="memoryOverlay" aria-hidden="true">
  <div id="memoryBackdrop"></div>
  <div id="memoryBox" role="dialog" aria-modal="true" aria-label="Ï∂îÏñµ Í∏∞Î°ù">
    <div class="memoryTitle">Ï∂îÏñµ Í∏∞Î°ù</div>
    <div id="memoryWhen" class="memoryMeta">-</div>

    <div class="memoryField">
      <div class="memoryLabel">Î∞©Î¨∏Ìïú Í≥≥</div>
      <input id="memoryPlaces" class="memoryInput" type="text" placeholder="" maxlength="120" />
    </div>

    <div class="memoryField">
      <div class="memoryLabel">Î©îÎ™®</div>
      <textarea id="memoryMemo" class="memoryTextarea" maxlength="240"></textarea>
    </div>

    <div class="memoryActions">
      <button type="button" id="memoryCancel" class="archiveBtnGhost">Ï∑®ÏÜå</button>
      <button type="button" id="memorySave" class="archiveBtnSolid">Ï†ÄÏû•</button>
    </div>
  </div>
</div>



<!-- Import overlay (share code) -->
<div id="importOverlay" aria-hidden="true">
  <div id="importBackdrop"></div>
  <div id="importBox" role="dialog" aria-modal="true" aria-label="ÏΩîÎìú Í∞ÄÏ†∏Ïò§Í∏∞">
    <div class="importTitle">ÏΩîÎìú Í∞ÄÏ†∏Ïò§Í∏∞</div>
    <div class="importDesc">Í∞ÄÏ†∏Ïò¨ Ï∂îÏñµÏùò ÏΩîÎìúÏôÄ ÏΩîÎìú ÏÜåÏú†ÏûêÏùò ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.</div>
    <div class="importField">
      <div class="importLabel">Í≥µÏú†ÏΩîÎìú</div>
      <textarea id="importCode" class="importTextarea" placeholder=""></textarea>
    </div>
    <div class="importField">
      <div class="importLabel">6ÏûêÎ¶¨ ÎπÑÎ∞ÄÎ≤àÌò∏</div>
      <input id="importPin" class="importInput" inputmode="numeric" maxlength="6" placeholder="Ïà´Ïûê 6ÏûêÎ¶¨" />
    </div>
    <p class="importNotice">‚ö†Ô∏è ÎÇ¥Ïö©Ïù¥ÎÇò ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω Ïãú, ÏÉà Í≥µÏú†ÏΩîÎìúÍ∞Ä ÏÉùÏÑ±ÎêòÎØÄÎ°ú, ÏµúÏã†Ïùò Í≥µÏú†ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.</p>
    <div class="importActions">
      <button type="button" id="importCancel" class="archiveBtnGhost">Ï∑®ÏÜå</button>
      <button type="button" id="importOk" class="archiveBtnSolid">ÌôïÏù∏</button>
    </div>
  </div>
</div>


<!-- Share Code overlay (single-line code + copy) -->
<div id="codeOverlay" aria-hidden="true">
  <div id="codeBackdrop"></div>
  <div id="codeBox" role="dialog" aria-modal="true" aria-label="Í≥µÏú†ÏΩîÎìú">
    <div class="codeTitle">Í≥µÏú†ÏΩîÎìú</div>
    <div class="codeDesc">ÏΩîÎìú Ïö∞Ï∏° ÏÉÅÎã®Ïùò Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥ ÏΩîÎìúÍ∞Ä Î≥µÏÇ¨Îê©ÎãàÎã§.</div>

    <div class="codeField">
      <button type="button" id="codeCopyBtn" class="codeCopyBtn" aria-label="Î≥µÏÇ¨ÌïòÍ∏∞">‚ßâ</button>
      <div class="codeLabel">ÏΩîÎìú</div>
      <div id="codeValue" class="codeValue">-</div>
    </div>

    <div class="codeActions">
      <button type="button" id="codeCloseBtn" class="archiveBtnGhost">Îã´Í∏∞</button>
      <button type="button" id="codeOkBtn" class="archiveBtnSolid">ÌôïÏù∏</button>
    </div>
  </div>
</div>


<!-- Result overlay -->
<div id="resultOverlay">
  <div id="resultBackdrop"></div>
  <div id="resultBox">
    <canvas id="resultCanvas"></canvas>
    <div id="resultContent">
      <div style="font-size:13px;font-weight:900;color:#777;">ÏµúÏ¢Ö ÎèÑÏ∞©</div>
      <div id="resultStation" style="margin-top:6px;font-size:26px;font-weight:900;color:#d6336c;"></div>
      <div id="resultCount" style="margin-top:10px;font-size:15px;font-weight:900;color:#ff4d6d;"></div>
      <button id="searchBtn" style="margin-top:12px;padding:10px 16px;border-radius:999px;border:none;background:#fff0f3;color:#d6336c;font-weight:900;font-size:14px;cursor:pointer;border:2px solid #ffccd5;">Îç∞Ïù¥Ìä∏ÏΩîÏä§ ÏïåÏïÑÎ≥¥Í∏∞üîç</button>
      <button id="memoryBtnResult" style="margin-top:10px;padding:10px 16px;border-radius:999px;border:none;background:#fff0f3;color:#d6336c;font-weight:900;font-size:14px;cursor:pointer;border:2px solid #ffccd5;">Ï∂îÏñµ Í∏∞Î°ùÌïòÍ∏∞üìì</button>
      <button id="closeBtn" style="margin-top:14px;padding:10px 16px;border-radius:999px;border:none;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:white;font-weight:900;font-size:14px;cursor:pointer;">ÌôïÏù∏ ‚ù§Ô∏è</button>
    </div>
  </div>
</div>

<div id="err"></div>


  <audio id="sfxTransfer" src="" preload="auto"></audio>
<!-- PIN overlay (4-digit) -->
<div id="pinOverlay" aria-hidden="true">
  <div id="pinBackdrop"></div>
  <div id="pinBox" role="dialog" aria-modal="true" aria-label="ÎπÑÎ∞ÄÎ≤àÌò∏">
    <div id="pinTitle" class="pinTitle">ÎπÑÎ∞ÄÎ≤àÌò∏</div>
    <div id="pinSub" class="pinSub">-</div>
    <div class="pinDots" aria-hidden="true">
      <div class="pinDot" data-pin-dot="0"></div>
      <div class="pinDot" data-pin-dot="1"></div>
      <div class="pinDot" data-pin-dot="2"></div>
      <div class="pinDot" data-pin-dot="3"></div>
      <div class="pinDot" data-pin-dot="4"></div>
      <div class="pinDot" data-pin-dot="5"></div>
    </div>
    <div class="pinPad" id="pinPad">
      <button type="button" class="pinKey" data-k="1">1</button>
      <button type="button" class="pinKey" data-k="2">2</button>
      <button type="button" class="pinKey" data-k="3">3</button>
      <button type="button" class="pinKey" data-k="4">4</button>
      <button type="button" class="pinKey" data-k="5">5</button>
      <button type="button" class="pinKey" data-k="6">6</button>
      <button type="button" class="pinKey" data-k="7">7</button>
      <button type="button" class="pinKey" data-k="8">8</button>
      <button type="button" class="pinKey" data-k="9">9</button>
      <button type="button" class="pinKey muted" data-k="c">Ï∑®ÏÜå</button>
      <button type="button" class="pinKey" data-k="0">0</button>
      <button type="button" class="pinKey muted" data-k="b">‚å´</button>
    </div>
    <div class="pinActions">
      <button type="button" id="pinAltCancel" class="archiveBtnGhost">Îã´Í∏∞</button>
      <button type="button" id="pinAltOk" class="archiveBtnSolid">ÌôïÏù∏</button>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
// SAFE GLOBAL
// === CLICK SFX RESET (FIXED49) ===
// - Ïù¥ÎèôÏùå(ÌÜ†ÌÅ∞ Ïù¥Îèô)ÏùÄ Í∏∞Ï°¥ playMoveTick Í∑∏ÎåÄÎ°ú
// - Î≤ÑÌäº ÌÅ¥Î¶≠ÏùåÏùÄ "Ïù¥ÎèôÏùåÍ≥º ÎèôÏùºÌïú WebAudio Î∞©Ïãù"ÏúºÎ°ú Î≥ÑÎèÑ Íµ¨ÌòÑ(Î≥ºÎ•®ÎèÑ Î≥ÑÎèÑ Ïä¨ÎùºÏù¥ÎçîÎ°ú Ï†úÏñ¥)
// - Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏóêÏÑú ÎàÑÏ†ÅÎêú Ï†ÑÏó≠ Ï∫°Ï≤ò Î¶¨Ïä§ÎÑà/Ï§ëÎ≥µ Î°úÏßÅÏùÄ Ï†ÑÎ∂Ä Ï†úÍ±∞ÌïòÍ≥†, Î≤ÑÌäº/ÌÇ§Ìå®ÎìúÏóêÎßå 1Ìöå ÏúÑÏûÑÏúºÎ°ú Î∂ôÏûÑ

function __safeClamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

// Button click SFX (WebAudio) - lightweight, repeatable, no external wav




function playUiClickSfx(){
  // prevent double fire (touch + click)
  const _nowTs = performance.now();
  if(window.__lastUiClickTs && _nowTs - window.__lastUiClickTs < 120) return;
  window.__lastUiClickTs = _nowTs;

  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC && !audioCtx) audioCtx = new AC();
    if(!audioCtx) return;

    if(audioCtx.state === 'suspended'){
      try{ audioCtx.resume().catch(()=>{}); }catch(e){}
    }

    if(!sfxGain){
      sfxGain = audioCtx.createGain();
      sfxGain.gain.value = 1.25;
      sfxGain.connect(audioCtx.destination);
    }

    let muted=false, movePct=750, uiPct=2000;
    try{ muted=(localStorage.getItem('jesong_vol_muted')||'0')==='1'; }catch(e){}
    try{ movePct=parseInt(localStorage.getItem('jesong_vol_move_pct')||'750',10); }catch(e){}
    try{ uiPct=parseInt(localStorage.getItem('jesong_vol_ui_pct')||'2000',10); }catch(e){}
    if(!Number.isFinite(movePct)) movePct=1000;
    if(!Number.isFinite(uiPct)) uiPct=500;

    const uiNorm = Math.max(0, Math.min(1, ((muted?0:(movePct/100))*(uiPct/5000))/10));
    if(uiNorm <= 0.001) return;

    const now = audioCtx.currentTime;

    // === "Tok." click ===
    // Slightly lower pitch, softer edge, tiny body.
    const o = audioCtx.createOscillator();
    const f = audioCtx.createBiquadFilter();
    const g = audioCtx.createGain();

    o.type = 'triangle';
    o.frequency.setValueAtTime(900, now);

    f.type = 'lowpass';
    f.frequency.setValueAtTime(2200, now);
    f.Q.setValueAtTime(0.7, now);

    const finalVol = Math.max(0, Math.min(1, uiNorm * 0.18));
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(finalVol, now + 0.0025);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.055);

    o.connect(f).connect(g).connect(sfxGain);

    o.start(now);
    o.stop(now + 0.06);
  }catch(e){}
}






// Î≤ÑÌäº/ÌÇ§Ìå®Îìú ÌÅ¥Î¶≠ ÏÇ¨Ïö¥Îìú: Ï†ÑÏó≠ Ï∫°Ï≤ò 1ÌöåÎßå (Ï§ëÎ≥µ Î∞©ÏßÄ)
(function wireUiClickSfxOnce(){
  if(window.__uiClickSfxWired) return;
  window.__uiClickSfxWired = true;

  const shouldPlay = (el)=>{
    if(!el) return false;
    // Disabled buttons shouldn't click
    if(el.tagName === 'BUTTON' && el.disabled) return false;

    // Prevent overlap: range sliders have their own preview sounds
    if(el.tagName === 'INPUT'){
      const tp = String(el.getAttribute('type')||'').toLowerCase();
      if(tp === 'range') return false;
    }
    return true;
  }

  // Normalize external subway data to the app's internal legacy format: { lineName: [stationName...] }
  function __normalizeSubwayData(obj){
    // v2 -> legacy
    if(obj && obj.schemaVersion === 2 && Array.isArray(obj.lines) && obj.stations){
      const legacy = {};
      for(const line of obj.lines){
        if(!line || !line.name || !Array.isArray(line.stations)) continue;
        const arr = [];
        for(const sid of line.stations){
          const st = obj.stations[sid];
          if(st && typeof st.name === 'string') arr.push(st.name);
        }
        if(arr.length) legacy[line.name] = arr;
      }
      return legacy;
    }
    // legacy passthrough
    return obj;
  }
;

  const fire = (e)=>{
      try{ __unlockAudioOnce(); }catch(_e){}
      const t = e && e.target ? e.target : null;
      if(!t || !t.closest) return;

      // Any interactive UI element should click-sfx (NEW RULE A)
      const el =
        t.closest('button, .pinKey, .toggleTrack, [role="switch"], input, textarea, select, a');

      if(!el) return;
      if(!shouldPlay(el)) return;

      // Avoid spamming: only on pointerdown (this listener), one-shot per gesture
      try{ playUiClickSfx(); }catch(_e){}
  };

  // pointerdownÎßå ÏÇ¨Ïö©(Ï§ëÎ≥µ fire Î∞©ÏßÄ)
  document.addEventListener('pointerdown', fire, {capture:true, passive:true});
})();
window.__gameStarted = false;
  window.__paused = false;
  try{ sessionStorage.removeItem('jesong_bg'); }catch(e){}

let audioCtx = null;
let sfxGain = null; // GLOBAL shared SFX bus
let transferGain = null;
let transferSource = null;

  
// --- Transfer SFX: robust restart on iOS using AudioBuffer one-shots ---
let transferBuffer = null;
let transferOneShot = null;
let transferLoadStarted = false;

async function loadTransferBuffer(){
  try{
    if(transferLoadStarted) return;
    transferLoadStarted = true;
    if(!audioCtx) return;
    if(transferBuffer) return;
    const url = (typeof TRANSFER_SFX_URL !== 'undefined') ? TRANSFER_SFX_URL : 'transfer-loop.mp3';
    const res = await fetch(url, { cache: 'force-cache' });
    const arr = await res.arrayBuffer();
    // decodeAudioData returns a promise in modern browsers; in older it uses callbacks
    transferBuffer = await audioCtx.decodeAudioData(arr);
  }catch(e){
    // If decode fails, allow fallback to <audio> element
    transferBuffer = null;
  }
}
const TRANSFER_SFX_URL = new URL('transfer-loop.mp3', window.location.href).href;

function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

// Persistent settings keys
const LAST_STATION_KEY = "jesong_last_station";
const MIN_STOPS_KEY = "jesong_min_stops";
const MAX_STOPS_KEY = "jesong_max_stops";
const TRUE_RANDOM_KEY = "jesong_true_random";
const DEFAULT_FIRST_STATION = "ÏÑúÏö∏Ïó≠";


(function(){
  const errEl=document.getElementById('err');
  function showErr(msg){
    errEl.textContent=msg;
    errEl.style.display='block';
    clearTimeout(showErr.__t);
    showErr.__t=setTimeout(()=>{ errEl.style.display='none'; }, 3200);
  }
  // small toast helper (reuse the same bottom toast UI)
  window.__toast = function(msg){
    try{ showErr(String(msg||"")); }catch(e){}
  };
  window.addEventListener('error',(e)=>showErr('JS ÏóêÎü¨: '+(e.message||'unknown')));
  window.addEventListener('unhandledrejection',(e)=>showErr('Promise ÏóêÎü¨: '+(e.reason?.message||e.reason||'unknown')));  // Responsive stage sizing (game + splash)
  function setStageSize(){
    const vv=window.visualViewport;
    const vw=(vv&&vv.width)||window.innerWidth;
    const vh=(vv&&vv.height)||window.innerHeight;

    const card=document.querySelector('.card');
    const title=document.querySelector('.title');
    const row=document.querySelector('.row');

    const wrapPad = 28; // .wrap padding (14*2)
    const maxW = Math.min(520, (card ? (card.clientWidth - 28) : (vw - wrapPad)));

    const titleH = title ? title.getBoundingClientRect().height : 0;
    const rowH   = row   ? row.getBoundingClientRect().height   : 0;
    const chrome = 34;

    const availableH = vh - (titleH + rowH) - chrome - 18;
    const maxH = Math.min(980, Math.max(480, availableH));

    // Game: keep as-is (no scroll on web)
    const HEIGHT_FACTOR = 0.92;
    const w = Math.max(300, Math.min(maxW, maxW));
    const h = Math.max(420, Math.min(maxH, maxH * HEIGHT_FACTOR));    // Splash: ÏãúÏûëÌôîÎ©¥ÏùÄ Ïä§ÌîåÎûòÏãú Ïù¥ÎØ∏ÏßÄ ÎπÑÏú®(9:16)ÏùÑ Ïú†ÏßÄÌïòÎ©¥ÏÑú,
    // ÏõπÏóêÏÑú 'Ìè∞ ÌôîÎ©¥ 1ÎåÄ'Í∞Ä Ï§ëÏïôÏóê ÌÅ¨Í≤å Î≥¥Ïù¥ÎèÑÎ°ù(Ïä§ÌÅ¨Î°§ ÏóÜÏù¥) Í∞ÄÎä•Ìïú Ìïú ÌÅ¨Í≤å ÎßûÏ∂òÎã§.
    // ‚Äª Í≤åÏûÑ ÎπÑÏú®ÏùÑ Îî∞ÎùºÍ∞ÄÎ©¥ ÏãúÏûëÌôîÎ©¥Ïù¥ ÏòÜÏúºÎ°ú ÎÑìÏñ¥Ï†∏ÏÑú(=Í∞ÄÎ°ú Í≥ºÌôïÎåÄ) Ïó¨Í∏∞ÏÑúÎäî Ïù¥ÎØ∏ÏßÄ ÎπÑÏú®ÏùÑ Í≥†Ï†ïÌïúÎã§.
    const splashRatio = 16/9; // height / width (Ïä§ÌîåÎûòÏãú ÏõêÎ≥∏ ÎπÑÏú®)
    // Î™®Î∞îÏùºÏóêÏÑúÎäî ÎπàÍ≥µÍ∞Ñ ÏóÜÍ≤å 'Î≥¥Ïù¥Îäî ÌôîÎ©¥(visual viewport)'ÏùÑ ÍΩâ Ï±ÑÏö∞Í≤å Ìï®
    let splashW, splashH;

    // Mobile: fill the visible viewport (no blanks)
    if (vw <= 700){
      splashW = vw;
      splashH = vh;
    } else {
      // Desktop/web: keep centered 'phone screen' frame
      splashH = Math.min(vh, maxH);
      splashW = splashH / splashRatio;
      if (splashW > maxW){
        splashW = maxW;
        splashH = splashW * splashRatio;
      }
    }

    const root=document.documentElement;
    root.style.setProperty('--stageWpx', w.toFixed(2)+'px');
    root.style.setProperty('--stageHpx', h.toFixed(2)+'px');
    root.style.setProperty('--splashWpx', splashW.toFixed(2)+'px');
    root.style.setProperty('--splashHpx', splashH.toFixed(2)+'px');
  }

  function min(a,b,c){ return Math.min(a,b,c); }

  window.addEventListener('resize', setStageSize, {passive:true});
  window.addEventListener('orientationchange', setStageSize, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', setStageSize, {passive:true});
  setStageSize();

  // Splash: tap -> loading -> reveal
  const splash=document.getElementById('startOverlay');
  const hintWrap=document.getElementById('tapHintWrap');
  const loadingWrap=document.getElementById('splashLoading');
  let splashStarted=false;

  function removeSplash(){
    if(!splash) return;
    splash.classList.add('fadeOut');
    setTimeout(()=>{ try{ splash.remove(); } catch(e){ splash.style.display='none'; } }, 600);
  }

  function beginSplashLoading(){
    if(!splash || splashStarted) return;
    splashStarted=true;
    // prevent double taps during loading but keep initial tap working
    splash.style.pointerEvents='none';
    splash.classList.add('loading');
    if(hintWrap) hintWrap.style.display='none';
    if(loadingWrap) loadingWrap.classList.add('show');

    // Give some action: subtle tick every 240ms
    let ticks=0;
    const iv=setInterval(()=>{ ticks++; if(ticks>12) clearInterval(iv); else { try{ playMoveTick(); }catch(e){} } }, 240);

    setTimeout(()=>{
      try{ clearInterval(iv); }catch(e){}
      removeSplash();
      try{ window.__gameStarted = true; }catch(e){}
      // After splash disappears (fadeOut 600ms), force-center on the token.
      scheduleInitialCenter();
      setTimeout(()=>{ try{ snapCameraToTokenNow(); }catch(e){} }, 650);
    }, 3000);
  }

  if(splash){
    // iOS/Safari reliability: use pointerdown/touchstart (click can be delayed or swallowed)
    const onSplashGesture = (e)=>{
      // prevent accidental scrolling / selection during splash tap
      try{ e.preventDefault(); }catch(err){}
      try{ resumeAudioNow(); }catch(e){}
      beginSplashLoading();
    };
    splash.addEventListener('pointerdown', onSplashGesture, {passive:false});
    splash.addEventListener('touchstart', onSplashGesture, {passive:false});
    splash.addEventListener('click', (e)=>{ try{ e.preventDefault(); }catch(err){} try{ resumeAudioNow(); }catch(e){}
      beginSplashLoading(); }, {passive:false});
    splash.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') try{ resumeAudioNow(); }catch(e){}
      beginSplashLoading(); });
  }

  let DATA = {"1Ìò∏ÏÑ†":["Ïó∞Ï≤ú","Ï†ÑÍ≥°","Ï≤≠ÏÇ∞","ÏÜåÏöîÏÇ∞","ÎèôÎëêÏ≤ú","ÏßÄÌñâ","ÎçïÏ†ï","ÎçïÍ≥Ñ","ÏñëÏ£º","ÎÖπÏñë","Í∞ÄÎä•","ÏùòÏ†ïÎ∂Ä","ÌöåÎ£°","ÎßùÏõîÏÇ¨","ÎèÑÎ¥âÏÇ∞","ÎèÑÎ¥â","Î∞©Ìïô","Ï∞ΩÎèô","ÎÖπÏ≤ú","ÏõîÍ≥Ñ","Í¥ëÏö¥ÎåÄ","ÏÑùÍ≥Ñ","Ïã†Ïù¥Î¨∏","Ïô∏ÎåÄÏïû","ÌöåÍ∏∞","Ï≤≠ÎüâÎ¶¨","Ï†úÍ∏∞Îèô","Ïã†ÏÑ§Îèô","ÎèôÎ¨òÏïû","ÎèôÎåÄÎ¨∏","Ï¢ÖÎ°ú5Í∞Ä","Ï¢ÖÎ°ú3Í∞Ä","Ï¢ÖÍ∞Å","ÏãúÏ≤≠","ÏÑúÏö∏Ïó≠","ÎÇ®ÏòÅ","Ïö©ÏÇ∞","ÎÖ∏ÎüâÏßÑ","ÎåÄÎ∞©","Ïã†Í∏∏","ÏòÅÎì±Ìè¨","Ïã†ÎèÑÎ¶º","Íµ¨Î°ú","Íµ¨Ïùº","Í∞úÎ¥â","Ïò§Î•òÎèô","Ïò®Ïàò","Ïó≠Í≥°","ÏÜåÏÇ¨","Î∂ÄÏ≤ú","Ï§ëÎèô","ÏÉÅÎèô","ÏÜ°ÎÇ¥","Î∂ÄÍ∞ú","Î∂ÄÌèâ","Î∞±Ïö¥","ÎèôÏïî","Í∞ÑÏÑù","Ï£ºÏïà","ÎèÑÌôî","Ï†úÎ¨ºÌè¨","ÎèÑÏõê","ÎèôÏù∏Ï≤ú","Ïù∏Ï≤ú","Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ","ÎèÖÏÇ∞","Í∏àÏ≤úÍµ¨Ï≤≠","ÏÑùÏàò","Í¥ÄÏïÖ","ÏïàÏñë","Î™ÖÌïô","Í∏àÏ†ï","ÏÇ∞Î≥∏","ÏàòÎ¶¨ÏÇ∞","ÎåÄÏïºÎØ∏","Î∞òÏõî","ÏÉÅÎ°ùÏàò","ÌïúÎåÄÏïû","Ï§ëÏïô","Í≥†Ïûî","Ï¥àÏßÄ","ÏïàÏÇ∞","Ïã†Í∏∏Ïò®Ï≤ú","Ï†ïÏôï","Ïò§Ïù¥ÎèÑ","ÏùòÏôï","ÏÑ±Í∑†Í¥ÄÎåÄ","ÌôîÏÑú","ÏàòÏõê","ÏÑ∏Î•ò","Î≥ëÏ†ê","ÏÑ∏Îßà","Ïò§ÏÇ∞ÎåÄ","Ïò§ÏÇ∞","ÏßÑÏúÑ","ÏÜ°ÌÉÑ","ÏÑúÏ†ïÎ¶¨","ÌèâÌÉùÏßÄÏ†ú","ÌèâÌÉù","ÏÑ±Ìôò","ÏßÅÏÇ∞","ÎëêÏ†ï","Ï≤úÏïà","Î¥âÎ™Ö","ÏåçÏö©","ÏïÑÏÇ∞","ÌÉïÏ†ï","Î∞∞Î∞©","Ïò®ÏñëÏò®Ï≤ú","Ïã†Ï∞Ω"],"2Ìò∏ÏÑ†":["ÏãúÏ≤≠","ÏùÑÏßÄÎ°úÏûÖÍµ¨","ÏùÑÏßÄÎ°ú3Í∞Ä","ÏùÑÏßÄÎ°ú4Í∞Ä","ÎèôÎåÄÎ¨∏Ïó≠ÏÇ¨Î¨∏ÌôîÍ≥µÏõê","Ïã†Îãπ","ÏÉÅÏôïÏã≠Î¶¨","ÏôïÏã≠Î¶¨","ÌïúÏñëÎåÄ","ÎöùÏÑ¨","ÏÑ±Ïàò","Í±¥ÎåÄÏûÖÍµ¨","Íµ¨Ïùò","Í∞ïÎ≥Ä","Ïû†Ïã§ÎÇòÎ£®","Ïû†Ïã§","Ïû†Ïã§ÏÉàÎÇ¥","Ï¢ÖÌï©Ïö¥ÎèôÏû•","ÏÇºÏÑ±","ÏÑ†Î¶â","Ïó≠ÏÇº","Í∞ïÎÇ®","ÍµêÎåÄ","ÏÑúÏ¥à","Î∞©Î∞∞","ÏÇ¨Îãπ","ÎÇôÏÑ±ÎåÄ","ÏÑúÏö∏ÎåÄÏûÖÍµ¨","Î¥âÏ≤ú","Ïã†Î¶º","Ïã†ÎåÄÎ∞©","Íµ¨Î°úÎîîÏßÄÌÑ∏Îã®ÏßÄ","ÎåÄÎ¶º","Ïã†ÎèÑÎ¶º","Î¨∏Îûò","ÏòÅÎì±Ìè¨Íµ¨Ï≤≠","ÎãπÏÇ∞","Ìï©Ï†ï","ÌôçÎåÄÏûÖÍµ¨","Ïã†Ï¥å","Ïù¥ÎåÄ","ÏïÑÌòÑ","Ï∂©Ï†ïÎ°ú","Ïö©Îãµ","Ïã†Îãµ","Ïö©Îëê","Ïã†ÏÑ§Îèô","ÎèÑÎ¶ºÏ≤ú","ÏñëÏ≤úÍµ¨Ï≤≠","Ïã†Ï†ïÎÑ§Í±∞Î¶¨","ÍπåÏπòÏÇ∞"],"3Ìò∏ÏÑ†":["ÎåÄÌôî","Ï£ºÏóΩ","Ï†ïÎ∞úÏÇ∞","ÎßàÎëê","Î∞±ÏÑù","ÎåÄÍ≥°","ÌôîÏ†ï","ÏõêÎãπ","ÏõêÌù•","ÏÇºÏÜ°","ÏßÄÏ∂ï","Íµ¨ÌååÎ∞ú","Ïó∞Ïã†ÎÇ¥","Î∂àÍ¥ë","ÎÖπÎ≤à","ÌôçÏ†ú","Î¨¥ÏïÖÏû¨","ÎèÖÎ¶ΩÎ¨∏","Í≤ΩÎ≥µÍ∂Å","ÏïàÍµ≠","Ï¢ÖÎ°ú3Í∞Ä","ÏùÑÏßÄÎ°ú3Í∞Ä","Ï∂©Î¨¥Î°ú","ÎèôÎåÄÏûÖÍµ¨","ÏïΩÏàò","Í∏àÌò∏","Ïò•Ïàò","ÏïïÍµ¨Ï†ï","Ïã†ÏÇ¨","Ïû†Ïõê","Í≥†ÏÜçÌÑ∞ÎØ∏ÎÑê","ÍµêÎåÄ","ÎÇ®Î∂ÄÌÑ∞ÎØ∏ÎÑê","ÏñëÏû¨","Îß§Î¥â","ÎèÑÍ≥°","ÎåÄÏπò","ÌïôÏó¨Ïö∏","ÎåÄÏ≤≠","ÏùºÏõê","ÏàòÏÑú","Í∞ÄÎùΩÏãúÏû•","Í≤ΩÏ∞∞Î≥ëÏõê","Ïò§Í∏à"],"4Ìò∏ÏÑ†":["ÏßÑÏ†ë","Ïò§ÎÇ®","Î≥ÑÎÇ¥Î≥ÑÍ∞ÄÎûå","ÎãπÍ≥†Í∞ú","ÏÉÅÍ≥Ñ","ÎÖ∏Ïõê","Ï∞ΩÎèô","ÏåçÎ¨∏","ÏàòÏú†","ÎØ∏ÏïÑ","ÎØ∏ÏïÑÏÇ¨Í±∞Î¶¨","Í∏∏Ïùå","ÏÑ±Ïã†Ïó¨ÎåÄÏûÖÍµ¨","ÌïúÏÑ±ÎåÄÏûÖÍµ¨","ÌòúÌôî","ÎèôÎåÄÎ¨∏","ÎèôÎåÄÎ¨∏Ïó≠ÏÇ¨Î¨∏ÌôîÍ≥µÏõê","Ï∂©Î¨¥Î°ú","Î™ÖÎèô","ÌöåÌòÑ","ÏÑúÏö∏Ïó≠","ÏàôÎåÄÏûÖÍµ¨","ÏÇºÍ∞ÅÏßÄ","Ïã†Ïö©ÏÇ∞","Ïù¥Ï¥å","ÎèôÏûë","Ï¥ùÏã†ÎåÄÏûÖÍµ¨","ÏÇ¨Îãπ","ÎÇ®ÌÉúÎ†π","ÏÑ†Î∞îÏúÑ","Í≤ΩÎßàÍ≥µÏõê","ÎåÄÍ≥µÏõê","Í≥ºÏ≤ú","Ï†ïÎ∂ÄÍ≥ºÏ≤úÏ≤≠ÏÇ¨","Ïù∏ÎçïÏõê","ÌèâÏ¥å","Î≤îÍ≥Ñ","Í∏àÏ†ï","ÏÇ∞Î≥∏","ÏàòÎ¶¨ÏÇ∞","ÎåÄÏïºÎØ∏","Î∞òÏõî","ÏÉÅÎ°ùÏàò","ÌïúÎåÄÏïû","Ï§ëÏïô","Í≥†Ïûî","Ï¥àÏßÄ","ÏïàÏÇ∞","Ïã†Í∏∏Ïò®Ï≤ú","Ï†ïÏôï","Ïò§Ïù¥ÎèÑ"],"5Ìò∏ÏÑ†":["Î∞©Ìôî","Í∞úÌôîÏÇ∞","ÍπÄÌè¨Í≥µÌï≠","ÏÜ°Ï†ï","ÎßàÍ≥°","Î∞úÏÇ∞","Ïö∞Ïû•ÏÇ∞","ÌôîÍ≥°","ÍπåÏπòÏÇ∞","Ïã†Ï†ï","Î™©Îèô","Ïò§Î™©Íµê","ÏñëÌèâ","ÏòÅÎì±Ìè¨Íµ¨Ï≤≠","ÏòÅÎì±Ìè¨ÏãúÏû•","Ïã†Í∏∏","Ïó¨ÏùòÎèÑ","Ïó¨ÏùòÎÇòÎ£®","ÎßàÌè¨","Í≥µÎçï","Ïï†Ïò§Í∞ú","Ï∂©Ï†ïÎ°ú","ÏÑúÎåÄÎ¨∏","Í¥ëÌôîÎ¨∏","Ï¢ÖÎ°ú3Í∞Ä","ÏùÑÏßÄÎ°ú4Í∞Ä","ÎèôÎåÄÎ¨∏Ïó≠ÏÇ¨Î¨∏ÌôîÍ≥µÏõê","Ï≤≠Íµ¨","Ïã†Í∏àÌò∏","ÌñâÎãπ","ÏôïÏã≠Î¶¨","ÎßàÏû•","ÎãµÏã≠Î¶¨","Ïû•ÌïúÌèâ","Íµ∞Ïûê","ÏïÑÏ∞®ÏÇ∞","Í¥ëÎÇòÎ£®","Ï≤úÌò∏","Í∞ïÎèô","Í∏∏Îèô","ÍµΩÏùÄÎã§Î¶¨","Î™ÖÏùº","Í≥†Îçï","ÏÉÅÏùºÎèô","Í∞ïÏùº","ÎØ∏ÏÇ¨","ÌïòÎÇ®ÌíçÏÇ∞","ÌïòÎÇ®ÏãúÏ≤≠","ÌïòÎÇ®Í≤ÄÎã®ÏÇ∞","ÎëîÏ¥åÎèô","Ïò¨Î¶ºÌîΩÍ≥µÏõê","Î∞©Ïù¥","Ïò§Í∏à","Í∞úÎ°±","Í±∞Ïó¨","ÎßàÏ≤ú"],"6Ìò∏ÏÑ†":["ÏùëÏïî","Ïó≠Ï¥å","ÎèÖÎ∞îÏúÑ","Ïó∞Ïã†ÎÇ¥","Íµ¨ÏÇ∞","ÏÉàÏ†à","Ï¶ùÏÇ∞","ÎîîÏßÄÌÑ∏ÎØ∏ÎîîÏñ¥ÏãúÌã∞","ÏõîÎìúÏªµÍ≤ΩÍ∏∞Ïû•","ÎßàÌè¨Íµ¨Ï≤≠","ÎßùÏõê","Ìï©Ï†ï","ÏÉÅÏàò","Í¥ëÌù•Ï∞Ω","ÎåÄÌù•","Í≥µÎçï","Ìö®Ï∞ΩÍ≥µÏõêÏïû","ÏÇºÍ∞ÅÏßÄ","ÎÖπÏÇ¨Ìèâ","Ïù¥ÌÉúÏõê","ÌïúÍ∞ïÏßÑ","Î≤ÑÌã∞Í≥†Í∞ú","ÏïΩÏàò","Ï≤≠Íµ¨","Ïã†Îãπ","ÎèôÎ¨òÏïû","Ï∞ΩÏã†","Î≥¥Î¨∏","ÏïàÏïî","Í≥†Î†§ÎåÄ","ÏõîÍ≥°","ÏÉÅÏõîÍ≥°","ÎèåÍ≥∂Ïù¥","ÏÑùÍ≥Ñ","ÌÉúÎ¶âÏûÖÍµ¨","ÌôîÎûëÎåÄ","Î¥âÌôîÏÇ∞","Ïã†ÎÇ¥"],"7Ìò∏ÏÑ†":["Ïû•Ïïî","ÎèÑÎ¥âÏÇ∞","ÏàòÎùΩÏÇ∞","ÎßàÎì§","ÎÖ∏Ïõê","Ï§ëÍ≥Ñ","ÌïòÍ≥Ñ","Í≥µÎ¶â","ÌÉúÎ¶âÏûÖÍµ¨","Î®πÍ≥®","Ï§ëÌôî","ÏÉÅÎ¥â","Î©¥Î™©","ÏÇ¨Í∞ÄÏ†ï","Ïö©ÎßàÏÇ∞","Ï§ëÍ≥°","Íµ∞Ïûê","Ïñ¥Î¶∞Ïù¥ÎåÄÍ≥µÏõê","Í±¥ÎåÄÏûÖÍµ¨","ÎöùÏÑ¨Ïú†ÏõêÏßÄ","Ï≤≠Îã¥","Í∞ïÎÇ®Íµ¨Ï≤≠","ÌïôÎèô","ÎÖºÌòÑ","Î∞òÌè¨","Í≥†ÏÜçÌÑ∞ÎØ∏ÎÑê","ÎÇ¥Î∞©","Ïù¥Ïàò","ÎÇ®ÏÑ±","Ïà≠Ïã§ÎåÄÏûÖÍµ¨","ÏÉÅÎèÑ","Ïû•ÏäπÎ∞∞Í∏∞","Ïã†ÎåÄÎ∞©ÏÇºÍ±∞Î¶¨","Î≥¥ÎùºÎß§","Ïã†Ìíç","ÎåÄÎ¶º","ÎÇ®Íµ¨Î°ú","Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ","Ï≤†ÏÇ∞","Í¥ëÎ™ÖÏÇ¨Í±∞Î¶¨","Ï≤úÏôï","Ïò®Ïàò","ÍπåÏπòÏö∏","Î∂ÄÏ≤úÏ¢ÖÌï©Ïö¥ÎèôÏû•","Ï∂òÏùò","Ïã†Ï§ëÎèô","Î∂ÄÏ≤úÏãúÏ≤≠","ÏÉÅÎèô","ÏÇºÏÇ∞Ï≤¥Ïú°Í¥Ä","Íµ¥Ìè¨Ï≤ú","Î∂ÄÌèâÍµ¨Ï≤≠","ÏÉÅÍ∞à","ÏÇ∞Í≥°","ÏÑùÎÇ®"],"8Ìò∏ÏÑ†":["Î≥ÑÎÇ¥","Îã§ÏÇ∞","ÎèôÍµ¨Î¶â","Íµ¨Î¶¨","Ïû•ÏûêÌò∏ÏàòÍ≥µÏõê","ÏïîÏÇ¨Ïó≠ÏÇ¨Í≥µÏõê","ÏïîÏÇ¨","Ï≤úÌò∏","Í∞ïÎèôÍµ¨Ï≤≠","Î™ΩÏ¥åÌÜ†ÏÑ±","Ïû†Ïã§","ÏÑùÏ¥å","ÏÜ°Ìåå","Í∞ÄÎùΩÏãúÏû•","Î¨∏Ï†ï","Ïû•ÏßÄ","Î≥µÏ†ï","ÎÇ®ÏúÑÎ°Ä","ÏÇ∞ÏÑ±","ÎÇ®ÌïúÏÇ∞ÏÑ±ÏûÖÍµ¨","Îã®ÎåÄÏò§Í±∞Î¶¨","Ïã†Ìù•","Ïã†Ï¥å","ÏàòÏßÑ","Î™®ÎûÄ"],"9Ìò∏ÏÑ†":["Í∞úÌôî","ÍπÄÌè¨Í≥µÌï≠","Í≥µÌï≠ÏãúÏû•","Ïã†Î∞©Ìôî","ÎßàÍ≥°ÎÇòÎ£®","ÏñëÏ≤úÌñ•Íµê","Í∞ÄÏñë","Ï¶ùÎØ∏","Îì±Ï¥å","ÏóºÏ∞Ω","Ïã†Î™©Îèô","ÏÑ†Ïú†ÎèÑ","ÎãπÏÇ∞","Íµ≠ÌöåÏùòÏÇ¨Îãπ","Ïó¨ÏùòÎèÑ","ÏÉõÍ∞ï","ÎÖ∏ÎüâÏßÑ","ÎÖ∏Îì§","ÌùëÏÑù","ÎèôÏûë","Íµ¨Î∞òÌè¨","Ïã†Î∞òÌè¨","Í≥†ÏÜçÌÑ∞ÎØ∏ÎÑê","ÏÇ¨Ìèâ","Ïã†ÎÖºÌòÑ","Ïñ∏Ï£º","ÏÑ†Ï†ïÎ¶â","ÏÇºÏÑ±Ï§ëÏïô","Î¥âÏùÄÏÇ¨","Ï¢ÖÌï©Ïö¥ÎèôÏû•","ÏÇºÏ†Ñ","ÏÑùÏ¥åÍ≥†Î∂Ñ","ÏÑùÏ¥å","ÏÜ°ÌååÎÇòÎ£®","ÌïúÏÑ±Î∞±Ï†ú","Ïò¨Î¶ºÌîΩÍ≥µÏõê","ÎëîÏ¥åÏò§Î•ú","Ï§ëÏïôÎ≥¥ÌõàÎ≥ëÏõê"],"Í≤ΩÏùòÏ§ëÏïôÏÑ†":["Î¨∏ÏÇ∞","ÌååÏ£º","ÏõîÎ°±","Í∏àÏ¥å","Í∏àÎ¶â","Ïö¥Ï†ï","ÏïºÎãπ","ÌÉÑÌòÑ","ÏùºÏÇ∞","ÌíçÏÇ∞","Î∞±Îßà","Í≥°ÏÇ∞","ÎåÄÍ≥°","Îä•Í≥°","ÌñâÏã†","Í∞ïÎß§","ÌôîÏ†Ñ","ÏàòÏÉâ","ÎîîÏßÄÌÑ∏ÎØ∏ÎîîÏñ¥ÏãúÌã∞","Í∞ÄÏ¢å","ÌôçÎåÄÏûÖÍµ¨","ÏÑúÍ∞ïÎåÄ","Í≥µÎçï","Ìö®Ï∞ΩÍ≥µÏõêÏïû","Ïö©ÏÇ∞","Ïù¥Ï¥å","ÏÑúÎπôÍ≥†","ÌïúÎÇ®","Ïò•Ïàò","ÏùëÎ¥â","ÏôïÏã≠Î¶¨","Ï≤≠ÎüâÎ¶¨","ÌöåÍ∏∞","Ï§ëÎûë","ÏÉÅÎ¥â","ÎßùÏö∞","ÏñëÏõê","Íµ¨Î¶¨","ÎèÑÎÜç","ÏñëÏ†ï","ÎçïÏÜå","ÎèÑÏã¨","ÌåîÎãπ","Ïö¥Í∏∏ÏÇ∞","ÏñëÏàò","Ïã†Ïõê","Íµ≠Ïàò","ÏïÑÏã†","Ïò§Îπà","ÏñëÌèâ","ÏõêÎçï","Ïö©Î¨∏","ÏßÄÌèâ"],"Ïã†Î∂ÑÎãπÏÑ†":["Ïã†ÏÇ¨","ÎÖºÌòÑ","Ïã†ÎÖºÌòÑ","Í∞ïÎÇ®","ÏñëÏû¨","ÏñëÏû¨ÏãúÎØºÏùòÏà≤","Ï≤≠Í≥ÑÏÇ∞ÏûÖÍµ¨","ÌåêÍµê","Ï†ïÏûê","ÎØ∏Í∏à","ÎèôÏ≤ú","ÏàòÏßÄÍµ¨Ï≤≠","ÏÑ±Î≥µ","ÏÉÅÌòÑ","Í¥ëÍµêÏ§ëÏïô","Í¥ëÍµê"],"ÏàòÏù∏Î∂ÑÎãπÏÑ†":["Ï≤≠ÎüâÎ¶¨","ÌöåÍ∏∞","Ï§ëÎûë","ÏÉÅÎ¥â","ÎßùÏö∞","Íµ¨Î¶¨","ÎèÑÎÜç","ÏñëÏ†ï","ÎçïÏÜå","ÏôïÏã≠Î¶¨","ÏÑúÏö∏Ïà≤","ÏïïÍµ¨Ï†ïÎ°úÎç∞Ïò§","Í∞ïÎÇ®Íµ¨Ï≤≠","ÏÑ†Ï†ïÎ¶â","ÏÑ†Î¶â","ÌïúÌã∞","ÎèÑÍ≥°","Íµ¨Î£°","Í∞úÌè¨Îèô","ÎåÄÎ™®ÏÇ∞ÏûÖÍµ¨","ÏàòÏÑú","Î≥µÏ†ï","Í∞ÄÏ≤úÎåÄ","ÌÉúÌèâ","Î™®ÎûÄ","ÏïºÌÉë","Ïù¥Îß§","ÏÑúÌòÑ","ÏàòÎÇ¥","Ï†ïÏûê","ÎØ∏Í∏à","Ïò§Î¶¨","Ï£ΩÏ†Ñ","Î≥¥Ï†ï","Íµ¨ÏÑ±","Ïã†Í∞à","Í∏∞Ìù•","ÏÉÅÍ∞à","Ï≤≠Î™Ö","ÏòÅÌÜµ","ÎßùÌè¨","Îß§ÌÉÑÍ∂åÏÑ†","ÏàòÏõêÏãúÏ≤≠","Îß§Íµê","ÏàòÏõê","Í≥†ÏÉâ","Ïò§Î™©Ï≤ú","Ïñ¥Ï≤ú","ÏïºÎ™©","ÏÇ¨Î¶¨","ÌïúÎåÄÏïû","Ï§ëÏïô","Í≥†Ïûî","Ï¥àÏßÄ","ÏïàÏÇ∞","Ïã†Í∏∏Ïò®Ï≤ú","Ï†ïÏôï","Ïò§Ïù¥ÎèÑ","Îã¨Ïõî","ÏõîÍ≥∂","ÏÜåÎûòÌè¨Íµ¨","Ïù∏Ï≤úÎÖºÌòÑ","Ìò∏Íµ¨Ìè¨","ÎÇ®ÎèôÏù∏ÎçîÏä§ÌååÌÅ¨","ÏõêÏù∏Ïû¨","Ïó∞Ïàò","ÏÜ°ÎèÑ","ÌïôÏùµ","Ïù∏ÌïòÎåÄ","Ïà≠Ïùò","Ïã†Ìè¨","Ïù∏Ï≤ú"]};

  // Audio: NO BGM, only SFX
  // sfxGain is global (shared)

  // === Sound settings (volume) ===
  const VOL_MUTED_KEY = "jesong_vol_muted";
  const VOL_MOVE_KEY = "jesong_vol_move_pct";
  const VOL_TRANSFER_KEY = "jesong_vol_transfer_pct";
  const VOL_ARRIVE_KEY = "jesong_vol_arrive_pct";
  const VOL_UI_KEY = "jesong_vol_ui_pct";

  let isMuted = false;
  let volMovePct = 600;     // 0~1500
  let volTransferPct = 2500; // 0~5000
  let volArrivePct = 400; // Ï§ëÏïôÍ∞í(Í∏∞Î≥∏) -20% Ï°∞Ï†ï: 0~800 Í∏∞Ï§Ä
  let volUiPct = 2500; // Î≤ÑÌäº (Ï§ëÏïôÍ∞í) // 0~5000

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function loadSoundSettings(){
    try{
      isMuted = (localStorage.getItem(VOL_MUTED_KEY)||"0") === "1";
      const m = parseInt(localStorage.getItem(VOL_MOVE_KEY) || "600", 10);
      const t = parseInt(localStorage.getItem(VOL_TRANSFER_KEY) || "2500", 10);
      const a = parseInt(localStorage.getItem(VOL_ARRIVE_KEY) || "400", 10);
      const u = parseInt(localStorage.getItem(VOL_UI_KEY) || "2500", 10);
      volMovePct = clamp(Number.isFinite(m)?m:600, 0, 1200);
      volTransferPct = clamp(Number.isFinite(t)?t:2500, 0, 5000);
      volArrivePct = clamp(Number.isFinite(a)?a:400, 0, 800);
      volUiPct = clamp(Number.isFinite(u)?u:2500, 0, 5000);
      // Safety floor: prevent 'silent UI' due to corrupted/zero stored values
      if(!isMuted && volUiPct < 80) volUiPct = 250;
      if(!isMuted && volMovePct < 40) volMovePct = 200;

    }catch(e){}
  }
  function saveSoundSettings(){
    try{
      localStorage.setItem(VOL_MUTED_KEY, isMuted ? "1" : "0");
      localStorage.setItem(VOL_MOVE_KEY, String(volMovePct));
      localStorage.setItem(VOL_TRANSFER_KEY, String(volTransferPct));
      localStorage.setItem(VOL_ARRIVE_KEY, String(volArrivePct));
      localStorage.setItem(VOL_UI_KEY, String(volUiPct));
    }catch(e){}
  }
  function volMove(){ return (isMuted ? 0 : (volMovePct/100)); }
  function volTransfer(){ return (isMuted ? 0 : (volTransferPct/100)); }
  function volArrive(){ return (isMuted ? 0 : (volArrivePct/100)); }
  function volUi(){ return __safeClamp(volMove() * (volUiPct/5000), 0, 10); }

  function applyTransferGain(){
    try{
      if(transferGain) transferGain.gain.value = 0.0045 * volTransfer();
    }catch(e){}
    try{
      // If <audio> fallback is used
      if(typeof sfxTransfer !== "undefined" && sfxTransfer) sfxTransfer.volume = 0.0045 * volTransfer();
    }catch(e){}
  }

  loadSoundSettings();

  
  /* === Audio resume safety v9 === */
  function resumeAudioNow(){
    try{
      const AC = window.AudioContext || window.webkitAudioContext;
      if(AC && !audioCtx) audioCtx = new AC();
      if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); }
    }catch(e){}
  }


// === Global audio unlock (iOS/PWA): ensure WebAudio works for move/UI ===
(function audioGuards(){
  if(window.__audioGuardsInstalled) return;
  window.__audioGuardsInstalled = true;

  const guard = ()=>{
    try{ ensureAudio(); }catch(e){}
    try{
      if(audioCtx && audioCtx.state === 'suspended'){
        audioCtx.resume().catch(()=>{});
      }
    }catch(e){}
    // iOS unlock: a tiny silent blip (kept very short)
    try{
      if(!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.00001, t);
      g.gain.exponentialRampToValueAtTime(0.00001, t+0.02);
      o.frequency.setValueAtTime(440, t);
      o.connect(g); g.connect(sfxGain || audioCtx.destination);
      o.start(t); o.stop(t+0.02);
    }catch(e){}
  };

  document.addEventListener('pointerdown', guard, {capture:true, passive:true});
  document.addEventListener('touchstart', guard, {capture:true, passive:true});
  document.addEventListener('click', guard, {capture:true, passive:true});
  document.addEventListener('visibilitychange', ()=>{
    if(!document.hidden) guard();
  });
})();

function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    try{ if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); } }catch(e){}
    if(!sfxGain){
      sfxGain = audioCtx.createGain();
      // iPhone Ïä§ÌîºÏª§ÏóêÏÑú UI ÌÅ¥Î¶≠Ïù¥ ÌôïÏã§Ìûà Îì§Î¶¨ÎèÑÎ°ù Ï†ÑÏ≤¥ SFX Ï∂úÎ†• Í≤åÏù∏ ÏÉÅÌñ•
      sfxGain.gain.value = 1.25;
      sfxGain.connect(audioCtx.destination);
    }
  }
  // iOS/PWA audio unlock: run once on the very first user gesture.
  function __unlockAudioOnce(){
    if(window.__audioUnlocked) return;
    window.__audioUnlocked = true;
    try{
      ensureAudio();
      if(!audioCtx) return;
      // Try resume in a user-gesture callstack
      if(audioCtx.state === 'suspended'){
        audioCtx.resume().catch(()=>{});
      }
      // "silent tick" to fully unlock audio routing on some iOS versions
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.setValueAtTime(440, now);
      g.gain.setValueAtTime(0.00001, now);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.03);
    }catch(e){}
  }

  // Attach one-time unlock to earliest gestures (capture)
  (function __wireAudioUnlock(){
    if(window.__wireAudioUnlockDone) return;
    window.__wireAudioUnlockDone = true;
    const unlock = ()=>{ try{ __unlockAudioOnce(); }catch(e){} };
    document.addEventListener('pointerdown', unlock, {capture:true, passive:true});
    document.addEventListener('touchstart', unlock, {capture:true, passive:true});
  })();

  function startBGM(){ ensureAudio(); }
  function playMoveTick(){
    ensureAudio();
    // iOS: AudioContext can be suspended until a user gesture. Resume safely.
    try{
      if(audioCtx && audioCtx.state === 'suspended'){
        audioCtx.resume().then(()=>{ try{ playMoveTick(); }catch(e){} }).catch(()=>{});
        return;
      }
    }catch(e){}
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    const f=audioCtx.createBiquadFilter();
    o.type='square'; o.frequency.value=1500;
    f.type='bandpass'; f.frequency.value=1100; f.Q.value=9;
    g.gain.value=0.0001;
    o.connect(f).connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.18*volMove(), now+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.06);
    o.stop(now+0.07);
    const o2=audioCtx.createOscillator();
    const g2=audioCtx.createGain();
    o2.type='sine'; o2.frequency.value=420;
    g2.gain.value=0.0001;
    o2.connect(g2).connect(sfxGain);
    o2.start(now+0.018);
    g2.gain.linearRampToValueAtTime(0.07*volMove(), now+0.03);
    g2.gain.exponentialRampToValueAtTime(0.0001, now+0.16);
    o2.stop(now+0.17);
  }
  // === UI Click SFX routing (fixed15) ===
  // playMoveTick: movement tick (used only during actual Ïù¥Îèô Ïó∞Ï∂ú)
  // playTick: UI click (used for Î™®Îì† ÌÑ∞Ïπò/Î≤ÑÌäº)
  function playTick(){
    try{ playUiClickSfx(); }catch(e){}
  }

  function playDing(){ try{ playUiClickSfx(); }catch(e){} }
  function playFanfare(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const g=audioCtx.createGain();
    g.gain.value=0.0001;
    g.connect(sfxGain);
    const o1=audioCtx.createOscillator();
    const o2=audioCtx.createOscillator();
    o1.type='square'; o2.type='square';
    o1.connect(g); o2.connect(g);
    const seq=[523.25,659.25,783.99,1046.5];
    const dur=0.10;
    o1.start(now); o2.start(now);
    seq.forEach((f,i)=>{ o1.frequency.setValueAtTime(f, now+i*dur); o2.frequency.setValueAtTime(f*0.5, now+i*dur); });
    g.gain.linearRampToValueAtTime(0.095*volArrive(), now+0.02);
    g.gain.linearRampToValueAtTime(0.065*volArrive(), now+0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, now+seq.length*dur+0.12);
    o1.stop(now+seq.length*dur+0.15);
    o2.stop(now+seq.length*dur+0.15);
  }

  function formatStation(s){ s=String(s).trim().replace(/Ïó≠$/,''); return s+'Ïó≠'; }
  function normalizeName(s){ return String(s).trim().replace(/Ïó≠$/,'').replace(/\s+/g,''); }

  // Build line data (line-aware)
  function cleanLine(arr){
    const out=[];
    for(let i=0;i<arr.length;i++){
      const s=String(arr[i]).trim();
      if(!s) continue;
      if(out.length && out[out.length-1]===s) continue;
      out.push(s);
    }
    return out;
  }
  // === Subway data derived structures (built from DATA) ===
  let subwayData = {};
  let lineNames = [];
  let lineIndex = {};
  let stationLines = new Map();
  let allStations = [];

  function __isValidSubwayData(obj){
    if(!obj || typeof obj !== 'object') return false;

    // v2 schema
    if(obj.schemaVersion === 2 && Array.isArray(obj.lines) && obj.stations && typeof obj.stations === 'object'){
      return true;
    }

    // legacy: { "2Ìò∏ÏÑ†": ["ÏãúÏ≤≠", ...], ... }
    const keys = Object.keys(obj);
    if(!keys.length) return false;
    for(const k of keys){
      if(!Array.isArray(obj[k])) return false;
      for(const v of obj[k]){
        if(typeof v !== 'string') return false;
      }
    }
    return true;
  }

  function rebuildSubwayStructures(){
    subwayData = {};
    lineNames = Object.keys(DATA);
    lineIndex = {};
    stationLines = new Map();

    for(const line of lineNames) subwayData[line] = cleanLine(DATA[line]);

    for(const line of lineNames){
      lineIndex[line] = {};
      const arr = subwayData[line];
      for(let i=0;i<arr.length;i++) lineIndex[line][arr[i]] = i;
    }

    for(const line of lineNames){
      for(const st of subwayData[line]){
        if(!stationLines.has(st)) stationLines.set(st, new Set());
        stationLines.get(st).add(line);
      }
    }

    allStations = Array.from(stationLines.keys());
  }

  // build once from embedded DATA first
  rebuildSubwayStructures();

  const getLinesOf=(st)=>stationLines.get(st)?Array.from(stationLines.get(st)):[];

  const getNextOnLine=(line,st,dir)=>{
    const idx=lineIndex[line] && lineIndex[line][st];
    if(idx===undefined) return null;
    const arr=subwayData[line];
    const ni=idx+dir;
    if(ni<0||ni>=arr.length) return null;
    return arr[ni];
  };

  // Try to load external subway_data.json (optional), then rebuild before game starts
  async function tryLoadExternalSubwayData(){
    try{
      // don't hot-swap while running animation/game
      if(window.__gameStarted) return;

      const url = 'subway_data.json?ts=' + Date.now();
      const res = await fetch(url, {cache:'no-store'});
      if(!res.ok) return;

      const obj = await res.json();
      if(!__isValidSubwayData(obj)) return;

      DATA = __normalizeSubwayData(obj);
      rebuildSubwayStructures();
      window.__subwayDataLoaded = true;
    }catch(_e){
      // ignore (offline / no file / blocked)
    }
  }
  window.tryLoadExternalSubwayData = tryLoadExternalSubwayData;
  window.rebuildSubwayStructures = rebuildSubwayStructures;

  // fire after DOM is ready (so fetch won't race iOS weirdness)
  document.addEventListener('DOMContentLoaded', ()=>{ tryLoadExternalSubwayData(); }, {once:true});

  // Load saved movement settings
  try{
    const ms = parseInt(localStorage.getItem(MIN_STOPS_KEY)||'',10);
    const mx = parseInt(localStorage.getItem(MAX_STOPS_KEY)||'',10);
    if(Number.isFinite(ms)) minStops = Math.max(1, Math.min(99, ms));
    if(Number.isFinite(mx)) maxStops = Math.max(1, Math.min(99, mx));
    if(minStops>maxStops) [minStops,maxStops] = [maxStops,minStops];
  }catch(e){}


  // Layout (no x-averaging)
  const yStep=90, xStep=22, marginX=90, marginY=90;
  const pos=new Map();
  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const y=marginY + li*yStep;
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++){
      const st=arr[i];
      const x=marginX + i*xStep;
      pos.set(line+'::'+st, {x:x,y:y});
    }
  }

  // Draw SVG
  
  // === Pause overlay (background -> pause, return -> require one tap) ===
  function initPauseOverlay(){
    const pauseOverlay = document.getElementById('pauseOverlay');
    const pausePlayBtn = document.getElementById('pausePlayBtn');
    if(!pauseOverlay || !pausePlayBtn) return;

    function showPause(){ pauseOverlay.classList.add('show'); pauseOverlay.setAttribute('aria-hidden','false'); }
    function hidePause(){ pauseOverlay.classList.remove('show'); pauseOverlay.setAttribute('aria-hidden','true'); }

    function setPaused(on){
      if(!window.__gameStarted) return;
      window.__paused = !!on;
      if(window.__paused){
        try{ stopTransferSound(); }catch(e){}
        try{ sessionStorage.setItem('jesong_bg', String(Date.now())); }catch(e){}
      }
    }

    function resumeFromPause(){
      try{ playTick(); }catch(e){}
      try{ primeAudio(); }catch(e){}
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
      window.__paused = false;
      try{ sessionStorage.removeItem('jesong_bg'); }catch(e){}
      hidePause();
    }

    pauseOverlay.addEventListener('click', (e)=>{ e.preventDefault(); resumeFromPause(); });
    pauseOverlay.addEventListener('touchend', (e)=>{ e.preventDefault(); resumeFromPause(); }, {passive:false});
    pausePlayBtn.addEventListener('click', (e)=>{ e.preventDefault(); resumeFromPause(); });
    pausePlayBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); resumeFromPause(); }, {passive:false});

    document.addEventListener('visibilitychange', ()=>{
      if(!window.__gameStarted) return;
      if(document.hidden){ setPaused(true); return; }
      const hadBg = window.__paused || !!sessionStorage.getItem('jesong_bg');
      if(hadBg){ window.__paused = true; showPause(); }
    });

    window.addEventListener('pagehide', ()=>{ setPaused(true); });
    window.addEventListener('blur', ()=>{ setPaused(true); });
    window.addEventListener('pageshow', ()=>{ 
      if(!window.__gameStarted) return;
      const hadBg = !!sessionStorage.getItem('jesong_bg');
      if(hadBg){ window.__paused = true; showPause(); }
    });
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initPauseOverlay);
  }else{
    initPauseOverlay();
  }


const viewport=document.getElementById('viewport');
  const map=document.getElementById('map');
  const gLines=document.getElementById('gLines');
  const gDots=document.getElementById('gDots');
  const token=document.getElementById('token');

  // --- Camera follow (stable): keep token centered without jitter (step-based + smoothing) ---
  const viewportEl = document.getElementById('viewport');

    let isAutoScroll = false;
// User can drag the view freely; after a short pause, camera returns to token center.
  if(viewportEl){
    const GRACE_MS = 1200; // time after last interaction before recenter
    const markUserPan = () => {
            if(isAutoScroll) return;
userPanUntil = Date.now() + GRACE_MS;
      if(recenterTimer) clearTimeout(recenterTimer);
      recenterTimer = setTimeout(() => {
        // Once user stops, snap back to token center (even if not animating)
        followTokenStable(true);
        setTimeout(()=>followTokenStable(true), 60);
      }, GRACE_MS + 20);
    };

    viewportEl.addEventListener('pointerdown', markUserPan, {passive:true});
    viewportEl.addEventListener('pointermove', markUserPan, {passive:true});
    window.addEventListener('pointerup', markUserPan, {passive:true});

    viewportEl.addEventListener('touchstart', markUserPan, {passive:true});
    viewportEl.addEventListener('touchmove', markUserPan, {passive:true});
    window.addEventListener('touchend', markUserPan, {passive:true});

    viewportEl.addEventListener('wheel', markUserPan, {passive:true});
  }

  let followPending = false;
  let userPanUntil = 0; // timestamp until which we don't auto-center (user is dragging)
  let recenterTimer = null;


  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  // Camera offset: user wants the person token to be **dead center**.
  const CAMERA_OFFSET_Y = 0;

  function scheduleInitialCenter(){
    // iOS Safari: run a few times after layout settles
    requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} });
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 120);
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 320);
  }

  // Snap camera to token immediately (used after teleport / after splash removal)
  function snapCameraToTokenNow(){
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }


  function followTokenStable(force){
    if(followPending) return;
    followPending = true;
    requestAnimationFrame(()=>{
      followPending = false;

      // overlays guard
      const startOverlayEl = document.getElementById('startOverlay');
      const settingsOverlayEl = document.getElementById('settingsOverlay');
      if(startOverlayEl){
        // While splash is fading out, allow camera to run so map becomes visible immediately.
        const cs = getComputedStyle(startOverlayEl);
        const fading = startOverlayEl.classList.contains('fadeOut');
        if(!fading && cs.display !== 'none' && cs.visibility !== 'hidden' && !startOverlayEl.classList.contains('hidden')) return;
      }


  // Snap camera to token immediately (useful right after setting station via input)
  function snapCameraToTokenNow(){
    // 2 frames only, once per teleport -> no noticeable stutter
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }
      if(settingsOverlayEl && settingsOverlayEl.classList.contains('show')) return;

      if(!viewportEl || !token) return;
      if(!force && Date.now() < userPanUntil) return;

      const vp = viewportEl.getBoundingClientRect();
      const tr = token.getBoundingClientRect();

      // token center in scroll-content coordinates
      const tokenCx = (tr.left - vp.left) + viewportEl.scrollLeft + tr.width/2;
      const tokenCy = (tr.top  - vp.top ) + viewportEl.scrollTop  + tr.height/2;

      const vpW = viewportEl.clientWidth;
      const vpH = viewportEl.clientHeight;

      const targetLeft = clamp(tokenCx - vpW/2, 0, viewportEl.scrollWidth - vpW);
      const targetTop  = clamp(tokenCy - vpH/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - vpH);

      isAutoScroll = true;
      viewportEl.scrollLeft = targetLeft;
      viewportEl.scrollTop  = targetTop;
      requestAnimationFrame(()=>{ isAutoScroll = false; });

      // one more settle frame for iOS timing
      requestAnimationFrame(()=>{
        const vp2 = viewportEl.getBoundingClientRect();
        const tr2 = token.getBoundingClientRect();
        const tokenCx2 = (tr2.left - vp2.left) + viewportEl.scrollLeft + tr2.width/2;
        const tokenCy2 = (tr2.top  - vp2.top ) + viewportEl.scrollTop  + tr2.height/2;
        const tL2 = clamp(tokenCx2 - viewportEl.clientWidth/2, 0, viewportEl.scrollWidth - viewportEl.clientWidth);
        const tT2 = clamp(tokenCy2 - viewportEl.clientHeight/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - viewportEl.clientHeight);
        isAutoScroll = true;
        viewportEl.scrollLeft = tL2;
        viewportEl.scrollTop  = tT2;
        requestAnimationFrame(()=>{ isAutoScroll = false; });
      });
    });
  }



  const hudG=document.getElementById('hudG');
  const HUD_OFFSET_Y = 68; // adjusted: closer to head, avoid clipping

  const hudLine1=document.getElementById('hudLine1');
  const hudLine2=document.getElementById('hudLine2');

  const LINE_COLORS={"1Ìò∏ÏÑ†":"#1e88e5","2Ìò∏ÏÑ†":"#2e7d32","3Ìò∏ÏÑ†":"#f9a825","4Ìò∏ÏÑ†":"#039be5","5Ìò∏ÏÑ†":"#8e24aa","6Ìò∏ÏÑ†":"#6d4c41","7Ìò∏ÏÑ†":"#7b1fa2","8Ìò∏ÏÑ†":"#d81b60","9Ìò∏ÏÑ†":"#b59a00","Í≤ΩÏùòÏ§ëÏïôÏÑ†":"#00838f","Ïã†Î∂ÑÎãπÏÑ†":"#c62828","ÏàòÏù∏Î∂ÑÎãπÏÑ†":"#f06292"};
  const lineColor=(n)=>LINE_COLORS[n]||"#ff4d6d";
  function svgEl(tag, attrs){
    const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  let maxLen=0;
  // Extra top padding so the token can be centered even when starting near the top lines.
  // (Otherwise scrollTop clamps to 0 and the token appears too low.)
  const PAD_TOP = 700;
  const PAD_BOTTOM = 900;
  const mapShift = document.getElementById('mapShift');
  for(const line of lineNames) maxLen=Math.max(maxLen, subwayData[line].length);
  const W=Math.max(1800, marginX + maxLen*xStep + 140);
  const H=Math.max(1100, marginY + lineNames.length*yStep + 140);
  map.setAttribute('width', String(W));
  map.setAttribute('height', String(H + PAD_TOP + PAD_BOTTOM));
  map.setAttribute('viewBox', '0 ' + (-PAD_TOP) + ' ' + W + ' ' + (H + PAD_TOP + PAD_BOTTOM));
  if(mapShift) mapShift.setAttribute('transform', 'translate(0,'+PAD_TOP+')');
for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const arr=subwayData[line];
    let d='';
    for(let i=0;i<arr.length;i++){
      const p=pos.get(line+'::'+arr[i]);
      d += (i===0 ? ('M '+p.x+' '+p.y) : (' L '+p.x+' '+p.y));
    }
    gLines.appendChild(svgEl('path', {d:d, class:'lineStroke', stroke: lineColor(line)}));
    gLines.appendChild(svgEl('path', {d:d, class:'lineInner'}));
    const label=svgEl('text', {x:'16', y:String(marginY + li*yStep + 5), class:'label'});
    label.textContent=line;
    gLines.appendChild(label);
  }

  stationLines.forEach((set, st)=>{
    const lines=Array.from(set);
    if(lines.length<2) return;
    const pts=[];
    for(const l of lines){ const p=pos.get(l+'::'+st); if(p) pts.push(p); }
    pts.sort((a,b)=>a.y-b.y);
    if(pts.length<2) return;
    let d='M '+pts[0].x+' '+pts[0].y;
    for(let i=1;i<pts.length;i++) d += ' L '+pts[i].x+' '+pts[i].y;
    gLines.appendChild(svgEl('path', {d:d, class:'connector'}));
  });

  stationLines.forEach((set, st)=>{
    if(set.size<2) return;
    for(const line of set){
      const p=pos.get(line+'::'+st);
      if(!p) continue;
      gDots.appendChild(svgEl('circle', {cx:String(p.x), cy:String(p.y), r:'4', class:'stationDot'}));
    }
  });

  // Drag-to-pan
  (function enableDragPan(){
    let isDown=false, startX=0, startY=0, sl=0, st=0;
    viewport.addEventListener('pointerdown',(e)=>{
      isDown=true; viewport.setPointerCapture(e.pointerId);
      startX=e.clientX; startY=e.clientY;
      sl=viewport.scrollLeft; st=viewport.scrollTop;
    });
    viewport.addEventListener('pointermove',(e)=>{
      if(!isDown) return;
      viewport.scrollLeft = sl - (e.clientX - startX);
      viewport.scrollTop  = st - (e.clientY - startY);
    });
    viewport.addEventListener('pointerup',()=>{ isDown=false; });
    viewport.addEventListener('pointercancel',()=>{ isDown=false; });
    // Set initial scroll so default view stays the same (but you can drag down to see more top)
})();

  // Confetti
  const confCanvas=document.getElementById('confetti');
  const confCtx=confCanvas.getContext('2d');
  function resizeCanvasTo(el, canvas, ctx){
    const r=el.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height};
  }
  function burstConfettiOn(canvas, ctx, w, h){
    if(canvas.__raf) cancelAnimationFrame(canvas.__raf);
    const colors=["#ff4d6d","#ff85a2","#ffd6e0","#c9184a","#ffb3c1","#ffe3ea"];
    const pieces=[];
    const count=190;
    for(let i=0;i<count;i++) pieces.push({x:w*0.5,y:h*0.32,vx:(Math.random()-0.5)*9,vy:-Math.random()*11-7,g:0.22+Math.random()*0.18,w:4+Math.random()*5,h:3+Math.random()*5,a:Math.random()*Math.PI,va:(Math.random()-0.5)*0.25,c:colors[Math.floor(Math.random()*colors.length)],life:0,max:170+Math.random()*70});
    function tick(){
      ctx.clearRect(0,0,w,h);
      let alive=0;
      for(const p of pieces){
        p.life++; if(p.life<p.max) alive++;
        p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.va;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.a);
        ctx.globalAlpha=Math.max(0,1-p.life/p.max);
        ctx.fillStyle=p.c;
        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }
      ctx.globalAlpha=1;
      if(alive>0) canvas.__raf=requestAnimationFrame(tick);
      else ctx.clearRect(0,0,w,h);
    }
    tick();
  }
  resizeCanvasTo(viewport, confCanvas, confCtx);
  window.addEventListener('resize', ()=>{ resizeCanvasTo(viewport, confCanvas, confCtx); });

  // Movement helpers
  // Camera policy (IMPORTANT):
  // - Person token must stay *dead center* of the map viewport.
  // - User can drag/pan anytime; while dragging we don't fight.
  // - After dragging ends, we gently return to token.
  // We reuse the existing followTokenStable() logic above to avoid conflicting camera systems.
  function setTokenXY(x,y, smooth){
    token.setAttribute('transform','translate('+x+','+y+')');
    hudG.setAttribute('transform','translate('+x+','+(y-HUD_OFFSET_Y)+')');

    // If smooth=false (snap moments like first render / arrival), force-center once.
    // Otherwise keep centering every frame (but do not fight the user while dragging).
    try{ followTokenStable(!smooth); }catch(e){}
  }

  function setTokenAt(line, st, smooth){
    const p=pos.get(line+'::'+st);
    if(!p) return;
    setTokenXY(p.x,p.y,smooth);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
  function moveSegment(lineA, stA, lineB, stB){
    const a=pos.get(lineA+'::'+stA);
    const b=pos.get(lineB+'::'+stB);
    if(!a||!b) return Promise.resolve();
    const d=dist(a,b);
    const duration=Math.max(240, Math.min(650, d*6.5));
    const start=performance.now();
    let pausedTotal=0;
    let lastT=0;
    let wasPaused=false;
    return new Promise(res=>{
      function tick(t){
      // freeze animation progress while paused (no const reassign; accumulate paused time)
      if(window.__paused){
        if(!wasPaused){ wasPaused=true; lastT = t; }
        else { pausedTotal += (t - lastT); lastT = t; }
        requestAnimationFrame(tick);
        return;
      }
      if(wasPaused){ wasPaused=false; lastT = t; }

        const p=Math.min(1,(t-start-pausedTotal)/duration);
        const e=p<0.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
        setTokenXY(a.x+(b.x-a.x)*e, a.y+(b.y-a.y)*e, true);
        if(p<1) requestAnimationFrame(tick); else res();
      }
      requestAnimationFrame(tick);
    });
  }

  // Path generator: transfer only at interchange, stop at terminal, no reverse
  let minStops = 1;
  let maxStops = 25;
  let trueRandomMode = false;
  // Always start with true-random OFF on initial load
  trueRandomMode = false;
  try{ localStorage.setItem(TRUE_RANDOM_KEY, '0'); }catch(e){}  
  // ------------------------------
  // Pathfinding (ÏµúÏ†Å Í≤ΩÎ°ú: ÏµúÏÜå Ïù¥ÎèôÏó≠ + Î∂àÌïÑÏöî ÌôòÏäπ ÏµúÏÜåÌôî)
  // ------------------------------
  // Build station adjacency (neighbors along each line)
  // IMPORTANT: We do NOT treat each line's station array as a single continuous chain when the line has branches.
  // Instead, we build an explicit adjacency list (stationNeighbors) and patch known branch-breaks so iOS/Android/PC all compute the same *real* shortest-stop routes.
  const stationNeighbors = new Map(); // station -> Set(neighborStation)
  const addEdge = (a,b)=>{
    if(!a||!b||a===b) return;
    if(!stationNeighbors.has(a)) stationNeighbors.set(a, new Set());
    if(!stationNeighbors.has(b)) stationNeighbors.set(b, new Set());
    stationNeighbors.get(a).add(b);
    stationNeighbors.get(b).add(a);
  };

  // 1) Í∏∞Î≥∏: Í∞Å Ìò∏ÏÑ†Ïùò Ïù∏Ï†ë Ïó≠(Î∞∞Ïó¥ÏóêÏÑú Î∞îÎ°ú Ïïû/Îí§)Îßå edgeÎ°ú Ï∂îÍ∞Ä
  lineNames.forEach(line => {
    const arr = subwayData[line];
    for(let i=1;i<arr.length;i++){
      const a = arr[i-1];
      const b = arr[i];
      // Branch patches for Line 1 (ÏàòÎèÑÍ∂å 1Ìò∏ÏÑ†ÏùÄ Î∂ÑÍ∏∞Í∞Ä ÎßéÏïÑÏÑú, Îã®Ïùº Î∞∞Ïó¥ÏùÑ Í∑∏ÎåÄÎ°ú ÏûáÏúºÎ©¥ Í∞ÄÏßú Ïó∞Í≤∞Ïù¥ ÏÉùÍπÄ)
      if(line==='1Ìò∏ÏÑ†'){
        // (1) Ïù∏Ï≤ú(Í≤ΩÏù∏ÏÑ† Ï¢ÖÏ†ê) Îã§ÏùåÏóê Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄÎ°ú 'Ï†êÌîÑ'ÌïòÎäî Í∞ÄÏßú Ïó∞Í≤∞ Ï∞®Îã®
        if((a==='Ïù∏Ï≤ú' && b==='Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ') || (a==='Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ' && b==='Ïù∏Ï≤ú')) continue;
        // (2) 1Ìò∏ÏÑ† Îç∞Ïù¥ÌÑ∞Ïóê ÏÑûÏó¨ÏûàÎäî 4Ìò∏ÏÑ† Íµ¨Í∞Ñ(Í∏àÏ†ï‚ÜíÏÇ∞Î≥∏‚Ä¶) Í∞ÄÏßú Ïó∞Í≤∞ Ï∞®Îã®
        if((a==='Í∏àÏ†ï' && b==='ÏÇ∞Î≥∏') || (a==='ÏÇ∞Î≥∏' && b==='Í∏àÏ†ï')) continue;
        // (3) Ïò§Ïù¥ÎèÑ Ïù¥ÌõÑ ÏùòÏôïÏúºÎ°ú Ï†êÌîÑÌïòÎäî Í∞ÄÏßú Ïó∞Í≤∞ Ï∞®Îã®
        if((a==='Ïò§Ïù¥ÎèÑ' && b==='ÏùòÏôï') || (a==='ÏùòÏôï' && b==='Ïò§Ïù¥ÎèÑ')) continue;
      }
      addEdge(a,b);
    }
  });

  // 2) 1Ìò∏ÏÑ† Î∂ÑÍ∏∞ Î≥¥Ï†ï: Íµ¨Î°ú‚ÜîÍ∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ(Í≤ΩÎ∂ÄÏÑ† Î∞©Ìñ•)Îäî Ïã§Ï†ú Ïù∏Ï†ëÏó≠Ïù∏Îç∞,
  //    ÏúÑÏùò ÏõêÎ≥∏ Î∞∞Ïó¥ÏóêÏÑ† 'Ïù∏Ï≤ú ÏßÄÏÑ†' Îí§Ïóê Î∂ôÏñ¥ÏûàÏñ¥ Ïó∞Í≤∞Ïù¥ Îπ†Ï†∏ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÌïúÎã§.
  addEdge('Íµ¨Î°ú','Í∞ÄÏÇ∞ÎîîÏßÄÌÑ∏Îã®ÏßÄ');


  function bfsDistances(start){
    const q=[start];
    const dist=new Map([[start,0]]);
    for(let qi=0; qi<q.length; qi++){
      const cur=q[qi];
      const d=dist.get(cur);
      const ns=stationNeighbors.get(cur);
      if(!ns) continue;
      ns.forEach(n=>{
        if(!dist.has(n)){
          dist.set(n,d+1);
          q.push(n);
        }
      });
    }
    return dist;
  }

  // Dijkstra with lexicographic cost: (stops, transfers)
  // State is (station, line). Move along same line adds 1 stop. Transfer changes line adds 1 transfer (0 stop).
  // We minimize **stops first**, and only if stops are equal, we minimize transfers.
  function bestRoute(startStation, endStation){
    const startLines = getLinesOf(startStation);
    const endLines = getLinesOf(endStation);
    if(!startLines.length || !endLines.length) return null;

    const pq=[];
    const key=(st,line)=>st+"@@"+line;
    const best=new Map();     // key -> [stops, transfers]
    const prev=new Map();     // key -> previous key
    const prevStep=new Map(); // key -> {st,line}

    function push(st,line,stops,transfers,fromKey){
      const k=key(st,line);
      const cur=best.get(k);
      if(cur){
        if(stops>cur[0] || (stops===cur[0] && transfers>=cur[1])) return;
      }
      best.set(k,[stops,transfers]);
      if(fromKey){
        prev.set(k,fromKey);
        prevStep.set(k,{st,line});
      }
      pq.push([stops,transfers,st,line]);
    }

    // init: allow starting on any line at startStation with 0/0
    startLines.forEach(line=>push(startStation,line,0,0,null));

    // poor man's priority queue: sort each pop (small graph so OK)
    while(pq.length){
      pq.sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
      const [stops,transfers,st,line]=pq.shift();
      const k=key(st,line);
      const cur=best.get(k);
      if(!cur || cur[0]!==stops || cur[1]!==transfers) continue;

      if(st===endStation && endLines.includes(line)){
        // reconstruct
        const path=[];
        let kk=k;
        while(kk){
          const [station, ln] = kk.split("@@");
          path.push({line: ln, st: station});
          kk = prev.get(kk);
        }
        path.reverse();
        // compress any accidental duplicates (same station+line)
        const out=[];
        for(const step of path){
          const last=out[out.length-1];
          if(last && last.st===step.st && last.line===step.line) continue;
          out.push(step);
        }
        return out;
      }

      // 1) move to neighbors along same line
      const idxMap = lineIndex[line];
      const arr = subwayData[line];
      const idx = idxMap ? idxMap[st] : undefined;
      if(idx!==undefined){
        if(idx>0){
          const n=arr[idx-1];
          push(n,line,stops+1,transfers,k);
        }
        if(idx<arr.length-1){
          const n=arr[idx+1];
          push(n,line,stops+1,transfers,k);
        }
      }

      // 2) transfer at same station
      const linesHere = getLinesOf(st).filter(l=>l!==line);
      for(const nl of linesHere){
        push(st,nl,stops,transfers+1,k);
      }
    }

    // If we couldn't reach with line-matching end, allow endStation on any line (still minimal)
    // Find best among endStation states
    let bestEndKey=null, bestCost=null;
    for(const ln of endLines){
      const k=key(endStation,ln);
      const c=best.get(k);
      if(c && (!bestCost || c[0]<bestCost[0] || (c[0]==bestCost[0] && c[1]<bestCost[1]))){
        bestCost=c; bestEndKey=k;
      }
    }
    if(!bestEndKey) return null;
    const path=[];
    let kk=bestEndKey;
    while(kk){
      const [station, ln] = kk.split("@@");
      path.push({line: ln, st: station});
      kk = prev.get(kk);
    }
    path.reverse();
    const out=[];
    for(const step of path){
      const last=out[out.length-1];
      if(last && last.st===step.st && last.line===step.line) continue;
      out.push(step);
    }
    return out;
  }

  // Compatibility alias: returns {path} where path is bestRoute (min stops, then min transfers)
  function dijkstraMinTransferStops(startStation, endStation){
    var p = bestRoute(startStation, endStation);
    return { path: p || [] };
  }


  // Pick a random destination within [minStops, maxStops] stops, then compute best route to it.
  
  // Pick a random destination within [minStops, maxStops] stops from start (by BFS distance),
  // then compute an optimal route prioritizing: (1) minimum transfers, (2) minimum stops.
  
  // Pick a destination whose *actual route stops* (path length - 1) falls within [minStops, maxStops].
  // Route is optimized by: (1) minimum transfers, (2) minimum stops.
  function planOptimalTrip(startStation){
    const dist = bfsDistances(startStation);
    const candidates = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d === undefined) continue;
      if(st !== startStation && d >= minStops && d <= maxStops) candidates.push(st);
    }

    // Shuffle candidates to keep it random but within constraints
    for(let i=candidates.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = candidates[i]; candidates[i]=candidates[j]; candidates[j]=tmp;
    }

    function routeStops(path){
      if(!path || !path.length) return 0;
      let s=0;
      for(let i=1;i<path.length;i++){ if(path[i].st !== path[i-1].st) s++; }
      return s;
    }

    // 1) Try strict: find a dest whose optimized route also fits the stop-range.
    for(const dest of candidates){
      const best = dijkstraMinTransferStops(startStation, dest);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops >= minStops && stops <= maxStops){
        return { dest, path };
      }
    }

    // 2) Fallback: if none fits (rare due to transfer-priority), pick the closest route <= maxStops
    let bestPick = null;
    for(const st of allStations){
      if(st === startStation) continue;
      const best = dijkstraMinTransferStops(startStation, st);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops > 0 && stops <= maxStops){
        if(!bestPick || stops > bestPick.stops){
          bestPick = { dest: st, path, stops };
        }
      }
    }
    if(bestPick) return { dest: bestPick.dest, path: bestPick.path };

    // 3) Absolute fallback: any reachable station
    const reachable = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d !== undefined && st !== startStation) reachable.push(st);
    }
    const dest = reachable.length ? pick(reachable) : startStation;
    const best = dijkstraMinTransferStops(startStation, dest);
    return { dest, path: (best && best.path) ? best.path : [] };
  }

function randomWalkPath(startLine, startStation){
    let curLine = startLine;

    const idx = lineIndex[curLine][startStation];
    const arr = subwayData[curLine];

    // Ï¢ÖÏ†êÏóêÏÑú Ï∂úÎ∞úÌïòÎ©¥ Î¨¥Ï°∞Í±¥ Ï¢ÖÏ†ê Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú Ï∂úÎ∞ú
    let dir;
    if (idx === 0) dir = 1;
    else if (idx === arr.length - 1) dir = -1;
    else dir = Math.random() < 0.5 ? -1 : 1;

    const stepsPlanned = randInt(minStops, maxStops);
    const path = [{ line: curLine, st: startStation }];
    let curSt = startStation;

    for (let step = 1; step <= stepsPlanned; step++) {
      const linesAtCur = getLinesOf(curSt);
      if (linesAtCur.length >= 2) {
        const remain = stepsPlanned - step + 1;
        const nearEnd = remain <= 6;
        const pTransfer = nearEnd ? 0.55 : 0.22;
        if (Math.random() < pTransfer) {
          const choices = linesAtCur.filter(l => l !== curLine);
          if (choices.length) {
            curLine = pick(choices);

            // ÌôòÏäπ ÌõÑÏóêÎèÑ Ï¢ÖÏ†êÏù¥Î©¥ Î∞©Ìñ• Îã§Ïãú Î≥¥Ï†ï
            const newIdx = lineIndex[curLine][curSt];
            const newArr = subwayData[curLine];
            if (newIdx === 0) dir = 1;
            else if (newIdx === newArr.length - 1) dir = -1;
          }
        }
      }

      const nextSt = getNextOnLine(curLine, curSt, dir);
      if (!nextSt) break;

      curSt = nextSt;
      path.push({ line: curLine, st: curSt });
    }

    return path;
  }

  // Result overlay
  const overlay=document.getElementById('resultOverlay');
  const resultStation=document.getElementById('resultStation');
  const resultCount=document.getElementById('resultCount');
  const resultBox=document.getElementById('resultBox');
  const resultCanvas=document.getElementById('resultCanvas');
  const resultCtx=resultCanvas.getContext('2d');

  document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; });
  document.getElementById('searchBtn').addEventListener('click', ()=>{
    const station = (resultStation.textContent || '').trim(); // includes 'Ïó≠'
    const query = encodeURIComponent(station + " Îç∞Ïù¥Ìä∏ÏΩîÏä§");
    window.open("https://search.naver.com/search.naver?query=" + query, "_blank");
  });

  function showResultOverlay(stationName,totalMoved){
    // memory: record the moment the result is shown
    try{ window.__lastResultAt = new Date().toISOString(); }catch(e){}
    resultStation.textContent = formatStation(stationName);
    
    try{ window.__lastDestStation = formatStation(stationName); }catch(e){}
if(typeof totalMoved === 'number' && isFinite(totalMoved)){
      resultCount.textContent = 'Ï¥ù ' + totalMoved + 'Ï†ïÍ±∞Ïû• Ïù¥Îèô';
    } else {
      resultCount.textContent = '';
      // Ï∞êÎûúÎç§ Î™®ÎìúÏóêÏÑúÎäî Ï†ïÍ±∞Ïû• ÏàòÎ•º ÌëúÏãúÌïòÏßÄ ÏïäÏùå
    }
    overlay.style.display='flex';
    const dims = resizeCanvasTo(resultBox, resultCanvas, resultCtx);
    burstConfettiOn(resultCanvas, resultCtx, dims.w, dims.h);
    playFanfare();
  }

  // Init
  const startInput=document.getElementById('startInput');
  const goBtn=document.getElementById('goBtn');

  try{ localStorage.removeItem(LAST_STATION_KEY); }catch(e){}
  let currentStation = (allStations.includes(DEFAULT_FIRST_STATION) ? DEFAULT_FIRST_STATION : (allStations[0] || DEFAULT_FIRST_STATION));
let currentLine = getLinesOf(currentStation)[0] || lineNames[0];
  startInput.value=currentStation;
  // Force initial dead-center on the person token.
  setTokenAt(currentLine,currentStation,false);
    try{ snapCameraToTokenNow(); }catch(e){}
  // Ensure initial camera is centered on token (after layout settles)
  requestAnimationFrame(()=>requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} }));

  scheduleInitialCenter();
  hudLine1.textContent=formatStation(currentStation);
  hudLine2.textContent='Ïù¥Îèô: 0Ï†ïÍ±∞Ïû•';
  let animating=false;

  // --- Transfer SFX (loop while transferring) ---
  let isTransferring = false;
  let audioPrimed = false;
  const sfxTransfer = document.getElementById('sfxTransfer');
  if(sfxTransfer){
    try{ sfxTransfer.src = TRANSFER_SFX_URL; sfxTransfer.load(); }catch(e){}
    try{ sfxTransfer.volume = 0.0045 * volTransfer(); }catch(e){}
    try{ sfxTransfer.muted = false; }catch(e){}
  }
  if(sfxTransfer){
    sfxTransfer.loop = false;
    sfxTransfer.volume = 0.0045 * volTransfer();
    sfxTransfer.preload = 'auto';
  }

  function primeAudio(){
    // iOS: unlock audio on first user gesture
    if(audioPrimed) return;
    if(!sfxTransfer) { audioPrimed = true; return; }

  // Warm up UI click wav (iOS unlock)
  try{
    const a = getUiClickAudio();
    if(a){
      // small trick: call load + a short play/pause attempt
      a.load();
      const p = a.play();
      if(p && p.then){
        p.then(()=>{ try{ a.pause(); a.currentTime = 0; }catch(_e){} }).catch(()=>{});
      }
    }
  }catch(_e){}
    audioPrimed = true;
    try{
      sfxTransfer.pause();
      sfxTransfer.currentTime = 0;
      sfxTransfer.muted = true;
      const p = sfxTransfer.play();
      // once a play is allowed, immediately stop and unmute
      Promise.resolve(p).then(()=>{
        try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
        sfxTransfer.muted = false;
      }).catch(()=>{
        // even if it fails, keep unmuted; future plays after gesture may work
        sfxTransfer.muted = false;
      });
    }catch(e){
      try{ sfxTransfer.muted = false; }catch(_e){}
    }

  // Also prime WebAudio so iOS volume control via GainNode is guaranteed
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC && !audioCtx) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.0045 * volTransfer();
      // kick off decode early
      if(!transferBuffer) loadTransferBuffer();
    }
  }catch(e){}
}

  // --- audio resume notice (reuse error toast style) ---
  function showResumeNotice(){ /* disabled */ }
  function hideResumeNotice(){ /* disabled */ }

// --- iOS background/foreground audio resume fix ---
  // iOS Safari/WebView may suspend or silently drop audio when the page is backgrounded.
  // When returning, sound can stay silent until a new user gesture.
  // We show a small notice (only when likely needed) and arm a one-time resume on the next touch/pointer.
  let _resumeArmed = false;
  let _bgAt = 0;

  function armAudioResumeOnNextGesture(){
    if(_resumeArmed) return;
    _resumeArmed = true;
    const resume = ()=>{
      _resumeArmed = false;
      try{ hideResumeNotice(); }catch(e){}

      // Try hard to re-unlock audio on iOS after background.
      // 1) Resume (or recreate) AudioContext
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(AC && !audioCtx) audioCtx = new AC();
        if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
      }catch(e){}

      // 2) Prime HTMLAudio elements again (iOS can drop the media pipeline after long background)
      try{
        if(sfxTransfer){
          try{ sfxTransfer.pause(); }catch(e){}
          try{ sfxTransfer.currentTime = 0; }catch(e){}
          // Reload helps after long background
          try{ sfxTransfer.load(); }catch(e){}
          // A short play attempt (muted) can re-unlock
          try{
            const prevMuted = sfxTransfer.muted;
            sfxTransfer.muted = true;
            const pp = sfxTransfer.play();
            Promise.resolve(pp).then(()=>{
              try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
              sfxTransfer.muted = prevMuted;
            }).catch(()=>{ sfxTransfer.muted = prevMuted; });
          }catch(e){}
        }
      }catch(e){}

      // 3) Prime once more if needed
      try{ if(!audioPrimed){ primeAudio(); } }catch(e){}

      // If a transfer SFX was in progress when we backgrounded, restart it.
      try{ if(isTransferring){ startTransferSound(); } }catch(e){}
    };
    const opts = { once:true, capture:true, passive:true };
    document.addEventListener('pointerdown', resume, opts);
    document.addEventListener('touchstart', resume, opts);
    document.addEventListener('mousedown', resume, opts);
  }

  function onAppForeground(bgMs){
    // bgMs: how long we were in background (ms)
    let shouldShow = false;
    try{
      // If AudioContext is actually suspended, we definitely need a touch.
      if(audioCtx && audioCtx.state === 'suspended') shouldShow = true;
    }catch(e){}

    // Some iOS cases keep audioCtx 'running' but audio is still muted after long background.
    // If we were away for a while and the app is/was playing movement SFX, prompt a touch anyway.
    try{
      // After a long background (e.g., watching a video), iOS may drop audio even if AudioContext isn't 'suspended'.
      // In that case, always prompt for a single touch to re-unlock audio.
      if(!shouldShow && bgMs && bgMs >= 8000) shouldShow = true;
    }catch(e){}

    if(shouldShow){
      try{ showResumeNotice(); }catch(e){}
    }
    try{ armAudioResumeOnNextGesture(); }catch(e){}
  }

  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      _bgAt = Date.now();
    }else{
      const bgMs = _bgAt ? (Date.now() - _bgAt) : 0;
      _bgAt = 0;
      onAppForeground(bgMs);
    }
  });
  window.addEventListener('pageshow', ()=>{ onAppForeground(9000); });


  function startTransferSound(){
  if(!sfxTransfer) return;
  if(!audioPrimed) primeAudio();

  isTransferring = true;

  
  try{ applyTransferGain(); }catch(e){}
// Ensure WebAudio volume path exists (works reliably on iOS)
  let usingWebAudio = false;
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx && AC) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }

    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.0045 * volTransfer();
      usingWebAudio = true;
      // Kick off preload (don't await)
      try{ if(!transferBuffer) loadTransferBuffer(); }catch(e){}
    }
  }catch(e){}

  // Preferred: play decoded AudioBuffer from time 0 every time (no Safari currentTime quirks)
  if(usingWebAudio && transferBuffer){
    try{
      // stop any previous one-shot immediately
      try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
      transferOneShot = audioCtx.createBufferSource();
      transferOneShot.buffer = transferBuffer;
      transferOneShot.connect(transferGain);
      transferOneShot.start(0);
      transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
      return;
    }catch(e){
      // fall through to <audio> fallback
    }
  }



  // If WebAudio is available but the buffer isn't decoded yet, wait and then play (avoid iOS <audio> volume quirks)
  if(usingWebAudio && !transferBuffer){
    try{
      loadTransferBuffer().then(()=>{
        try{
          if(!isTransferring) return;
          if(!audioCtx || !transferGain || !transferBuffer) return;
          try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
          transferOneShot = audioCtx.createBufferSource();
          transferOneShot.buffer = transferBuffer;
          transferOneShot.connect(transferGain);
          transferOneShot.start(0);
          transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
        }catch(e){}
      });
      return;
    }catch(e){}
  }
  // Fallback: <audio> element restart (only when WebAudio isn't available)
  if(usingWebAudio){ return; }

  // Fallback: <audio> element restart (less reliable on iOS, but better than silence)
  try{
    // If WebAudio isn't in use, apply element volume
    if(!usingWebAudio){ try{ sfxTransfer.volume = 0.0045 * volTransfer(); }catch(e){} }

    sfxTransfer.muted = false;
    try{ sfxTransfer.loop = false; }catch(e){}
    try{ sfxTransfer.pause(); }catch(e){}

    const doPlay = ()=>{
      try{
        const p = sfxTransfer.play();
        if(p && p.catch) p.catch(()=>{});
      }catch(e){}
    };

    try{
      const onSeeked = ()=>{ doPlay(); };
      sfxTransfer.addEventListener('seeked', onSeeked, { once:true });
      try{ sfxTransfer.currentTime = 0; }catch(e){}
      setTimeout(doPlay, 100);
    }catch(e){
      try{ sfxTransfer.currentTime = 0; }catch(_){}
      doPlay();
    }
  }catch(e){}
}

  function stopTransferSound(){
  if(!sfxTransfer) return;
  isTransferring = false;

  // Stop WebAudio one-shot if used
  try{
    if(transferOneShot){
      try{ transferOneShot.stop(0); }catch(e){}
      transferOneShot = null;
    }
  }catch(e){}

  // Also stop <audio> fallback (harmless if not used)
  try{
    try{ sfxTransfer.loop = false; }catch(e){}
    sfxTransfer.pause();
    try{ sfxTransfer.currentTime = 0; }catch(e){}
  }catch(e){}
}
  
  // === Audio UI ===
  const audioBtn = document.getElementById('audioBtn');

  // Block all background interactions while any overlay is open
  const modalBlocker = document.getElementById('modalBlocker');
  if(modalBlocker){
    ['pointerdown','touchstart','touchmove','click'].forEach(ev=>{
      modalBlocker.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
    });
  }

  const audioOverlay = document.getElementById('audioOverlay');
  const audioBackdrop = document.getElementById('audioBackdrop');
  const audioCloseBtn = document.getElementById('audioCloseBtn');

  const volMoveRange = document.getElementById('volMoveRange');
  const volTransferRange = document.getElementById('volTransferRange');
  const volArriveRange = document.getElementById('volArriveRange');
  const volUiRange = document.getElementById('volUiRange');
  const audioMuteBtn = document.getElementById('audioMuteBtn');
  const audioResetBtn = document.getElementById('audioResetBtn');

  function syncAudioUI(){
    if(volMoveRange) volMoveRange.value = String(volMovePct);
    if(volTransferRange) volTransferRange.value = String(volTransferPct);
    if(volArriveRange) volArriveRange.value = String(volArrivePct);
    if(volUiRange) volUiRange.value = String(volUiPct);
    // keep icons stable; muted state is stored, no extra text
    try{ audioMuteBtn.style.opacity = isMuted ? '0.75' : '1'; }catch(e){}
  }


  function setOverlayState(isOpen){
    const open = !!isOpen;
    document.body.classList.toggle('overlayOpen', open);

    // Robust scroll lock (iOS-safe): freeze body at current scroll position
    const root = document.documentElement;
    const body = document.body;
    if(open){
      const y = window.scrollY || root.scrollTop || 0;
      body.dataset.scrollY = String(y);
      body.style.position = 'fixed';
      body.style.top = `-${y}px`;
      body.style.left = '0';
      body.style.right = '0';
      body.style.width = '100%';
      body.style.overflow = 'hidden';
      root.style.overflow = 'hidden';
    }else{
      const y = parseInt(body.dataset.scrollY || '0', 10) || 0;
      body.style.position = '';
      body.style.top = '';
      body.style.left = '';
      body.style.right = '';
      body.style.width = '';
      body.style.overflow = '';
      root.style.overflow = '';
      try{ delete body.dataset.scrollY; }catch(e){}
      window.scrollTo(0, y);
    }

    const mb = document.getElementById('modalBlocker');
    if(mb) mb.setAttribute('aria-hidden', open ? 'false' : 'true');
  }

  
  // Extra safety: prevent background scroll/drag on iOS while overlays are open
  // BUT allow gestures inside overlays (e.g., dragging range sliders)
  document.addEventListener('touchmove', (e)=>{
    if(!document.body.classList.contains('overlayOpen')) return;
    const t = e.target;
    const inOverlay = !!(t && (t.closest && (t.closest('#audioOverlay') || t.closest('#settingsOverlay') || t.closest('#archiveOverlay') || t.closest('#memoryOverlay'))));
    if(inOverlay) return; // allow slider drag, scrolling inside overlay content if any
    e.preventDefault();
  }, {passive:false});

  function openAudio(){
    if(!audioOverlay) return;
    syncAudioUI();
    audioOverlay.classList.add('show');
    setOverlayState(true);
    audioOverlay.setAttribute('aria-hidden','false');
  }
  function closeAudio(){
    if(!audioOverlay) return;
    audioOverlay.classList.remove('show');
    setOverlayState(false);
    audioOverlay.setAttribute('aria-hidden','true');
  }

  function previewMove(){ try{ playMoveTick(); }catch(e){} }
  function previewArrive(){ try{ playFanfare(); }catch(e){} }
  function previewTransfer(){
    try{
      startTransferSound();
      setTimeout(()=>{ try{ stopTransferSound(); }catch(e){} }, 220);
    }catch(e){}
  }

  function onRangeCommit(kind){
    saveSoundSettings();
    // apply transfer gain immediately if it is currently active
    if(kind==='transfer'){ applyTransferGain(); }
    // preview once on release/change
    if(kind==='move') previewMove();
    else if(kind==='transfer') previewTransfer();
    else if(kind==='arrive') previewArrive();
  }

  if(audioBtn){
    audioBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); });
    audioBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); }, {passive:false});
  }
  if(audioBackdrop){
    audioBackdrop.addEventListener('click', closeAudio);
  }
  if(audioCloseBtn){
    audioCloseBtn.addEventListener('click', closeAudio);
  }

  if(audioMuteBtn){
    audioMuteBtn.addEventListener('click', ()=>{ try{ playTick(); }catch(e){}
      isMuted = !isMuted;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
    });
  }

  if(audioResetBtn){
    audioResetBtn.addEventListener('click', ()=>{
      isMuted = false;
      volMovePct = 600;
      volTransferPct = 2500;
      volArrivePct = 400;
      volUiPct = 2500;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
      // preview a tiny ding so user knows it worked
      try{ playDing(); }catch(e){}
    });
  }

  
  // === Slider live preview (throttled) ===
  const __previewLast = { move:0, transfer:0, arrive:0, ui:0 };
  function previewThrottle(kind, fn){
    const now = Date.now();
    if(now - (__previewLast[kind]||0) < 130) return;
    __previewLast[kind] = now;
    try{ fn(); }catch(e){}
  }

  
if(volMoveRange){
    volMoveRange.addEventListener('input', ()=>{
      volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 1200);
      // no preview while dragging
    });
    volMoveRange.addEventListener('change', ()=>{
      volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 1200);
      onRangeCommit('move'); // preview once on release
    });
  }

  
if(volTransferRange){
    volTransferRange.addEventListener('input', ()=>{
      volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000);
      // no preview while dragging (prevents spam + lag)
      applyTransferGain();
    });
    volTransferRange.addEventListener('change', ()=>{
      volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000);
      onRangeCommit('transfer'); // preview once on release
    });
  }

  
if(volArriveRange){
    volArriveRange.addEventListener('input', ()=>{
      volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 800);
      // no preview while dragging
    });
    volArriveRange.addEventListener('change', ()=>{
      volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 800);
      onRangeCommit('arrive'); // preview once on release
    });
  }

  if(volUiRange){
    volUiRange.addEventListener('input', ()=>{
      volUiPct = clamp(parseInt(volUiRange.value,10)||0, 0, 5000);
      // ÏõÄÏßÅÏù¥Îäî ÎèôÏïàÏóêÎäî ÎØ∏Î¶¨Îì£Í∏∞ Ïû¨ÏÉùÌïòÏßÄ ÏïäÏùå
    });
    volUiRange.addEventListener('change', ()=>{
      volUiPct = clamp(parseInt(volUiRange.value,10)||0, 0, 5000);
      saveSoundSettings();
      // ÏÜêÏùÑ ÎÜìÏùÑ Îïå 1Î≤à Îçî ÌôïÏã§Ìûà
      try{ playUiClickSfx(); }catch(e){}
      syncAudioUI();
    });
  }

// Initial UI sync (values already loaded)
  syncAudioUI();

  // === Memories (timestamp-only + places + memo) ===
  const MEM_KEY = "jesong_memories_v3";
  // === PIN (6-digit) ===
  const PIN_HASH_KEY = "jesong_pin_hash";
  const PIN_SALT_KEY = "jesong_pin_salt";
  const PIN_UNLOCK_UNTIL_KEY = "jesong_pin_unlocked_until"; // sessionStorage
  const PIN_SESSION_KEY = "jesong_pin_session"; // sessionStorage (temporary, for gated actions)
  // attempt throttling
  const PIN_FAIL_KEY = "jesong_pin_fail_count";
  const PIN_LOCK_KEY = "jesong_pin_lock_until";
  const PIN_IMPORT_FAIL_KEY = "jesong_import_fail_count";
  const PIN_IMPORT_LOCK_KEY = "jesong_import_lock_until";

  const pinOverlay = document.getElementById("pinOverlay");
  const pinBackdrop = document.getElementById("pinBackdrop");
  const pinTitleEl = document.getElementById("pinTitle");
  const pinSubEl = document.getElementById("pinSub");
  const pinAltCancel = document.getElementById("pinAltCancel");
  const pinAltOk = document.getElementById("pinAltOk");
  const pinDots = Array.from(document.querySelectorAll("[data-pin-dot]"));
  const pinPad = document.getElementById("pinPad");

  function getPinHash(){ try{ return localStorage.getItem(PIN_HASH_KEY) || ""; }catch(e){ return ""; } }
  function getPinSalt(){ try{ return localStorage.getItem(PIN_SALT_KEY) || ""; }catch(e){ return ""; } }
  function setPinSalt(v){ try{ localStorage.setItem(PIN_SALT_KEY, v); }catch(e){} }
  function setPinHash(v){
    try{ localStorage.setItem(PIN_HASH_KEY, v); }catch(e){}
  }

  // === Archive Code (per-memory, permanent) ===
  // Code is an immutable identifier issued on FIRST creation of an archive.
  // Password changes must NOT change this code.
  function genArchiveCode(){
    // 100 chars, immutable archive identifier (independent from memo/places/password)
    // avoid ambiguous chars (0/O, 1/I)
    const alphabet = '23456789ABCDEFGHJKLMNPQRSTUVWXYZ';
    let out = '';
    const a = new Uint8Array(100);
    try{ crypto.getRandomValues(a); }catch(e){ /* ignore */ }
    for(let i=0;i<100;i++){
      const n = a[i] || Math.floor(Math.random()*256);
      out += alphabet[n % alphabet.length];
    }
    return out;
  }

  
  // === Share Code (cross-device, password-based) ===
  // NOTE:
  // - archiveCode (100 chars) is an immutable ID issued once at archive creation (independent of text and PIN changes)
  // - shareCode is a transport blob for moving an archive to another device WITHOUT a server.
  // - shareCode is generated from the CURRENT archive data + CURRENT 6-digit PIN.
  //   Therefore, if the PIN changes, previously generated shareCodes will no longer open with the new PIN (by design).
  // - Import ALWAYS creates a NEW archive entry on this device.

  function __b64urlFromBytes(bytes){
    let bin = '';
    for(let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
    const b64 = btoa(bin);
    return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function __bytesFromB64url(b64url){
    const b64 = String(b64url||'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = (4 - (b64.length % 4)) % 4;
    const bin = atob(b64 + '='.repeat(pad));
    const out = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out;
  }
  async function __deriveAesKeyFromPin(pin, saltBytes){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      enc.encode(String(pin)),
      {name:'PBKDF2'},
      false,
      ['deriveKey']
    );
    return crypto.subtle.deriveKey(
      {name:'PBKDF2', salt:saltBytes, iterations:150000, hash:'SHA-256'},
      keyMaterial,
      {name:'AES-GCM', length:256},
      false,
      ['encrypt','decrypt']
    );
  }
  async function buildShareCodeFromRec(rec, pin){
    if(!window.crypto || !crypto.subtle) throw new Error('nocrypto');

    const payload = {
      schema: 1,
      resultAt: rec && rec.resultAt ? String(rec.resultAt) : null,
      dest: rec && rec.dest ? String(rec.dest) : '',
      places: rec && rec.places ? String(rec.places) : '',
      memo: rec && rec.memo ? String(rec.memo) : '',
      originArchiveCode: rec && rec.archiveCode ? String(rec.archiveCode) : null,
      originCreatedAt: rec && rec.createdAt ? String(rec.createdAt) : null
    };

    const pt = new TextEncoder().encode(JSON.stringify(payload));
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await __deriveAesKeyFromPin(pin, salt);
    const ctBuf = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, pt);
    const ct = new Uint8Array(ctBuf);

    const pack = {v:1, s:__b64urlFromBytes(salt), i:__b64urlFromBytes(iv), c:__b64urlFromBytes(ct)};
    // Wrap once more so users can safely copy as a single token (no JSON braces)
    const token = __b64urlFromBytes(new TextEncoder().encode(JSON.stringify(pack)));
    return 'JSG1.' + token;
  }
  async function parseShareCodeToPayload(shareCode, pin){
    if(!window.crypto || !crypto.subtle) throw new Error('nocrypto');
    let raw = String(shareCode||'').trim();
    if(raw.startsWith('JSG1.')) raw = raw.slice(5);

    const packStr = new TextDecoder().decode(__bytesFromB64url(raw));
    const pack = JSON.parse(packStr);
    if(!pack || pack.v !== 1) throw new Error('badcode');

    const salt = __bytesFromB64url(pack.s);
    const iv = __bytesFromB64url(pack.i);
    const ct = __bytesFromB64url(pack.c);

    const key = await __deriveAesKeyFromPin(pin, salt);
    const ptBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
    const payloadStr = new TextDecoder().decode(new Uint8Array(ptBuf));
    return JSON.parse(payloadStr);
  }

  // === Share Vault (100-char code -> encrypted payload stored locally) ===
  // Î™©Ï†Å: ÌôîÎ©¥Ïóê ÌëúÏãú/Î≥µÏÇ¨ÎêòÎäî Í≥µÏú†ÏΩîÎìúÎäî Ìï≠ÏÉÅ 100ÏûêÎ¶¨(archiveCode)Î°ú Í≥†Ï†ï.
  // Ïã§Ï†ú Ï†ÑÏÜ° Îç∞Ïù¥ÌÑ∞(payload)Îäî Ïù¥ Í∏∞Í∏∞Ïùò localStorageÏóê ÏïîÌò∏Ìôî Î≥¥Í¥ÄÎêúÎã§.
  // ‚Äª Îã§Î•∏ Í∏∞Í∏∞ÏóêÏÑú "ÏßÑÏßúÎ°ú" Í∞ÄÏ†∏Ïò§Î†§Î©¥, Í∏∞Ï°¥ Î∞©Ïãù(JSG1.Î°ú ÏãúÏûëÌïòÎäî Ï†ÑÏ≤¥ ÏΩîÎìú)ÎèÑ Í≥ÑÏÜç ÏßÄÏõêÌïúÎã§.
  const SHARE_VAULT_KEY = "jesong_share_vault_v1"; // { [archiveCode]: shareCodeToken(JSG1....) }

  function __vaultLoad(){
    try{
      const o = JSON.parse(localStorage.getItem(SHARE_VAULT_KEY) || "{}");
      return (o && typeof o === "object") ? o : {};
    }catch(e){ return {}; }
  }
  function __vaultSave(o){
    try{ localStorage.setItem(SHARE_VAULT_KEY, JSON.stringify(o||{})); }catch(e){}
  }
  async function __vaultUpsertFromRec(rec, pin){
    try{
      if(!rec || !rec.archiveCode) return;
      const token = await buildShareCodeFromRec(rec, String(pin||""));
      const v = __vaultLoad();
      v[String(rec.archiveCode)] = String(token);
      __vaultSave(v);
    }catch(e){}
  }
  function __vaultGetToken(archiveCode){
    try{
      const v = __vaultLoad();
      return v ? v[String(archiveCode||"")] : null;
    }catch(e){ return null; }
  }


function isUnlocked(){
    try{
      const until = parseInt(sessionStorage.getItem(PIN_UNLOCK_UNTIL_KEY) || "0", 10);
      return Date.now() < until;
    }catch(e){ return false; }
  }
  function markUnlocked(minutes){
    try{
      const ms = (minutes||10) * 60 * 1000;
      sessionStorage.setItem(PIN_UNLOCK_UNTIL_KEY, String(Date.now() + ms));
    }catch(e){}
  }
  function clearUnlocked(){
    try{ sessionStorage.removeItem(PIN_UNLOCK_UNTIL_KEY); }catch(e){}
    try{ sessionStorage.removeItem(PIN_SESSION_KEY); }catch(e){}
  }
  function setSessionPin(pin){
    try{ sessionStorage.setItem(PIN_SESSION_KEY, String(pin)); }catch(e){}
  }
  function getSessionPin(){
    try{ return sessionStorage.getItem(PIN_SESSION_KEY); }catch(e){ return null; }
  }
  function clearSessionPin(){
    try{ sessionStorage.removeItem(PIN_SESSION_KEY); }catch(e){}
  }

  function _lockInfo(lockKey){
    try{
      const until = parseInt(localStorage.getItem(lockKey)||"0",10)||0;
      return { until, now: Date.now(), remainMs: Math.max(0, until - Date.now()) };
    }catch(e){ return { until:0, now:Date.now(), remainMs:0 }; }
  }
  function isLocked(lockKey){
    const info=_lockInfo(lockKey);
    return info.remainMs>0;
  }
  function lockRemainingSec(lockKey){
    return Math.ceil(_lockInfo(lockKey).remainMs/1000);
  }
  function recordFail(failKey, lockKey){
    let n=0;
    try{ n = parseInt(localStorage.getItem(failKey)||"0",10)||0; }catch(e){}
    n += 1;
    try{ localStorage.setItem(failKey, String(n)); }catch(e){}
    let lockMs = 0;
    if(n >= 12) lockMs = 60*60*1000;      // 1h
    else if(n >= 10) lockMs = 10*60*1000; // 10m
    else if(n >= 8)  lockMs = 2*60*1000;  // 2m
    else if(n >= 5)  lockMs = 30*1000;    // 30s
    if(lockMs>0){
      try{ localStorage.setItem(lockKey, String(Date.now()+lockMs)); }catch(e){}
    }
    return { n, lockMs };
  }
  function clearFail(failKey, lockKey){
    try{ localStorage.removeItem(failKey); }catch(e){}
    try{ localStorage.removeItem(lockKey); }catch(e){}
  }


  async function sha256Hex(str){
    try{
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest("SHA-256", enc);
      const arr = Array.from(new Uint8Array(buf));
      return arr.map(b=>b.toString(16).padStart(2,"0")).join("");
    }catch(e){
      // ultra fallback (not cryptographic) ‚Äî still prevents casual view
      return btoa(unescape(encodeURIComponent(str))).slice(0,64);
    }
  }

  function randomSalt(){
    // 16 bytes hex
    const a = new Uint8Array(16);
    crypto.getRandomValues(a);
    return Array.from(a).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  let __pinMode = "unlock"; // unlock | set1 | set2 | change_verify | change_set1 | change_set2
  let __pinBuf = "";
  let __pinTemp = ""; // for confirm step
  let __pinResolve = null;

  function pinSetDots(n){
    pinDots.forEach((d,i)=>{ d.classList.toggle("filled", i < n); });
  }

  function openPinUI(mode, subText){
    __pinMode = mode;
    __pinBuf = "";
    pinSetDots(0);
    if(pinOverlay){
      pinOverlay.classList.add("show");
      pinOverlay.setAttribute("aria-hidden","false");
      try{ setOverlayState(true); }catch(e){}
    }
    pinTitleEl.textContent = "ÎπÑÎ∞ÄÎ≤àÌò∏";
    pinSubEl.textContent = subText || "";
  }

  function closePinUI(){
    if(pinOverlay){
      pinOverlay.classList.remove("show");
      pinOverlay.setAttribute("aria-hidden","true");
      try{ setOverlayState(false); }catch(e){}
    }
    __pinBuf = "";
    __pinTemp = "";
    pinSetDots(0);
  }

  async function finishPin(success){
    const r = __pinResolve;
    __pinResolve = null;
    if(success){ try{ playDing(); }catch(e){} }
    else { /* no error SFX on cancel */ }
    closePinUI();
    if(r) r(!!success);
  }

  async function verifyCurrentPin(pin){
    const salt = getPinSalt();
    const want = getPinHash();
    if(!salt || !want) return false;
    const got = await sha256Hex(pin + ":" + salt);
    return got === want;
  }

  async function applyNewPin(pin){
    let salt = getPinSalt();
    if(!salt){
      salt = randomSalt();
      setPinSalt(salt);
    }
    const h = await sha256Hex(pin + ":" + salt);
    setPinHash(h);
  }

  async function handlePinComplete(pin){
    const hasPin = !!getPinHash();

    if(__pinMode === "unlock"){
      const ok = await verifyCurrentPin(pin);
      if(ok){
        clearFail(PIN_FAIL_KEY, PIN_LOCK_KEY);
        setSessionPin(pin);
        markUnlocked(30); // 30Î∂Ñ Ïú†ÏßÄ
        return finishPin(true);
      }else{
        const info = recordFail(PIN_FAIL_KEY, PIN_LOCK_KEY);
        if(isLocked(PIN_LOCK_KEY)){
          pinSubEl.textContent = "Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ ("+lockRemainingSec(PIN_LOCK_KEY)+"Ï¥à)";
        }else{
          pinSubEl.textContent = "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÌãÄÎ†∏ÏäµÎãàÎã§ ("+info.n+"Ìöå)";
        }
        __pinBuf = "";
        pinSetDots(0);
        return;
      }
    }

    if(__pinMode === "set1"){
      __pinTemp = pin;
      __pinMode = "set2";
      __pinBuf = "";
      pinSetDots(0);
      pinSubEl.textContent = "Ìïú Î≤à Îçî ÏûÖÎ†•";
      return;
    }

    if(__pinMode === "set2"){
      if(pin !== __pinTemp){
        pinSubEl.textContent = "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§";
        __pinMode = "set1";
        __pinBuf = "";
        __pinTemp = "";
        pinSetDots(0);
        return;
      }
      await applyNewPin(pin);
      // ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω "ÌôïÏ†ï" ÏãúÏ†êÏóêÎßå, Î™®Îì† ÏïÑÏπ¥Ïù¥Î∏åÏùò Í≥µÏú†Ïö© ÏΩîÎìúÎ•º 1Ìöå Í∞±Ïã†
      ;(async ()=>{
        try{
          const __list = memLoad();
          if(!Array.isArray(__list) || !__list.length) return;
          for(let k=0;k<__list.length;k++){
            try{
              // refresh legacy cached shareCode (if used)
              __list[k].shareCode = String(await buildShareCodeFromRec(__list[k], String(pin)));
            }catch(_e){}
            try{
              // refresh 100-char code vault snapshot
              await __vaultUpsertFromRec(__list[k], String(pin));
            }catch(_e){}
          }
          memSave(__list);
        }catch(_e){}
      })();
      clearFail(PIN_FAIL_KEY, PIN_LOCK_KEY);
      setSessionPin(pin);
      markUnlocked(30);
      return finishPin(true);
    }

    if(__pinMode === "change_verify"){
      const ok = await verifyCurrentPin(pin);
      if(!ok){
        pinSubEl.textContent = "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÌãÄÎ†∏ÏäµÎãàÎã§";
        __pinBuf = "";
        pinSetDots(0);
        return;
      }
      __pinMode = "change_set1";
      __pinBuf = "";
      __pinTemp = "";
      pinSetDots(0);
      pinSubEl.textContent = "ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ 6ÏûêÎ¶¨";
      return;
    }

    if(__pinMode === "change_set1"){
      __pinTemp = pin;
      __pinMode = "change_set2";
      __pinBuf = "";
      pinSetDots(0);
      pinSubEl.textContent = "ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ Ìïú Î≤à Îçî";
      return;
    }

    if(__pinMode === "change_set2"){
      if(pin !== __pinTemp){
        pinSubEl.textContent = "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§";
        __pinMode = "change_set1";
        __pinBuf = "";
        __pinTemp = "";
        pinSetDots(0);
        return;
      }
      await applyNewPin(pin);

      // ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ ÌôïÏù∏(ÏùºÏπò) ÏãúÏ†êÏóê Ï¶âÏãú: Î™®Îì† ÏïÑÏπ¥Ïù¥Î∏åÏùò Í≥µÏú† Ïä§ÎÉÖÏÉ∑(=Vault)ÏùÑ ÏÉà ÎπÑÎ≤à Í∏∞Ï§ÄÏúºÎ°ú Í∞±Ïã†
      ;(async ()=>{
        try{
          const __list = memLoad();
          if(!Array.isArray(__list) || !__list.length) return;
          for(let k=0;k<__list.length;k++){
            try{
              __list[k].shareCode = String(await buildShareCodeFromRec(__list[k], String(pin)));
            }catch(_e){}
            try{ await __vaultUpsertFromRec(__list[k], String(pin)); }catch(_e){}
          }
          memSave(__list);
        }catch(_e){}
      })();

      clearFail(PIN_FAIL_KEY, PIN_LOCK_KEY);
      setSessionPin(pin);
      markUnlocked(30);
      return finishPin(true);
    }
  }

  function pinInputDigit(d){
    // throttle for unlock/verify steps
    if((__pinMode === 'unlock' || __pinMode === 'change_verify') && isLocked(PIN_LOCK_KEY)){
      pinSubEl.textContent = 'Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ ('+lockRemainingSec(PIN_LOCK_KEY)+'Ï¥à)';
      return;
    }
    if(__pinBuf.length >= 6) return;
    __pinBuf += d;
    pinSetDots(__pinBuf.length);
    if(__pinBuf.length === 6){
      // slight defer so dot paints first
      setTimeout(()=>{ handlePinComplete(__pinBuf); }, 40);
    }
  }
  function pinBackspace(){
    if(__pinBuf.length<=0) return;
    __pinBuf = __pinBuf.slice(0,-1);
    pinSetDots(__pinBuf.length);
  }

  function pinCancel(){
    finishPin(false);
  }

  if(pinPad){
    pinPad.addEventListener("click", (e)=>{
      const b = e.target.closest("[data-k]");
      if(!b) return;
      const k = b.getAttribute("data-k");
      if(k === "b") return pinBackspace();
      if(k === "c") return pinCancel();
      if(/^\d$/.test(k)) return pinInputDigit(k);
    });
  }
  if(pinBackdrop) pinBackdrop.addEventListener("click", (e)=>{ try{ playTick(); }catch(_e){} pinCancel(); });
  if(pinAltCancel) pinAltCancel.addEventListener("click", pinCancel);
  if(pinAltOk) pinAltOk.addEventListener("click", ()=>{
    // OK Î≤ÑÌäºÏùÄ "Îã´Í∏∞" Ïó≠Ìï†(ÎØ∏ÏôÑÏÑ± ÏûÖÎ†• Ïãú Ïù¥ÎèôÏùå/ÏóêÎü¨Ïùå Í∏àÏßÄ)
    if(__pinBuf.length === 6) return; // 6ÏûêÎ¶¨ ÏôÑÎ£åÎäî ÏûêÎèô Ï≤òÎ¶¨
    try{ closePinUI(); }catch(e){}
    const r = __pinResolve; __pinResolve = null;
    if(r) r(false);
  });

  async function requirePinReady(reason){
    // returns true if allowed to proceed
    const hasPin = !!getPinHash();
    if(hasPin && isUnlocked()) return true;

    return new Promise((resolve)=>{
      __pinResolve = resolve;

      if(!hasPin){
        clearUnlocked();
        openPinUI("set1", "ÎπÑÎ∞ÄÎ≤àÌò∏ 6ÏûêÎ¶¨ ÏÑ§Ï†ï");
      }else{
        openPinUI("unlock", reason || "ÎπÑÎ∞ÄÎ≤àÌò∏ 6ÏûêÎ¶¨ ÏûÖÎ†•");
      }
    });
  }

  async function openChangePinFlow(){
    const hasPin = !!getPinHash();
    if(!hasPin){
      // set directly
      const ok = await requirePinReady("ÎπÑÎ∞ÄÎ≤àÌò∏ 6ÏûêÎ¶¨ ÏÑ§Ï†ï");
      return ok;
    }
    // Need verify first
    const ok = await new Promise((resolve)=>{
      __pinResolve = resolve;
      openPinUI("change_verify", "ÌòÑÏû¨ ÎπÑÎ∞ÄÎ≤àÌò∏ ÏûÖÎ†•");
    });
    return ok;
  }

  function memLoad(){
    try{
      const arr = JSON.parse(localStorage.getItem(MEM_KEY) || "[]");
      // do not persist transient flags from previous builds
      try{ (arr||[]).forEach(r=>{ if(r && typeof r==='object'){ delete r.__codeBusy; } }); }catch(_e){}
      return Array.isArray(arr) ? arr : [];
    }catch(e){
      return [];
    }
  }
  function memSave(list){
    try{ localStorage.setItem(MEM_KEY, JSON.stringify(list)); }catch(e){}
  }
  
  
  // === Share Frame helpers (limit + fit) ===
  function __limitText(s, max){
    s = String(s ?? "");
    if(max && s.length > max) return s.slice(0, Math.max(0, max-1)) + "‚Ä¶";
    return s;
  }

  // Normalize memory fields to avoid overflow in archive/share
  const MEM_MAX = { placesTotal: 120, memo: 240, title: 16, date: 42 };
  function __sanitizePlaces(raw){
    // Î∞©Î¨∏Ìïú Í≥≥: Ï¥ù 150ÏûêÍπåÏßÄÎäî Ï†àÎåÄ '...'Î°ú ÎåÄÏ≤¥ÌïòÏßÄ ÏïäÏùå.
    // (ÏûÖÎ†•/Ï†ÄÏû•/Í≥µÏú† Î™®Îëê ÎèôÏùº Í∑úÏπô)
    let s = String(raw || "");
    s = s.replace(/[\r\n]+/g, " ").replace(/\s+/g, " ").trim();
    if(s.length > MEM_MAX.placesTotal) s = s.slice(0, MEM_MAX.placesTotal);
    return s;
  }
  function __sanitizeMemo(raw){
    // Prevent manual line breaks from breaking the share frame.
    // Convert any CR/LF to a single space, then collapse repeated spaces.
    let s = String(raw||"");
    s = s.replace(/[\r\n]+/g, " ").replace(/\s{2,}/g, " ").trim();
    return __limitText(s, MEM_MAX.memo);
  }
  function __fitText(el, minPx, maxPx){
    if(!el) return;
    let size = maxPx;
    el.style.fontSize = size + "px";
    // shrink until fits
    while(size > minPx && (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight)){
      size -= 2;
      el.style.fontSize = size + "px";
    }
  }

  
function __formatDateDot(iso){
  try{
    const d = new Date(iso);
    if(!isFinite(d.getTime())) return String(iso||"-");
    const y = d.getFullYear();
    const m = d.getMonth()+1;
    const da = d.getDate();
    return `${y}.${m}.${da}.`;
  }catch(e){
    return String(iso||"-");
  }
}


function __formatDateCompact(iso){
  try{
    const d = new Date(iso);
    if(!isFinite(d.getTime())) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return `${y}${m}${da}`;
  }catch(e){ return ""; }
}
function __sanitizeFilePart(s){
  try{
    return String(s||"")
      .trim()
      .replace(/\s+/g,"")
      .replace(/[\\\/:*?"<>|]/g,"")  // Windows/mac invalids
      .replace(/\u0000/g,"")
      .slice(0, 32);
  }catch(e){ return ""; }
}
function __makeCardFileName(destText, dt){
  // destText: "ÎëîÏ¥åÎèôÏó≠" Í∞ôÏùÄ Î¨∏ÏûêÏó¥
  let station = __sanitizeFilePart(destText || "Ïó≠");
  if(!station) station = "Ïó≠";
  let ymd = "";
  try{
    if(dt && isFinite(dt.getTime())) ymd = `${dt.getFullYear()}${String(dt.getMonth()+1).padStart(2,"0")}${String(dt.getDate()).padStart(2,"0")}`;
  }catch(e){}
  if(!ymd){
    try{ ymd = __formatDateCompact(window.__lastResultAt || ""); }catch(e){}
  }
  if(!ymd) ymd = "00000000";
  return `ÎûúÎç§Îç∞Ïù¥Ìä∏_${station}_${ymd}.png`;
}

function escapeHtml(str){
    const s = String(str ?? "");
    return s
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

// === Share Code (encrypted with PIN) ===
  function _b64(bytes){
    return btoa(String.fromCharCode(...bytes));
  }
  function _ub64(b64){
    const bin = atob(b64);
    return Uint8Array.from(bin, c=>c.charCodeAt(0));
  }
  async function _deriveAesKey(pin, saltBytes){
    const enc = new TextEncoder();
    const baseKey = await crypto.subtle.importKey(
      "raw",
      enc.encode(String(pin)),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      {name:"PBKDF2", salt:saltBytes, iterations:100000, hash:"SHA-256"},
      baseKey,
      {name:"AES-GCM", length:256},
      false,
      ["encrypt","decrypt"]
    );
  }
  async function encodeCode(obj, pin){
    const salt = new Uint8Array(16); crypto.getRandomValues(salt);
    const iv = new Uint8Array(12); crypto.getRandomValues(iv);
    const key = await _deriveAesKey(pin, salt);
    const plain = new TextEncoder().encode(JSON.stringify(obj));
    const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, plain);
    const ct = new Uint8Array(ctBuf);
    const pack = {v:1, salt:_b64(salt), iv:_b64(iv), ct:_b64(ct)};
    return btoa(unescape(encodeURIComponent(JSON.stringify(pack))));
  }
  async function _sha256b64(str){
    try{
      const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(String(str||'')));
      const arr = new Uint8Array(buf);
      // b64
      let bin = '';
      for(let i=0;i<arr.length;i++) bin += String.fromCharCode(arr[i]);
      return btoa(bin);
    }catch(e){ return ''; }
  }

  async function decodeCode(code, pin){
    const pack = JSON.parse(decodeURIComponent(escape(atob(code))));
    if(!pack || pack.v!==1) throw new Error("badpack");
    const salt = _ub64(pack.salt);
    const iv = _ub64(pack.iv);
    const ct = _ub64(pack.ct);
    const key = await _deriveAesKey(pin, salt);
    const plainBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return JSON.parse(new TextDecoder().decode(plainBuf));
  }

  const archiveBtn = document.getElementById("archiveBtn");
  const archiveOverlay = document.getElementById("archiveOverlay");
  const archiveBackdrop = document.getElementById("archiveBackdrop");
  const archiveClose = document.getElementById("archiveClose");
  const archiveDeleteSelected = document.getElementById("archiveDeleteSelected");

  const archiveBottomBar = document.querySelector(".archiveBottomBar");
  if(archiveBottomBar){
    archiveBottomBar.addEventListener("click", (e)=>{
      const t = e.target;
      const id = t && t.id ? t.id : "";
      if(id === "archivePinBtn"){
        e.preventDefault();
        try{ openPinChangeFromArchive(); }catch(_e){}
      }
    });
    archiveBottomBar.addEventListener("touchend", (e)=>{
      const t = e.target;
      const id = t && t.id ? t.id : "";
      if(id === "archivePinBtn"){
        e.preventDefault();
        try{ openPinChangeFromArchive(); }catch(_e){}
      }
    }, {passive:false});
  }

  const archiveImportBtn = document.getElementById("archiveImportBtn");

  // === Import modal UI (centered) ===
  const importOverlay = document.getElementById("importOverlay");
  const importBackdrop = document.getElementById("importBackdrop");
  const importCodeEl = document.getElementById("importCode");
  const importPinEl = document.getElementById("importPin");
  const importCancelBtn = document.getElementById("importCancel");
  const importOkBtn = document.getElementById("importOk");

  function openImportModal(){
    if(!importOverlay) return;
    try{ if(importCodeEl) importCodeEl.value = ""; }catch(e){}
    try{ if(importPinEl) importPinEl.value = ""; }catch(e){}
    importOverlay.classList.add("show");
    importOverlay.setAttribute("aria-hidden","false");
    try{ setOverlayState(true); }catch(e){}
    try{ playTick(); }catch(e){}
    setTimeout(()=>{ try{ importCodeEl && importCodeEl.focus(); }catch(e){} }, 30);
  }
  function closeImportModal(){
    if(!importOverlay) return;
    importOverlay.classList.remove("show");
    importOverlay.setAttribute("aria-hidden","true");
    try{ setOverlayState(false); }catch(e){}
  }
  if(importBackdrop) importBackdrop.addEventListener("click", closeImportModal);
  if(importCancelBtn) importCancelBtn.addEventListener("click", closeImportModal);
  const archivePinBtn = document.getElementById("archivePinBtn");
  // Robust tap for 'ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω' (some iOS clicks don't fire inside sticky bars)
  if(archivePinBtn){
    const _go = async (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_e){} try{ await openPinChangeFromArchive(); }catch(_e){} };
    archivePinBtn.addEventListener('pointerup', _go, {passive:false});
    archivePinBtn.addEventListener('touchend', _go, {passive:false});
  }

  const archiveList = document.getElementById("archiveList");

  // === Archive actions: robust tap handler (fix: 'ÏàòÏ†ï/Î≥ÄÍ≤Ω' not clickable on some iOS cases) ===
  (function wireArchiveActionsOnce(){
    if(window.__archiveActionsWired) return;
    window.__archiveActionsWired = true;

    const handler = async (e)=>{
      // Only when archive is open
      try{
        if(!archiveOverlay || !archiveOverlay.classList.contains('show')) return;
      }catch(_e){ return; }

      const btn = e && e.target && e.target.closest ? e.target.closest('button[data-act]') : null;

      if(!btn) return;

      // prevent double-fire per button
      try{
        const now = Date.now();
        const last = Number(btn.dataset.__ts||0);
        if(now-last < 450) return;
        btn.dataset.__ts = String(now);
      }catch(_e){}
      // prevent double-fire (touchend + click)
      try{ e.preventDefault(); }catch(_e){}
      try{ e.stopPropagation(); }catch(_e){}

      const act = btn.getAttribute('data-act');
      const row = btn.closest('.archiveItem');
      const id = row ? (row.dataset.id || '') : '';
      const list = memLoad();
      const rec = list.find(x => String(x.id) === String(id));
      if(!rec) return;

      if(act === 'edit'){
        try{ await openMemoryEdit(rec); }catch(_e){}
        return;
      }

      if(act === 'code'){
        // 'ÏΩîÎìú' Î≤ÑÌäº = Îã§Î•∏ Í∏∞Í∏∞ÏóêÏÑúÎèÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÎäî "Ï†ÑÏ≤¥ Í≥µÏú†ÏΩîÎìú"(JSG1.*)
        const __ok = await requirePinReady('Í≥µÏú†ÏΩîÎìú');
        if(!__ok) return;

        const pin = getSessionPin();
        if(!pin || !/^[0-9]{6}$/.test(String(pin))){
          alert("ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Îã§Ïãú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
          return;
        }

        try{
          const shareCode = await buildShareCodeFromRec(rec, String(pin));
          openCodeModal(String(shareCode));
        }catch(err){
          alert("Í≥µÏú†ÏΩîÎìú ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        }
        return;
      }

      if(act === 'share'){
        // prevent double-run (pointerup + click/touch) causing false failure alerts
        try{
          if(window.__shareBusy && (Date.now()-window.__shareBusy)<900) return;
          window.__shareBusy = Date.now();
          setTimeout(()=>{ try{ window.__shareBusy = 0; }catch(_e){} }, 1100);
        }catch(_e){}

        // trigger existing per-row handler if any; otherwise run minimal share path
        try{
          // reuse the existing click by dispatching a click after preventing defaults is tricky; instead call the same logic here:
          if(typeof html2canvas !== "function"){ alert("Í≥µÏú† Í∏∞Îä• Î°úÎî© Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî."); return; }
          const stage = document.getElementById("shareStage");
          if(!stage) return;

          const dt = rec.resultAt ? new Date(rec.resultAt) : null;
          let timeText = (rec.resultAt || "-");
          if(dt && isFinite(dt.getTime())) timeText = __formatDateDot(rec.resultAt); // date only (no time)

          const destText = rec.dest ? String(rec.dest) : "";
          const placesText = (rec.places && String(rec.places).trim()) ? String(rec.places) : "-";
          const memoText = rec.memo || "";

          stage.innerHTML = "";
          const wrap = document.createElement("div");
          wrap.className = "memFrameWrap";
          wrap.innerHTML = `
            <div class="memFrameCapture" id="memFrameCapture">
              <img class="memFrameImg" src="./memory-frame-final-1080x1920.png" alt="" />
              <div class="memSlot memTitle" id="memTitle">${escapeHtml(__limitText(destText || "-", 16))}</div>
              <div class="memSlot memDate" id="memDate">${escapeHtml(__limitText(timeText || "-", 42))}</div>
              <div class="memSlot memPlaces" id="memPlaces">${escapeHtml(__limitText(placesText || "-", 150))}</div>
              <div class="memSlot memMemo" id="memMemo">${escapeHtml(__limitText(memoText || " ", MEM_MAX.memo)).replace(/\n/g,"<br>")}</div>
            </div>
          `;
          stage.appendChild(wrap);

          try{
            __fitText(document.getElementById("memTitle"), 46, 82);
            __fitText(document.getElementById("memDate"), 30, 38);
            __fitText(document.getElementById("memPlaces"), 32, 32);
            __fitText(document.getElementById("memMemo"), 32, 32);
          }catch(_e){}

          const targetEl = document.getElementById('memFrameCapture') || wrap;
          const canvas = await html2canvas(targetEl, {backgroundColor: null, scale: 1.5, useCORS: true});
          const blob = await new Promise(res=>canvas.toBlob(res, "image/png", 1.0));
          if(!blob){ alert("Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®"); return; }

          const file = new File([blob], __makeCardFileName(destText, dt), {type:"image/png"});
          if(navigator.share && navigator.canShare && navigator.canShare({files:[file]})){
            await navigator.share({ files:[file] });
            return;
          }
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = __makeCardFileName(destText, dt);
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1500);
        }catch(_e){
          alert('Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®');
        }
      }
    };

    // Capture phase avoids scroll/click quirks on iOS
    document.addEventListener('pointerup', handler, {capture:true});
    document.addEventListener('click', handler, {capture:true, passive:false});
    document.addEventListener('touchend', handler, {capture:true, passive:false});
    document.addEventListener('pointerdown', handler, {capture:true});
    document.addEventListener('touchstart', handler, {capture:true, passive:false});
;

    document.addEventListener('click', handler, {capture:true});
    document.addEventListener('touchend', handler, {capture:true, passive:false});
    document.addEventListener('pointerdown', handler, {capture:true});
    document.addEventListener('touchstart', handler, {capture:true, passive:false});
  })();


  
  let __editUid = null;
  let __editId = null;
const memoryOverlay = document.getElementById("memoryOverlay");
  const memoryBackdrop = document.getElementById("memoryBackdrop");
  const memoryWhen = document.getElementById("memoryWhen");
  const memoryPlaces = document.getElementById("memoryPlaces");
  const memoryMemo = document.getElementById("memoryMemo");

  // Memo must be single-line: block Enter and strip any pasted line breaks
  if(memoryMemo){
    const __stripMemoNewlines = ()=>{
      try{
        const v = String(memoryMemo.value||"")
          .replace(/[\r\n]+/g, " ")
          .replace(/\s{2,}/g, " ");
        if(v !== memoryMemo.value) memoryMemo.value = v;
      }catch(e){}
    };
    memoryMemo.addEventListener("keydown", (e)=>{
      if(e && e.key === "Enter"){
        e.preventDefault();
        __stripMemoNewlines();
      }
    });
    memoryMemo.addEventListener("input", __stripMemoNewlines);
    memoryMemo.addEventListener("paste", ()=>setTimeout(__stripMemoNewlines, 0));
    memoryMemo.addEventListener("blur", __stripMemoNewlines);
  }

  const memoryCancel = document.getElementById("memoryCancel");
  const memorySaveBtn = document.getElementById("memorySave");
  const memoryBtnResult = document.getElementById("memoryBtnResult");

  let __savingMemory = false;

  async function openArchive(){
    const __ok = await requirePinReady('Ï∂îÏñµ Î≥¥Í¥ÄÌï® Ïó¥Í∏∞');
    if(!__ok) return;

    if(!archiveOverlay) return;
    renderArchive();
    archiveOverlay.classList.add("show");
    archiveOverlay.setAttribute("aria-hidden","false");
    try{ setOverlayState(true); }catch(e){}
    try{ playTick(); }catch(e){}
  }
  function closeArchive(){
    if(!archiveOverlay) return;
    archiveOverlay.classList.remove("show");
    archiveOverlay.setAttribute("aria-hidden","true");
    try{ setOverlayState(false); }catch(e){}
  }

    function renderArchive(){
    if(!archiveList) return;
    const list = memLoad();
    archiveList.innerHTML = "";
    if(!list.length){
      archiveList.innerHTML = "<div style='padding:18px;font-weight:900;color:#777;'>Ï†ÄÏû•Îêú Ï∂îÏñµÏù¥ ÏóÜÏäµÎãàÎã§</div>";
      return;
    }
    for(const m of list){
      const row = document.createElement("div");
      row.className = "archiveItem";
      row.dataset.id = String(m.id);

      const dt = m.resultAt ? new Date(m.resultAt) : null;
      let timeTextDate = (m.resultAt || "-");
      let timeTextTime = "";
      if(dt && isFinite(dt.getTime())){
        timeTextDate = dt.toLocaleDateString('ko-KR');
        timeTextTime = dt.toLocaleTimeString('ko-KR');
      }
      const destText = m.dest ? String(m.dest) : "";

      row.innerHTML = `
        <input type="checkbox" class="archChk">
        <div class="archiveInfo">
          <div class="date">${escapeHtml(timeTextDate)}</div>
          <div class="time">${escapeHtml(timeTextTime)}</div>
          <div class="dest">${escapeHtml(destText || "-")}</div>
        </div>
        <div class="archiveActions">
          <button type="button" class="archiveBtnGhost" data-act="code">ÏΩîÎìú</button>
          <button type="button" class="archiveBtnGhost" data-act="share">Í≥µÏú†</button>
          <button type="button" class="archiveBtnGhost" data-act="edit">ÏàòÏ†ï</button>
        </div>
      `;
      archiveList.appendChild(row);
    }
  }

  async function openMemory(){
    __editUid = null; __editId = null;
    const __ok = await requirePinReady('Ï∂îÏñµ Í∏∞Î°ù');
    if(!__ok) return;

    if(!memoryOverlay) return;
    const iso = window.__lastResultAt;
    if(!iso){ alert("Î®ºÏ†Ä ÎûúÎç§ Í≤∞Í≥ºÎ•º ÏÉùÏÑ±ÌïòÏÑ∏Ïöî."); return; }
    const dt = new Date(iso);
    memoryWhen.textContent = isFinite(dt.getTime()) ? dt.toLocaleString() : iso;
    memoryPlaces.value = "";
    memoryMemo.value = "";
    memoryOverlay.classList.add("show");
    memoryOverlay.setAttribute("aria-hidden","false");
    try{ setOverlayState(true); }catch(e){}
    try{ playTick(); }catch(e){}
  }
  
  async function openMemoryEdit(rec){
    const __ok = await requirePinReady('Ï∂îÏñµ ÏàòÏ†ï');
    if(!__ok) return;

    if(!memoryOverlay) return;
    __editUid = rec && rec.uid ? String(rec.uid) : null;
    __editId = rec && rec.id ? String(rec.id) : null;

    const iso = rec && rec.resultAt ? String(rec.resultAt) : window.__lastResultAt;
    // ensure save works in edit mode
    try{ window.__lastResultAt = iso; }catch(e){}
    try{ window.__lastDestStation = rec && rec.dest ? String(rec.dest) : (window.__lastDestStation||""); }catch(e){}
    if(!iso){ alert("Í∏∞Î°ù ÏãúÍ∞ÑÏù¥ ÏóÜÏäµÎãàÎã§."); return; }
    const dt = new Date(iso);
    try{ memoryWhen.textContent = isFinite(dt.getTime()) ? dt.toLocaleString() : iso; }catch(e){}
    try{ memoryPlaces.value = (rec && rec.places) ? String(rec.places) : ""; }catch(e){}
    try{ memoryMemo.value = __sanitizeMemo(rec && rec.memo ? String(rec.memo) : ""); }catch(e){}

    memoryOverlay.classList.add("show");
    memoryOverlay.setAttribute("aria-hidden","false");
    try{ setOverlayState(true); }catch(e){}
    try{ playTick(); }catch(e){}
  }
function closeMemory(){
    if(!memoryOverlay) return;
    memoryOverlay.classList.remove("show");
    memoryOverlay.setAttribute("aria-hidden","true");
    try{ setOverlayState(false); }catch(e){}
  }

  if(archiveBtn){
    archiveBtn.addEventListener("click", (e)=>{ e.preventDefault(); openArchive(); });
    archiveBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); openArchive(); }, {passive:false});
  }
  if(archiveBackdrop) archiveBackdrop.addEventListener("click", closeArchive);
  if(archiveClose) archiveClose.addEventListener("click", closeArchive);

  if(memoryBtnResult){
    memoryBtnResult.addEventListener("click", (e)=>{ e.preventDefault(); openMemory(); });
    memoryBtnResult.addEventListener("touchend", (e)=>{ e.preventDefault(); openMemory(); }, {passive:false});
  }
  if(memoryBackdrop) memoryBackdrop.addEventListener("click", closeMemory);
  if(memoryCancel) memoryCancel.addEventListener("click", closeMemory);

  if(memorySaveBtn){
    memorySaveBtn.addEventListener("click", ()=>{
      if(__savingMemory) return;
      __savingMemory = true;
      setTimeout(()=>{ __savingMemory = false; }, 450);

      const iso = window.__lastResultAt;
      if(!iso) return;

      const places = __sanitizePlaces(memoryPlaces.value||"");
      const memo = __sanitizeMemo(memoryMemo.value||"");
      const dest = String(window.__lastDestStation || "").trim();

      const list = memLoad();

      // If editing, preserve existing uid (if any). If not, create one.
      let uidToUse = (__editUid || null);
      if(!uidToUse && __editId){
        const prev = list.find(x => String(x.id) === String(__editId));
        if(prev && prev.uid) uidToUse = String(prev.uid);
      }
      if(!uidToUse){
        uidToUse = (crypto.randomUUID ? crypto.randomUUID() : (Date.now().toString()+Math.random().toString(16).slice(2)));
      }

      const item = {
        id: (__editId || Date.now().toString()),
        uid: uidToUse,
        resultAt: iso,
        dest,
        places,
        memo
      };

      // Preserve issued archiveCode (permanent) + codePayload snapshot used for 'ÏΩîÎìú'
      try{
        const prevRec = (__editUid)
          ? list.find(x => String(x.uid||"") === String(__editUid))
          : (__editId ? list.find(x => String(x.id||"") === String(__editId)) : null);

        if(prevRec){
          if(prevRec.createdAt) item.createdAt = prevRec.createdAt;
          if(prevRec.archiveCode) item.archiveCode = prevRec.archiveCode;
          if(prevRec.codePayload) item.codePayload = prevRec.codePayload;
        }else{
          // New record: freeze the payload that will be used for 'ÏΩîÎìú' forever (even if user edits later)
          item.createdAt = new Date().toISOString();
          item.archiveCode = genArchiveCode();
          item.codePayload = { id:item.id, uid:(item.uid||null), resultAt:item.resultAt, dest:(item.dest||""), places:(item.places||""), memo:(item.memo||"") };
        }
      }catch(_e){}

      if(__editUid){
        const i = list.findIndex(x => String(x.uid||"") === String(__editUid));
        if(i >= 0) list[i] = item;
        else list.unshift(item);
      }else if(__editId){
        const i = list.findIndex(x => String(x.id||"") === String(__editId));
        if(i >= 0) list[i] = item;
        else list.unshift(item);
      }else{
        list.unshift(item);
      }

      memSave(list);
      // Í≥µÏú†Ïö© ÏΩîÎìúÎäî "ÎÇ¥Ïö© Ï†ÄÏû• ÌôïÏù∏" ÏãúÏ†êÏóêÎßå Í∞±Ïã† (ÏûÖÎ†• Ï§ëÏóêÎäî Í∞±Ïã†ÌïòÏßÄ ÏïäÏùå)
      ;(async ()=>{
        try{
          const pin = getSessionPin();
          if(!pin || !/^[0-9]{6}$/.test(String(pin))) return;
          const sc = await buildShareCodeFromRec(item, String(pin));
          item.shareCode = String(sc);
          const __list2 = memLoad();
          const __j = __list2.findIndex(x => String(x.uid||"") === String(item.uid||"") || String(x.id||"") === String(item.id||""));
          if(__j >= 0){
            __list2[__j].shareCode = item.shareCode;
            memSave(__list2);
          }
        }catch(_e){}
      })();
      try{ playDing(); }catch(e){}
      closeMemory();
      __editUid = null; __editId = null;
      try{ renderArchive(); }catch(e){}
    });
  }

  if(archiveDeleteSelected){
    archiveDeleteSelected.addEventListener("click", ()=>{
      const list = memLoad();
      const checkedIds = [...document.querySelectorAll(".archChk")]
        .filter(c=>c.checked)
        .map(c=>c.closest("[data-id]")?.dataset.id)
        .filter(Boolean);
      if(!checkedIds.length) return;
      const remain = list.filter(m => !checkedIds.includes(String(m.id)));
      memSave(remain);
      renderArchive();
      try{ playDing(); }catch(e){}
    });
  }

  if(archiveImportBtn){
    archiveImportBtn.addEventListener("click", async ()=>{
      if(isLocked(PIN_IMPORT_LOCK_KEY)){
        alert("Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ ("+lockRemainingSec(PIN_IMPORT_LOCK_KEY)+"Ï¥à)");
        return;
      }
      openImportModal();
    });
  }

  // ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω (Î≥¥Í¥ÄÌï®)
  async function openPinChangeFromArchive(){
    const ok = await requirePinReady('ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω');
    if(!ok) return;
    await openChangePinFlow();
  }
  if(archivePinBtn){
    archivePinBtn.addEventListener("click", (e)=>{ e.preventDefault(); openPinChangeFromArchive(); });
    archivePinBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); openPinChangeFromArchive(); }, {passive:false});
  }




  
  async function runImportFromModal(){
    const shareCodeRaw = String(importCodeEl && importCodeEl.value ? importCodeEl.value : "").trim();
    const pinStr = String(importPinEl && importPinEl.value ? importPinEl.value : "").trim();
    if(!shareCodeRaw){ alert("Í≥µÏú†ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî."); return; }
    if(!/^[0-9]{6}$/.test(pinStr)){ alert("ÎπÑÎ∞ÄÎ≤àÌò∏Îäî 6ÏûêÎ¶¨ Ïà´Ïûê"); return; }

    // throttle / lockout
    if(isLocked(PIN_IMPORT_LOCK_KEY)){
      alert("Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ ("+lockRemainingSec(PIN_IMPORT_LOCK_KEY)+"Ï¥à)");
      return;
    }

    try{
      // decrypt share code with the PIN the sender used at the time of sharing
      let payload = null;

      // 1) Legacy full share code (can be long): starts with JSG1.
      if(/^JSG1\./.test(shareCodeRaw)){
        payload = await parseShareCodeToPayload(shareCodeRaw, pinStr);
      }
      // 2) New short code (ALWAYS 100 chars): archiveCode only
      else if(/^[23456789ABCDEFGHJKLMNPQRSTUVWXYZ]{100}$/.test(shareCodeRaw)){
        const tok = __vaultGetToken(shareCodeRaw);
        if(!tok) throw new Error("novault");
        payload = await parseShareCodeToPayload(String(tok), pinStr);
      }else{
        throw new Error("badcode");
      }

      // Build a NEW archive on this device (always new)
      const list = memLoad();

      const nowId = Date.now().toString();
      const uidToUse = (crypto.randomUUID ? crypto.randomUUID() : (Date.now().toString()+Math.random().toString(16).slice(2)));

      const dest = String(payload && payload.dest ? payload.dest : "").trim();
      const places = __sanitizePlaces(String(payload && payload.places ? payload.places : ""));
      const memo = __sanitizeMemo(String(payload && payload.memo ? payload.memo : ""));
      const resultAt = String(payload && payload.resultAt ? payload.resultAt : new Date().toISOString());

      const item = { id: nowId, uid: uidToUse, resultAt, dest, places, memo };

      // freeze permanent archiveCode + payload snapshot
      try{
        item.createdAt = new Date().toISOString();
        item.archiveCode = genArchiveCode(); // NEW archive => NEW immutable code
        item.codePayload = { id:item.id, uid:(item.uid||null), resultAt:item.resultAt, dest:(item.dest||""), places:(item.places||""), memo:(item.memo||"") };
        if(payload && payload.originArchiveCode) item.importedFrom = String(payload.originArchiveCode);
      }catch(_e){}

      list.unshift(item);
      memSave(list);

      clearFail(PIN_IMPORT_FAIL_KEY, PIN_IMPORT_LOCK_KEY);
      closeImportModal();
      try{ playDing(); }catch(e){}
      try{ renderArchive(); }catch(e){}
      __toast("Ï∂îÏñµÏùÑ Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.");
    }catch(e){
      const info = recordFail(PIN_IMPORT_FAIL_KEY, PIN_IMPORT_LOCK_KEY);
      if(isLocked(PIN_IMPORT_LOCK_KEY)){
        alert("ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÌãÄÎ†∏ÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ ("+lockRemainingSec(PIN_IMPORT_LOCK_KEY)+"Ï¥à)");
      }else{
        const msg = (e && e.message) ? String(e.message) : "";
        if(msg === "novault"){
          alert("Ïù¥ 100ÏûêÎ¶¨ ÏΩîÎìúÏóê Ìï¥ÎãπÌïòÎäî Îç∞Ïù¥ÌÑ∞Í∞Ä Ïù¥ Í∏∞Í∏∞Ïóê ÏóÜÏäµÎãàÎã§.\n\nÎã§Î•∏ Í∏∞Í∏∞ÏóêÏÑú Í∞ÄÏ†∏Ïò§Î†§Î©¥ JSG1.Î°ú ÏãúÏûëÌïòÎäî Ï†ÑÏ≤¥ Í≥µÏú†ÏΩîÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
        }else if(msg === "badcode"){
          alert("Í≥µÏú†ÏΩîÎìú ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.");
        }else{
          alert("Í≥µÏú†ÏΩîÎìú ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§ ("+info.n+"Ìöå)");
        }
      }
    }
  }
  if(importOkBtn) importOkBtn.addEventListener("click", runImportFromModal);
// Settings UI (min/max stops)
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsBackdrop = document.getElementById('settingsBackdrop');
  const minStopsInputEl = document.getElementById('minStopsInput');
  const maxStopsInputEl = document.getElementById('maxStopsInput');
  const trueRandomToggle = document.getElementById('trueRandomToggle');
  const settingsOk = document.getElementById('settingsOk');
  const settingsCancel = document.getElementById('settingsCancel');

  function updateTrueRandomUI(){
    const on = !!(trueRandomToggle && trueRandomToggle.checked);

    // Fully disable the min/max range controls when True Random is ON
    const stopsRowEl = document.getElementById('stopsRow');
    if(stopsRowEl){
      stopsRowEl.classList.toggle('controlsDisabled', on);
      stopsRowEl.setAttribute('aria-disabled', on ? 'true' : 'false');
    }

    // Also set disabled attributes for accessibility
    [minStopsInputEl, maxStopsInputEl].forEach(el=>{
      if(!el) return;
      el.disabled = on;
      el.style.opacity = on ? '0.45' : '1';
    });
    document.querySelectorAll('.stepBtn').forEach(btn=>{
      if(!btn) return;
      btn.disabled = on;
      btn.style.opacity = on ? '0.35' : '1';
    });

    // Slightly dim the stop row (visual)
    if(stopsRowEl){ stopsRowEl.style.opacity = on ? '0.55' : '1'; }
  }

  function updateStartInputForMode(){
    try{
      if(trueRandomMode){
        startInput.classList.add('trueRandomInput');
        startInput.value = 'Ï∞êÎûúÎç§ Î™®Îìú';
        startInput.setAttribute('readonly','');
        // prevent keyboard / touches
        startInput.style.pointerEvents = 'none';
      }else{
        startInput.classList.remove('trueRandomInput');
        startInput.removeAttribute('readonly');
        startInput.style.pointerEvents = 'auto';
        // restore to last/ current station name
        startInput.value = currentStation || '';
      }
    }catch(e){}
  }

  function clampInt(v, lo, hi){
    v = parseInt(String(v||'').trim(), 10);
    if(!Number.isFinite(v)) return lo;
    return Math.max(lo, Math.min(hi, v));
  }
  function openSettings(){
    if(animating) return;
    minStopsInputEl.value = String(minStops);
    maxStopsInputEl.value = String(maxStops);
    if(trueRandomToggle){
      trueRandomToggle.checked = !!trueRandomMode;
    }
    updateTrueRandomUI();
    settingsOverlay.classList.add('show');
    setOverlayState(true);
    settingsOverlay.setAttribute('aria-hidden','false');
    try{ playTick(); }catch(e){}
    setTimeout(()=>{ try{ (trueRandomMode ? settingsOk : minStopsInputEl).focus(); }catch(e){} }, 40);
  }
  function closeSettings(){
    settingsOverlay.classList.remove('show');
    setOverlayState(false);
    settingsOverlay.setAttribute('aria-hidden','true');
  }
  function applySettings(){
    var minEl = document.getElementById('minStopsInput');
    var maxEl = document.getElementById('maxStopsInput');

    var newMin = parseInt(minEl && minEl.value ? minEl.value : '', 10);
    var newMax = parseInt(maxEl && maxEl.value ? maxEl.value : '', 10);

    if(!isFinite(newMin)) newMin = 6;
    if(!isFinite(newMax)) newMax = 25;

    newMin = Math.min(99, Math.max(1, newMin));
    newMax = Math.min(99, Math.max(1, newMax));

    if(newMax < newMin){
      newMax = newMin;
      if(maxEl) maxEl.value = String(newMax);
    }

    // Save true random toggle
    if(trueRandomToggle){
      trueRandomMode = !!trueRandomToggle.checked;
      try{ localStorage.setItem(TRUE_RANDOM_KEY, trueRandomMode ? '1' : '0'); }catch(e){}
    }

    if(!trueRandomMode){
      minStops = newMin;
      maxStops = newMax;
      try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
      try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
    }

    updateTrueRandomUI();
    updateStartInputForMode();
    closeSettings();
    try{ playDing(); }catch(e){}
  }

  if(settingsBtn){
    settingsBtn.addEventListener('click', openSettings);
    settingsBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); openSettings(); }, {passive:false});
  }
  if(settingsBackdrop){
    settingsBackdrop.addEventListener('click', closeSettings);
  }
  if(settingsCancel){
    settingsCancel.addEventListener('click', closeSettings);
  }
  if(settingsOk){
    settingsOk.addEventListener('click', applySettings);
  }

  if(trueRandomToggle){
    trueRandomToggle.addEventListener('change', ()=>{ try{ playTick(); }catch(e){} try{ const tr=document.getElementById('trueRandomTrack'); if(tr) tr.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} updateTrueRandomUI(); });

    // Make only the switch itself clickable (avoid row-wide label hit areas)
    const trueRandomTrack = document.getElementById('trueRandomTrack');
    const syncSwitchAria = ()=>{ try{ trueRandomTrack.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} };
    syncSwitchAria();
    if(trueRandomTrack){
      trueRandomTrack.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        trueRandomToggle.checked = !trueRandomToggle.checked;
        syncSwitchAria();
        trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
      });
      trueRandomTrack.addEventListener('keydown', (e)=>{
        if(e.key==='Enter' || e.key===' '){
          e.preventDefault();
          trueRandomToggle.checked = !trueRandomToggle.checked;
          syncSwitchAria();
          trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
        }
      });
    }

  }

  // Apply initial mode effects to the start input (after we have UI refs).
  updateStartInputForMode();

  // Step buttons
  document.querySelectorAll('.stepBtn').forEach(btn=>{
    const doStep = ()=>{
      if(btn.disabled) return;
      if(typeof trueRandomMode!=='undefined' && trueRandomMode) return;
      const which = btn.getAttribute('data-step');
      const delta = parseInt(btn.getAttribute('data-delta')||'0',10) || 0;
      if(which === 'min'){
        const next = clampInt(minStopsInputEl.value,1,99) + delta;
        minStopsInputEl.value = String(clampInt(next,1,99));
      } else {
        const next = clampInt(maxStopsInputEl.value,1,99) + delta;
        maxStopsInputEl.value = String(clampInt(next,1,99));
      }
      try{ playTick(); }catch(e){}
    };

    // Prevent double-tap / bubbling into the map viewport
    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); });
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); }, {passive:false});
    btn.addEventListener('dblclick', (e)=>{ e.preventDefault(); });
  });

  // Enter = apply, ESC = close
  settingsOverlay && settingsOverlay.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape') closeSettings();
    if(e.key === 'Enter') applySettings();
  });


  function findStartStation(input){
    const q=normalizeName(input);
    for(const s of allStations) if(normalizeName(s)===q) return s;
    return null;
  }

  async function animatePath(path){
    let moved=0;
    for(let i=0;i<path.length;i++){
      const cur=path[i];
      hudLine1.textContent=formatStation(cur.st);
      hudLine2.textContent='Ïù¥Îèô: '+moved+'Ï†ïÍ±∞Ïû•';
      if(i===0){
        // Teleport to start: snap camera immediately so it follows from the first segment
        setTokenAt(cur.line,cur.st,false);
        try{ snapCameraToTokenNow(); }catch(e){}
        await sleep(180);
        continue;
      }
      const prev=path[i-1];
            if(prev.line !== cur.line){ startTransferSound(); }
      await moveSegment(prev.line,prev.st,cur.line,cur.st);
      if(prev.line !== cur.line){ stopTransferSound(); }

      // Count only actual station-to-station moves. Transfers at the same station do NOT count as a stop.
      if(prev.st !== cur.st){
        moved++;
      }
      hudLine2.textContent='Ïù¥Îèô: '+moved+'Ï†ïÍ±∞Ïû•';

      playMoveTick();
      await sleep(160);
      const remain=(path.length-1)-i;
      const t=Math.max(0,6-remain);
      const jitter=Math.floor(Math.random()*180);
      const curve=t===0 ? 1 : (1 + 0.14*t*t);
      let ms=(380 + jitter)*curve;
      if(remain<=2) ms += 260;
      await sleep(ms);
    }
    return moved;
  }

  async function trueRandomWarpTo(destStation){
    // Warp around randomly for a fixed duration, then stop at destination.
    // NOTE: This is purely for fun (Ï∞êÎûúÎç§), so it doesn't follow line order.
    const DURATION_MS = 16500; // Ï¥ù 16.5Ï¥à ÏõåÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖò (Ï™ºÎäîÎßõ ÏûàÍ≤å Ï°∞Í∏à Îçî Í∏∏Í≤å)
    const WARPS = 24;          // Ï†êÌîÑ ÌöüÏàò (ÎÑàÎ¨¥ ÎπΩÎπΩÌïòÏßÄ ÏïäÍ≤å)

    // Create a slowdown schedule whose intervals sum to DURATION_MS.
    // Start fast, end slow (quadratic ease-out style).
    const minInterval = 160;
    const maxInterval = 1150;
    const raw = [];
    let rawSum = 0;
    for(let i=0;i<WARPS;i++){
      const t = (WARPS<=1) ? 1 : (i/(WARPS-1));
      const e = Math.pow(t, 1.7); // Î∂ÄÎìúÎü¨Ïö¥ Í∞êÏÜç (Ï¥àÎ∞ò ÎÑàÎ¨¥ Îπ†Î•∏ ÏõåÌîÑ Î∞©ÏßÄ)
      const v = minInterval + (maxInterval - minInterval) * e;
      raw.push(v);
      rawSum += v;
    }
    const scale = DURATION_MS / rawSum;

    for(let i=0;i<WARPS;i++){
      const isLast = (i === WARPS-1);
      // pick a random station (avoid dest until the very last warp)
      let st = destStation;
      if(!isLast){
        for(let tries=0; tries<10; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== destStation){ st = cand; break; }
        }
      }

      const lines = getLinesOf(st);
      const ln = lines.length ? lines[Math.floor(Math.random()*lines.length)] : (lineNames[0]||'');
      setTokenAt(ln, st, false);
      
      try{ playMoveTick(); }catch(e){}
// Keep station name updating (including final stop). Only the 2nd line stays uniform.
      hudLine1.textContent = formatStation(st);
      hudLine2.textContent = 'ÏõåÌîÑÏ§ë..';
      try{ playTick(); }catch(e){}

      // scaled interval + tiny randomness (kept small so total stays ~16.5s)
      const jitter = isLast ? 0 : (Math.random()*40);
      const delay = Math.max(20, Math.floor(raw[i] * scale + jitter));
      await sleep(delay);
    }

    // Ensure camera is centered once we land.
    try{ snapCameraToTokenNow(); }catch(e){}
    // ÏÇ¥Ïßù Ï†ïÏ∞©ÌïòÎäî ÎäêÎÇå
    await sleep(180);
  }

  async function finale(targetStation,totalMoved){
    // Keep HUD consistent at arrival (no 'ÏõåÌîÑÏ§ë..' flash).
    try{ hudLine1.textContent = formatStation(targetStation); }catch(e){}
    try{
      if(typeof totalMoved === 'number'){
        hudLine2.textContent = 'Ïù¥Îèô: ' + totalMoved + 'Ï†ïÍ±∞Ïû•';
      } else {
        hudLine2.textContent = 'ÏõåÌîÑÏ§ë..';
      }
    }catch(e){}
    stopTransferSound();
    playDing();
    const dims = resizeCanvasTo(viewport, confCanvas, confCtx);
    burstConfettiOn(confCanvas, confCtx, dims.w, dims.h);
    showResultOverlay(targetStation,totalMoved);
  }

  async function onStart(){
    if(animating) return;
    try{ resumeAudioNow(); }catch(e){}
    // safety: ensure not stuck in paused state
    try{ window.__paused = false; }catch(e){}
    try{ sessionStorage.removeItem('jesong_bg'); }catch(e){}
    try{ const po=document.getElementById('pauseOverlay'); if(po) po.classList.remove('show'); }catch(e){}

    if(trueRandomMode){
      // True random: pick a random start AND destination from the whole map.
      animating=true; goBtn.disabled=true;
      primeAudio();
      startBGM();
      overlay.style.display='none';

      // Pick random start
      let startStation = currentStation;
      if(allStations.length){
        startStation = allStations[Math.floor(Math.random()*allStations.length)] || currentStation;
      }
      currentStation = startStation;
      currentLine = (getLinesOf(currentStation)[0] || lineNames[0]);
      setTokenAt(currentLine, currentStation, false);
      try{ snapCameraToTokenNow(); }catch(e){}
      try{ hudLine1.textContent = formatStation(currentStation); }catch(e){}
      try{ hudLine2.textContent = 'ÏõåÌîÑÏ§ë..'; }catch(e){}

      // Pick random destination (not the same as start)
      let dest = startStation;
      if(allStations.length>1){
        for(let tries=0; tries<40; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== startStation){ dest = cand; break; }
        }
      }

      await trueRandomWarpTo(dest);
      // Hold on the destination briefly so it doesn't feel like it "pops".
      await sleep(650);
      await finale(dest, null);
      currentStation=dest;
      currentLine=getLinesOf(currentStation)[0] || currentLine;
      try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
      animating=false; goBtn.disabled=false;
      return;
    }

    const startStation=findStartStation(startInput.value);
    if(!startStation){ showErr('Ï∂úÎ∞úÏó≠ Ïò§ÌÉÄ Ïòà: ÌòúÌôî, ÎèôÎåÄÎ¨∏, ÏÑúÏö∏Ïó≠, Í∞ïÎÇ®'); return; }


    // If the user sets a stop range that is impossible from this start station (in terms of
    // *minimum-stops* graph distance), clamp it and clearly ÏïàÎÇ¥ÌïúÎã§.
    try{
      const dist = bfsDistances(startStation);
      let maxPossible = 0;
      dist.forEach((v)=>{ if(v>maxPossible) maxPossible = v; });
      if(Number.isFinite(maxPossible) && maxPossible > 0){
        if(maxStops > maxPossible){
          maxStops = maxPossible;
          if(minStops > maxStops) minStops = maxStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('Ï∂úÎ∞úÏó≠ Í∏∞Ï§Ä ÏµúÎåÄ Ïù¥Îèô Í∞ÄÎä• Ï†ïÍ±∞Ïû• Ïàò(' + maxPossible + 'Ïó≠)Î•º Ï†ÅÏö©ÌñàÏäµÎãàÎã§.');
        } else if(minStops > maxPossible){
          minStops = maxPossible;
          if(maxStops < minStops) maxStops = minStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('Ï∂úÎ∞úÏó≠ Í∏∞Ï§Ä ÏµúÎåÄ Ïù¥Îèô Í∞ÄÎä• Ï†ïÍ±∞Ïû• Ïàò(' + maxPossible + 'Ïó≠)Î•º Ï†ÅÏö©ÌñàÏäµÎãàÎã§.');
        }
      }
    }catch(e){}

    animating=true; goBtn.disabled=true;
    primeAudio();
    startBGM();
    overlay.style.display='none';
    currentStation=startStation;
    currentLine=getLinesOf(currentStation)[0] || lineNames[0];
    const plan = planOptimalTrip(currentStation);
    const path = (plan && plan.path) ? plan.path : [];
    if(!path.length || !path[0] || !path[0].st){
      alert('Í≤ΩÎ°úÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§. (Ï∂úÎ∞ú/ÎèÑÏ∞© Ïó≠ÏùÑ Îã§Ïãú ÌôïÏù∏ÌïòÏÑ∏Ïöî.)');
      animating=false; goBtn.disabled=false;
      return;
    }

    // update currentLine to the route's starting line (could change if station belongs to multiple lines)
    currentLine = (path[0] && path[0].line) ? path[0].line : currentLine;
    const last=path[path.length-1];
    const moved=await animatePath(path);
    // Arrived: pause briefly before showing the result so it feels intentional.
    hudLine1.textContent = formatStation(last.st);
    hudLine2.textContent = 'Ïù¥Îèô: ' + moved + 'Ï†ïÍ±∞Ïû•';
    await sleep(650);
    await finale(last.st,moved);
    currentStation=last.st;
    currentLine=last.line;
    try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
    animating=false; goBtn.disabled=false;
  }

  goBtn.addEventListener('click', onStart);
  goBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
  })();
  // === Code modal (per-archive share code) ===
  const codeOverlay = document.getElementById("codeOverlay");
  const codeBackdrop = document.getElementById("codeBackdrop");
  const codeValueEl = document.getElementById("codeValue");
  const codeCopyBtn = document.getElementById("codeCopyBtn");
  const codeCloseBtn = document.getElementById("codeCloseBtn");
  const codeOkBtn = document.getElementById("codeOkBtn");

  let __currentCode = "";

  function openCodeModal(code){
    if(!codeOverlay) return;
    __currentCode = String(code||"");
    try{ if(codeValueEl) codeValueEl.textContent = __currentCode || "-"; }catch(e){}
    codeOverlay.classList.add("show");
    codeOverlay.setAttribute("aria-hidden","false");
    try{ setOverlayState(true); }catch(e){}
  }
  function closeCodeModal(){
    if(!codeOverlay) return;
    codeOverlay.classList.remove("show");
    codeOverlay.setAttribute("aria-hidden","true");
    try{ setOverlayState(false); }catch(e){}
    __currentCode = "";
  }
  async function copyCurrentCode(){
    const code = String(__currentCode||"");
    if(!code) return;
    try{
      if(navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(code);
      }else{
        prompt("Í≥µÏú†ÏΩîÎìú", code);
      }
      try{ playUiClickSfx(); }catch(e){}
    }catch(e){
      prompt("Í≥µÏú†ÏΩîÎìú", code);
    }
  }

  if(codeBackdrop) codeBackdrop.addEventListener("click", closeCodeModal);
  if(codeCloseBtn) codeCloseBtn.addEventListener("click", closeCodeModal);
  if(codeOkBtn) codeOkBtn.addEventListener("click", closeCodeModal);
  if(codeCopyBtn){
    const _c = (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_e){} copyCurrentCode(); };
    codeCopyBtn.addEventListener("click", _c);
    codeCopyBtn.addEventListener("touchend", _c, {passive:false});
    codeCopyBtn.addEventListener("pointerup", _c, {passive:false});
  }

// === VisualViewport height fix (prevents top blank on mobile Safari) ===
(function setupVvh(){
  const setVvh = () => {
    const vv = window.visualViewport;
    const h = vv ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--vvh', (h * 0.01) + 'px');
  };
  setVvh();
  window.addEventListener('resize', setVvh);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', setVvh);
})();
// UI_BUTTON_SFX_DELEGATE
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('button');
  if(b) playUiClickSfx();
}, true);
// (removed) redundant touchend UI click SFX listener


// === FIX17: iOS overlay button reliability (memory save/confirm) ===
(function fixOverlayButtons(){
  const attach = ()=>{
    const btn = document.getElementById('memorySave');
    if(btn && !btn.__fix17){
      btn.__fix17 = true;
      const fire = (e)=>{
        try{ e.preventDefault(); e.stopPropagation(); }catch(_e){}
        try{ playUiClickSfx(); }catch(_e){}
        // trigger the existing click handler
        try{ btn.click(); }catch(_e){}
      };
      btn.addEventListener('touchend', fire, {passive:false});
      btn.addEventListener('pointerup', fire, {passive:false});
    }
  };
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();

</script>

<script>
// Prevent text selection, callout, and dragging (mobile friendly)
(()=>{
  const prevent = (e)=>{ try{ e.preventDefault(); }catch(_){} };
  document.addEventListener('selectstart', prevent, {passive:false});
  document.addEventListener('dragstart', prevent, {passive:false});
  document.addEventListener('contextmenu', prevent, {passive:false});
  document.addEventListener('gesturestart', prevent, {passive:false});
  document.addEventListener('dblclick', (e)=>{
    // avoid double-tap selection on some browsers
    prevent(e);
  }, {passive:false});
})();

// UI_BUTTON_SFX_DELEGATE
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('button');
  if(b) playUiClickSfx();
}, true);
// (removed) redundant touchend UI click SFX listener



/* === CitySparkles populate (bottom area) === */
(function initCitySparkles(){
  const host = document.getElementById('citySparkles');
  if(!host) return;
  const N = 34;
  for(let i=0;i<N;i++){
    const s = document.createElement('i');
    const x = Math.random() < 0.55 ? (55 + Math.random()*45) : (Math.random()*100);
    const y = Math.random()*100;
    const size = 4 + Math.random()*5;
    s.style.left = x.toFixed(2) + '%';
    s.style.top  = y.toFixed(2) + '%';
    s.style.width = s.style.height = size.toFixed(1) + 'px';
    s.style.animationDelay = (Math.random()*2.6).toFixed(2) + 's';
    s.style.animationDuration = (2.0 + Math.random()*1.8).toFixed(2) + 's';
    host.appendChild(s);
  }
})();
</script>

  <div id="resumeNotice">ÌôîÎ©¥ÏùÑ Ìïú Î≤à ÌÑ∞ÏπòÌïòÎ©¥ ÏÜåÎ¶¨Í∞Ä Îã§Ïãú Ïû¨ÏÉùÎê©ÎãàÎã§.</div>
  <div id="modalBlocker" class="modalBlocker" aria-hidden="true"></div>

  
  <!-- Share Stage (hidden) -->
  <div id="shareStage" aria-hidden="true" style="position:fixed;left:-99999px;top:-99999px;width:1px;height:1px;overflow:hidden;"></div>

  <div id="pauseOverlay" class="pauseOverlay" aria-hidden="true">
    <div class="pauseCard">
      <div class="pauseTitle">ÏùºÏãúÏ†ïÏßÄÎê®</div>
      <button id="pausePlayBtn" class="pausePlayBtn" type="button" aria-label="Ïû¨Í∞ú">
        <span class="tri"></span>
      </button>
      <div class="pauseHint">ÌôîÎ©¥ÏùÑ ÌÑ∞ÏπòÌïòÎ©¥ Ïû¨Í∞úÎê©ÎãàÎã§</div>
    </div>
  </div>



<p class="import-notice" style="
  font-size:12px;
  color:#888;
  margin-top:8px;
  line-height:1.4;
">
‚ö†Ô∏è ÎÇ¥Ïö©Ïù¥ÎÇò ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω Ïãú ÏÉà Í≥µÏú†ÏΩîÎìúÍ∞Ä ÏÉùÏÑ±ÎêòÎØÄÎ°ú, ÏµúÏã†Ïùò Í≥µÏú†ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.
</p>

</body>
</html>
