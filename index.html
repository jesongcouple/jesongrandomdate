<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="theme-color" content="#ff4d6d" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- iOS 홈화면 아이콘은 manifest보다 apple-touch-icon을 우선하는 경우가 많음 -->
<link rel="apple-touch-icon" href="./apple-touch-icon.png" />
<!-- 브라우저 탭 아이콘(설치형 아이콘과 별개) -->
<link rel="icon" href="./icon-192.png" type="image/png" sizes="192x192" />
<link rel="icon" href="./icon-512.png" type="image/png" sizes="512x512" />
<title>제•송 랜덤데이트</title>
<style>
:root{--main:#ff4d6d;--bg:#fff0f3;--ink:#c9184a;--stageWpx:320px;--stageHpx:560px;--splashWpx:320px;--splashHpx:560px;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;font-family:-apple-system,system-ui,sans-serif;}
html,body{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
*{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
svg,svg *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
img,svg{ -webkit-user-drag:none; user-drag:none; }
input,button,textarea,select{ -webkit-user-select:none; user-select:none; }

body{margin:0;background:var(--bg);}
.wrap{max-width:520px;margin:0 auto;padding:14px;}
.card{background:#fff;border:6px solid #ffccd5;border-radius:28px;padding:14px;box-shadow:0 14px 30px rgba(255,77,109,.18);}
.title{font-weight:900;color:var(--ink);font-size:20px;margin:0 0 14px;text-align:center;}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
input{flex:1;min-width:180px;padding:12px 14px;border-radius:18px;border:3px solid #ffccd5;font-size:16px;outline:none;text-align:center;}

/* === True Random mode: lock start input + sparkle text === */
.trueRandomInput{
  color:#ff4d6d !important;
  font-weight:1000 !important;
  letter-spacing:0.4px;
  border-color:#ff8fa3 !important;
  /* 테두리는 깜빡이지 않고 은은하게 빛나기만 */
  box-shadow: 0 0 0 3px rgba(255,77,109,0.18), 0 0 18px rgba(255,77,109,0.22);
  /* 반짝임은 글자만 */
  animation: trSparkle 1.1s ease-in-out infinite;
}
@keyframes trSparkle{
  0%{ text-shadow: 0 0 4px rgba(255,77,109,0.30), 0 0 10px rgba(255,77,109,0.18); }
  50%{ text-shadow: 0 0 8px rgba(255,77,109,0.55), 0 0 18px rgba(255,77,109,0.28); }
  100%{ text-shadow: 0 0 5px rgba(255,77,109,0.32), 0 0 12px rgba(255,77,109,0.20); }
}
button{padding:12px 16px;border:0;border-radius:999px;background:linear-gradient(135deg,#ff8fa3,#ffb3c1);color:#fff;font-weight:900;font-size:16px;box-shadow:0 10px 18px rgba(255,77,109,.25);cursor:pointer;}
button:disabled{background:#ccc;box-shadow:none;cursor:default;}
.stageWrap{margin-top:12px;width:var(--stageWpx);height:var(--stageHpx);margin-left:auto;margin-right:auto;background:#fff8f9;border:2px solid #ffd6df;border-radius:22px;overflow:hidden;position:relative;}
.viewport{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;background:#fff8f9;position:relative;touch-action:pan-x pan-y;}
.viewport{scrollbar-width:none;-ms-overflow-style:none;}
.viewport::-webkit-scrollbar{width:0;height:0;display:none;}

svg{display:block;}
.lineStroke{stroke-width:22;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;filter:drop-shadow(0 10px 14px rgba(0,0,0,.10));}
.lineInner{stroke:#fff;stroke-width:7;stroke-linecap:round;stroke-linejoin:round;fill:none;opacity:.95;}
.connector{stroke:#ffb3c1;stroke-width:5;stroke-linecap:round;opacity:.75;fill:none;}
.label{font-size:11px;font-weight:900;fill:#c9184a;opacity:1;}
.stationDot{fill:#fff;stroke:var(--main);stroke-width:4;opacity:1;}
.token{filter:drop-shadow(0 10px 12px rgba(0,0,0,.16));}
.token circle,.token rect{fill:var(--main);stroke:#fff;stroke-width:4;}
#hudRect{fill:white;stroke:#ffccd5;stroke-width:4;opacity:.94;}
#confetti{position:absolute;inset:0;pointer-events:none;z-index:20;}

#resultOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;}
#resultBackdrop{position:absolute;inset:0;background:rgba(255,240,243,.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
#resultBox{position:relative;width:min(360px,86vw);background:#fff;border-radius:24px;padding:22px 26px;text-align:center;border:4px solid #ffccd5;box-shadow:0 20px 40px rgba(255,77,109,.25);overflow:hidden;}
#resultCanvas{position:absolute;inset:0;pointer-events:none;z-index:2;}
#resultContent{position:relative;z-index:3;}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;display:none;background:rgba(0,0,0,.85);color:#fff;padding:12px 14px;border-radius:14px;font-weight:900;font-size:11px;line-height:1.35;}

/* --- Splash (tap -> loading -> reveal) --- */
#startOverlay{
  position:fixed;
  inset:0;
  z-index:100000;
  background:var(--bg);
  opacity:1;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0; /* 카드처럼 작게는 안 보이되, 스크롤/넘침 방지용 최소 여백 */
  touch-action:manipulation;
  user-select:none;
}
#startOverlay.fadeOut{ opacity:0; transition:opacity .55s ease; }

.splashStage{
  width:var(--splashWpx);
  height:var(--splashHpx);
  border-radius:0;
  overflow:hidden;
  border:0;
  background:var(--bg);
  position:relative;
}
#splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
#tapHintWrap, #splashLoading{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%,-50%);
  text-align:center;
  width:100%;
  padding:0 14px;
}
#tapHint{
  font-size:18px;
  font-weight:1000;
  letter-spacing:0.5px;
  color:rgba(255,255,255,.96);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  animation:tapPulse 1.05s ease-in-out infinite;
}
@keyframes tapPulse{
  0%{ transform:scale(.98); opacity:.55; }
  45%{ transform:scale(1.04); opacity:1; }
  100%{ transform:scale(.98); opacity:.55; }
}
#splashLoading{
  font-size:20px;
  font-weight:1000;
  letter-spacing:1px;
  color:rgba(255,255,255,.95);
  text-shadow:0 10px 22px rgba(0,0,0,.55);
  display:none;
  line-height:1;
}
#splashLoading.show{ display:block; }
#splashLoading .dots::after{ content:""; animation:dots 1.05s steps(4,end) infinite; }
#splashLoading .blink{ animation:blink 0.55s steps(2,end) infinite; }
@keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:.25} }
@keyframes dots{ 0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""} }
#startOverlay.loading #splashImg{width:100%;height:100%;object-fit:cover;object-position:center;display:block;}
@keyframes loadingZoom{ 0%{ transform:scale(1); filter:saturate(1.05); } 50%{ transform:scale(1.02); filter:saturate(1.15); } 100%{ transform:scale(1); filter:saturate(1.05); } }

/* --- Mini settings button & modal --- */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:800;
  font-size:17px;
  line-height:1;
  box-shadow:0 6px 12px rgba(255,77,109,.18);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
}
.miniBtn:active{ transform:translateY(1px) scale(.99); }

#settingsOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9000;
}
#settingsOverlay.show{ display:flex; }
#settingsBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
}
#settingsBox{
  border:3px solid #ffd6df;
  position:relative;
  width:min(380px, 88vw);
  background:#fff;
  border-radius:24px;
  padding:20px 22px 18px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.settingsTitle{
  font-weight:1000;
  font-size:16px;
  color:#d6336c;
  text-align:center;
  margin-bottom:14px;
}
.settingsRow{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:12px 10px;
  border-radius:18px;
  background:#fff8f9;
  border:3px solid #ffccd5;
  margin-bottom:10px;
  text-align:center;
}

/* Combined min/max row (one box) */
.settingsRowCombined{ padding:14px 12px; }

#stopsRow.controlsDisabled{
  pointer-events:none;
}
#stopsRow.controlsDisabled .settingsLabel{
  opacity:.85;
}
#stopsRow.controlsDisabled .stepBtn,
#stopsRow.controlsDisabled .numInput{
  filter:saturate(.9);
}
.stopsGrid{
  width:100%;
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  align-items:center;
  justify-items:center;
}
.stopItem{ width:100%; display:flex; flex-direction:column; align-items:center; gap:8px; }
.stopItem .numInput{ width:78px; min-width:78px; }
.stopItem .stepBtn{ width:40px; height:40px; border-radius:14px; }

/* True random row: a bit darker / more present */
.settingsRowStrong{
  background:linear-gradient(180deg,#ffe3ea,#ffd2dc);
  border-color:#ff8fa3;
}
.settingsLabel{
  font-weight:900;
  font-size:13px;
  color:#d6336c;
  white-space:nowrap;
  width:100%;
  text-align:center;
}
.stepper{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}
.numInput{
  width:84px;
  min-width:84px;
  padding:10px 10px;
  border-radius:14px;
  border:2px solid #ffd6df;
  font-weight:1000;
  font-size:16px;
  text-align:center;
  outline:none;
}
.stepBtn{
  touch-action:manipulation;
  user-select:none;
  width:42px;
  height:42px;
  padding:0;
  border-radius:14px;
  border:2px solid #ffd6df;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:16px;
  line-height:1;
  box-shadow:0 10px 18px rgba(255,77,109,.18);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
}
.stepBtn:active{ transform:translateY(1px) scale(.99); }
.stepBtn:disabled{ opacity:.35; cursor:not-allowed; pointer-events:none; filter:grayscale(.1); }
.stepBtn:disabled:active{ transform:none; }

.settingsHint{
  margin:8px 2px 14px;
  font-weight:900;
  font-size:11px;
  color:#ff4d6d;
  text-align:center;
  opacity:.92;
}
.settingsActions{
  display:flex;
  justify-content:center;
  gap:10px;
}
.ghostBtn{
  padding:10px 16px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:#fff0f3;
  color:#d6336c;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
}
.solidBtn{
  padding:10px 18px;
  border-radius:999px;
  border:0;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
}


/* === Visual viewport height var (mobile Safari fix) === */
:root{ --vvh: 1vh; }
#startOverlay{ height: calc(var(--vvh) * 100); }
#splashStage{ height: calc(var(--vvh) * 100); width: 100%; }


/* === Settings UI tone override (softer) === */
.miniBtn{
  width:40px !important;
  height:40px !important;
  border-radius:12px !important;
  border:2px solid #ffd6df !important;
  background: rgba(255,240,243,.92) !important;
  color:#c9184a !important;
  box-shadow:0 6px 12px rgba(201,24,74,.12) !important;
  font-weight:900 !important;
}
.miniBtn:hover{ filter:none !important; }
.stepBtn{
  border:2px solid #ffd6df !important;
  background: linear-gradient(135deg,#ff8fa3,#ffb3c1) !important;
  box-shadow:0 6px 12px rgba(201,24,74,.10) !important;
}
#settingsBox{
  border:3px solid #ffd6df !important;
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 4px 8px rgba(201,24,74,.16),
    inset 0 1px 0 rgba(255,255,255,.7) !important;
}


/* === Mobile splash: fill the whole screen (no side gaps) === */
@media (max-width: 700px){
  #startOverlay{ padding:0 !important; }
  .splashStage{ width:100vw !important; height:calc(var(--vvh) * 100) !important; }
}


.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}


/* === Settings button: deep pink 3D === */
.miniBtn{
  background: linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  border:2px solid #ffb3c1 !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}





/* === Settings button redraw (border + 3D, no mismatch) === */
.miniBtn{
  position:absolute;
  right:10px;
  bottom:10px;
  width:46px;
  height:46px;
  border-radius:16px;
  border:0 !important;
  background: linear-gradient(180deg,#ff7a9b 0%, #ff3d66 100%) !important;
  color:#fff !important;
  font-weight:900;
  font-size:18px;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:30;
  box-shadow: 0 12px 18px rgba(201,24,74,.22);
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:16px;
  box-shadow:
    inset 0 0 0 3px rgba(255,204,213,.95),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.14);
  pointer-events:none;
}
.miniBtn::after{
  content:"";
  position:absolute;
  inset:4px;
  border-radius:12px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%);
  pointer-events:none;
}
.miniBtn:active{
  transform: translateY(1px) scale(.98);
  box-shadow: 0 8px 12px rgba(201,24,74,.20);
}
@media (max-width:700px){
  .miniBtn{ right: calc(10px + env(safe-area-inset-right)); bottom: calc(10px + env(safe-area-inset-bottom)); }
}


/* === Settings button border redraw (perfect match) === */
.miniBtn{
  position:absolute !important;
  right:10px !important;
  bottom:10px !important;
  width:46px !important;
  height:46px !important;
  border-radius:16px !important;
  border:none !important;            /* border drawn by ::before */
  background:linear-gradient(180deg,#ff85a2 0%, #ff4d6d 100%) !important;
  color:#fff !important;
  box-shadow:
    0 10px 16px rgba(201,24,74,.22),
    inset 0 2px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.10) !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  cursor:pointer !important;
  z-index:30 !important;
  padding:0 !important;
}
.miniBtn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  border:3px solid rgba(255,204,213,.95);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    0 0 0 1px rgba(255,204,213,.15);
  pointer-events:none;
}
.miniBtn:active{
  transform:translateY(1px) scale(.98) !important;
  box-shadow:
    0 6px 10px rgba(201,24,74,.20),
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12) !important;
}



/* === Pan extra space: allow camera to truly center token (top+bottom) === */
#panTopPad{ height:120px; width:1px; }
#panBottomPad{ height:900px; width:1px; }


.row{position:relative;z-index:50;}


/* Hide native number input spinners (use our icon buttons instead) */
.numInput::-webkit-outer-spin-button,
.numInput::-webkit-inner-spin-button{
  -webkit-appearance: none;
  margin: 0;
}
.numInput{
  -moz-appearance: textfield;
  appearance: textfield;
}


/* === True Random Toggle Switch === */
.toggleSwitch{ position:relative; display:inline-flex; align-items:center; width:fit-content;  pointer-events:none; }
.toggleSwitch input{ position:absolute; opacity:0; width:1px; height:1px; }
.toggleTrack{
  display:inline-block;
  pointer-events:auto;
  touch-action:manipulation;
  width:78px; height:42px;
  border-radius:999px;
  background: linear-gradient(180deg,#ffe3ea 0%, #ffd6df 100%);
  border:3px solid #ffccd5;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.06);
  position:relative;
  transition: all .22s ease;
  cursor:pointer;
}
.toggleKnob{
  z-index:2;
  position:absolute; top:50%; left:4px;
  width:34px; height:34px;
  border-radius:999px;
  transform: translateY(-50%);
  background: linear-gradient(180deg,#ffffff 0%, #fff7f9 100%);
  border:2px solid rgba(255,204,213,.9);
  box-shadow: 0 8px 14px rgba(201,24,74,.14);
  transition: all .22s ease;
}
.toggleText{
  z-index:1;
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 9px;
  font-weight:1000;
  font-size:11px;
  letter-spacing:.5px;
  color: rgba(201,24,74,.45);
  pointer-events:none;
}
.toggleText span{ display:inline-block;  opacity:.55; transition:opacity .22s ease; min-width:28px; text-align:center; }
.toggleText .on{ opacity:.25; transform:translateX(2px); }
.toggleText .off{ opacity:.75; transform:translateX(-2px); }

.toggleSwitch input:checked ~ .toggleTrack{
  background: linear-gradient(135deg,#ff8fa3 0%, #ff4d6d 100%);
  border-color:#ffb3c1;
  box-shadow: inset 0 2px 4px rgba(0,0,0,.07), 0 10px 18px rgba(201,24,74,.14);
}
.toggleSwitch input:checked ~ .toggleTrack .toggleKnob{
  z-index:2; left: calc(100% - 4px - 34px); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText{
  z-index:1; color: rgba(255,255,255,.88); }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .on{ opacity:.95; }
.toggleSwitch input:checked ~ .toggleTrack .toggleText .off{ opacity:.35; }

.hotPink{ color:#ff4d6d !important; font-weight:1000 !important; }



/* iOS audio resume notice */
#resumeNotice{position:fixed;left:50%;transform:translateX(-50%);bottom:110px;z-index:9999;padding:8px 12px;border-radius:12px;background:rgba(255,255,255,.92);color:#444;font-size:12px;box-shadow:0 8px 18px rgba(0,0,0,.12);display:none;pointer-events:none;}

/* === Sound control button (above settings) === */
.soundBtn{
  bottom:64px !important; /* above ⚙️ */
}

/* === Sound overlay (volume) === */
#audioOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9050; /* above settings (9000) */
}
#audioOverlay.show{ display:flex; }
#audioBackdrop{
  position:absolute;
  inset:0;
  background:rgba(255,240,243,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
}
#audioBox{
  position:relative;
  width:min(420px, 92vw);
  background:#fff;
  border-radius:26px;
  padding:18px 18px 16px;
  border:4px solid #ffccd5;
  box-shadow:0 22px 46px rgba(255,77,109,.26);
  z-index:2;
}
.audioTitle{
  font-weight:1000;
  font-size:18px;
  color:#d6336c;
  text-align:center;
  margin:2px 0 12px;
}
.audioTopActions{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:center;
  margin-bottom:10px;
}
.audioRoundBtn{
  width:46px;
  height:46px;
  border-radius:999px;
  border:3px solid #ffccd5;
  background:linear-gradient(180deg,#ffe3ea 0%, #ffd2dc 100%);
  box-shadow:
    0 10px 16px rgba(201,24,74,.18),
    inset 0 2px 0 rgba(255,255,255,.45),
    inset 0 -2px 0 rgba(0,0,0,.08);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:18px;
  cursor:pointer;
  user-select:none;
}
.audioRoundBtn:active{ transform:translateY(1px) scale(.98); }

.audioCard{
  width:100%;
  background:#fff8f9;
  border:3px solid #ffccd5;
  border-radius:20px;
  padding:12px 12px 14px;
  margin:10px 0;
}
.audioLabel{
  font-weight:1000;
  font-size:14px;
  color:#d6336c;
  text-align:center;
  margin-bottom:10px;
}
.audioRow{
  display:flex;
  align-items:center;
  gap:10px;
  width:100%;
}
.audioHint{
  width:26px;
  text-align:center;
  font-size:14px;
  opacity:.55;
  user-select:none;
}
.audioRange{
  flex:1 1 auto;
  width:100%;
  min-width:0;
  max-width:none;
  -webkit-appearance:none;
  appearance:none;
  height:8px;
  border-radius:999px;
  background:#e9ecef;
  outline:none;
}
.audioRange::-webkit-slider-thumb{
  -webkit-appearance:none;
  appearance:none;
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioRange::-moz-range-thumb{
  width:22px;height:22px;border-radius:50%;
  background:#6c757d;
  border:2px solid #fff;
  box-shadow:0 6px 10px rgba(0,0,0,.18);
}
.audioCloseRow{
  display:flex;
  justify-content:center;
  margin-top:12px;
}
.audioCloseBtn{
  width:100%;
  padding:14px 16px;
  border-radius:999px;
  border:none;
  background:linear-gradient(135deg,#ff8fa3,#ffb3c1);
  color:#fff;
  font-weight:1000;
  font-size:18px;
  box-shadow:0 10px 18px rgba(255,77,109,.22);
  cursor:pointer;
}
.audioCloseBtn:active{ transform:translateY(1px) scale(.99); }


/* === Modal behavior: block background interaction when overlays are open === */
body.overlayOpen .wrap,
body.overlayOpen canvas{
  pointer-events:none;
}
#settingsOverlay,
#audioOverlay{
  pointer-events:auto;
}


/* Modal interaction blocker (prevents any background taps/drags) */
.modalBlocker{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0);
  z-index: 9998;
  display: none;
  touch-action: none;
}
body.overlayOpen .modalBlocker{ display:block; }
/* Ensure overlays are above blocker */
#settingsOverlay, #audioOverlay{ z-index: 10000; }


/* === FIX: range reaches visual edges (speaker + range + speaker via grid) === */
.sound-slider-wrap{
  display: grid !important;
  grid-template-columns: auto 1fr auto !important;
  align-items: center !important;
  column-gap: 8px !important;
  width: 100% !important;
}
.sound-slider-wrap input[type="range"]{
  width: 100% !important;
  min-width: 0 !important;
  margin: 0 !important;
}
/* Ensure rows don't shrink the range */
.audioRow{ width: 100% !important; }
.audioRange{
  width: 100% !important;
  max-width: none !important;
  min-width: 0 !important;
}


/* === FIX: iOS range track end-gaps (custom range in audio overlay only) === */
#audioOverlay input[type="range"]{
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  padding: 0;
}
#audioOverlay input[type="range"]::-webkit-slider-runnable-track{
  height: 6px;
  border-radius: 999px;
  background: rgba(0,0,0,0.18);
}
#audioOverlay input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 3px 10px rgba(0,0,0,0.18);
  margin-top: -6px;
}
/* Firefox */
#audioOverlay input[type="range"]::-moz-range-track{
  height: 6px;
  border-radius: 999px;
  background: rgba(0,0,0,0.18);
}
#audioOverlay input[type="range"]::-moz-range-thumb{
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  border: none;
  box-shadow: 0 3px 10px rgba(0,0,0,0.18);
}
#audioOverlay .audioRange{ margin:0 !important; }


/* === UX: make audio sliders easier to grab (bigger hit area) === */
#audioOverlay input[type="range"]{
  height: 34px;
  touch-action: pan-x;
}
#audioOverlay input[type="range"]::-webkit-slider-thumb{
  width: 24px;
  height: 24px;
  margin-top: -9px; /* re-center on 6px track */
}
#audioOverlay input[type="range"]::-moz-range-thumb{
  width: 24px;
  height: 24px;
}


/* === UX: clearer mute button on/off state === */
.audioIconBtn.isOn{
  background: rgba(255,77,109,0.32) !important;
  box-shadow: 0 6px 14px rgba(255,77,109,0.22) !important;
}


/* === FINAL POLISH: remove iOS range focus/box outlines === */
#audioOverlay input[type="range"]{
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
  background-clip: padding-box !important;
}
#audioOverlay input[type="range"]:focus,
#audioOverlay input[type="range"]:focus-visible{
  outline: none !important;
  box-shadow: none !important;
}


#resumeNotice{display:none!important;}

/* === Pause overlay (forces one tap to resume after background) === */
.pauseOverlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 12000;
  background: rgba(255,77,109,0.07); /* more transparent pink */
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
}
.pauseOverlay.show{ display:flex; }
.pauseCard{
  width: 100%;
  max-width: none;
  padding: 0 18px;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
  text-align: center;
}
.pauseTitle{
  font-weight: 800;
  font-size: 18px;
  margin-bottom: 14px;
}
.pauseHint{
  margin-top: 14px;
  font-size: 13px;
  opacity: 0.75;
}
.pausePlayBtn{
  width: 76px;
  height: 76px;
  border-radius: 999px;
  border: none;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.85), rgba(255,77,109,0.28) 55%, rgba(255,77,109,0.18));
  box-shadow: 0 14px 26px rgba(255,77,109,0.22), inset 0 2px 0 rgba(255,255,255,0.75);
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.pausePlayBtn:active{ transform: scale(0.98); }
.pausePlayBtn .tri{
  display:block;
  width: 0;
  height: 0;
  border-top: 10px solid transparent;
  border-bottom: 10px solid transparent;
  border-left: 16px solid rgba(255,77,109,0.98);
  margin-left: 4px;
  filter: drop-shadow(0 2px 6px rgba(255,77,109,0.25));
}



.pausePlayBtn{
  position: relative;
  overflow: hidden;
  transform: translateZ(0);
}
.pausePlayBtn::before{
  content:"";
  position:absolute;
  inset: 0;
  border-radius: 999px;
  background: radial-gradient(circle at 28% 22%, rgba(255,255,255,0.95), rgba(255,255,255,0) 52%);
  opacity: 0.85;
  pointer-events:none;
}
.pausePlayBtn::after{
  content:"";
  position:absolute;
  inset: -1px;
  border-radius: 999px;
  border: 1px solid rgba(255,77,109,0.22);
  pointer-events:none;
}
.pausePlayBtn{
  transition: transform 0.08s ease, filter 0.12s ease;
}
.pausePlayBtn:active{
  transform: scale(0.97);
  filter: brightness(0.98);
}


/* Fullscreen pause overlay layout */
.pauseTitle{ font-size: 20px; margin-bottom: 18px; }
.pauseHint{ font-size: 14px; opacity: 0.8; }


/* === Play button (clean glossy, modern) === */
.pausePlayBtn{
  width: 76px;
  height: 76px;
  border-radius: 999px;
  border: none;
  background: rgba(255,77,109,0.28);
  box-shadow:
    0 10px 22px rgba(255,77,109,0.22),
    inset 0 2px 0 rgba(255,255,255,0.65);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: transform .08s ease, filter .12s ease;
}
.pausePlayBtn:active{
  transform: scale(0.97);
  filter: brightness(0.98);
}
.pausePlayBtn .tri{
  width: 0;
  height: 0;
  border-top: 11px solid transparent;
  border-bottom: 11px solid transparent;
  border-left: 18px solid rgba(255,77,109,0.95);
  margin-left: 4px;
}



const TRANSFER_SFX_URL = new URL('transfer-loop.mp3', window.location.href).href;

function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

// Persistent settings keys
const LAST_STATION_KEY = "jesong_last_station";
const MIN_STOPS_KEY = "jesong_min_stops";
const MAX_STOPS_KEY = "jesong_max_stops";
const TRUE_RANDOM_KEY = "jesong_true_random";
const DEFAULT_FIRST_STATION = "서울역";


(function(){
  const errEl=document.getElementById('err');
  function showErr(msg){
    errEl.textContent=msg;
    errEl.style.display='block';
    clearTimeout(showErr.__t);
    showErr.__t=setTimeout(()=>{ errEl.style.display='none'; }, 3200);
  }
  window.addEventListener('error',(e)=>showErr('JS 에러: '+(e.message||'unknown')));
  window.addEventListener('unhandledrejection',(e)=>showErr('Promise 에러: '+(e.reason?.message||e.reason||'unknown')));  // Responsive stage sizing (game + splash)
  function setStageSize(){
    const vv=window.visualViewport;
    const vw=(vv&&vv.width)||window.innerWidth;
    const vh=(vv&&vv.height)||window.innerHeight;

    const card=document.querySelector('.card');
    const title=document.querySelector('.title');
    const row=document.querySelector('.row');

    const wrapPad = 28; // .wrap padding (14*2)
    const maxW = Math.min(520, (card ? (card.clientWidth - 28) : (vw - wrapPad)));

    const titleH = title ? title.getBoundingClientRect().height : 0;
    const rowH   = row   ? row.getBoundingClientRect().height   : 0;
    const chrome = 34;

    const availableH = vh - (titleH + rowH) - chrome - 18;
    const maxH = Math.min(980, Math.max(480, availableH));

    // Game: keep as-is (no scroll on web)
    const HEIGHT_FACTOR = 0.92;
    const w = Math.max(300, Math.min(maxW, maxW));
    const h = Math.max(420, Math.min(maxH, maxH * HEIGHT_FACTOR));    // Splash: 시작화면은 스플래시 이미지 비율(9:16)을 유지하면서,
    // 웹에서 '폰 화면 1대'가 중앙에 크게 보이도록(스크롤 없이) 가능한 한 크게 맞춘다.
    // ※ 게임 비율을 따라가면 시작화면이 옆으로 넓어져서(=가로 과확대) 여기서는 이미지 비율을 고정한다.
    const splashRatio = 16/9; // height / width (스플래시 원본 비율)
    // 모바일에서는 빈공간 없게 '보이는 화면(visual viewport)'을 꽉 채우게 함
    let splashW, splashH;

    // Mobile: fill the visible viewport (no blanks)
    if (vw <= 700){
      splashW = vw;
      splashH = vh;
    } else {
      // Desktop/web: keep centered 'phone screen' frame
      splashH = Math.min(vh, maxH);
      splashW = splashH / splashRatio;
      if (splashW > maxW){
        splashW = maxW;
        splashH = splashW * splashRatio;
      }
    }

    const root=document.documentElement;
    root.style.setProperty('--stageWpx', w.toFixed(2)+'px');
    root.style.setProperty('--stageHpx', h.toFixed(2)+'px');
    root.style.setProperty('--splashWpx', splashW.toFixed(2)+'px');
    root.style.setProperty('--splashHpx', splashH.toFixed(2)+'px');
  }

  function min(a,b,c){ return Math.min(a,b,c); }

  window.addEventListener('resize', setStageSize, {passive:true});
  window.addEventListener('orientationchange', setStageSize, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', setStageSize, {passive:true});
  setStageSize();

  // Splash: tap -> loading -> reveal
  const splash=document.getElementById('startOverlay');
  const hintWrap=document.getElementById('tapHintWrap');
  const loadingWrap=document.getElementById('splashLoading');
  let splashStarted=false;

  function removeSplash(){
    if(!splash) return;
    splash.classList.add('fadeOut');
    setTimeout(()=>{ try{ splash.remove(); } catch(e){ splash.style.display='none'; } }, 600);
  }

  function beginSplashLoading(){
    if(!splash || splashStarted) return;
    splashStarted=true;
    // prevent double taps during loading but keep initial tap working
    splash.style.pointerEvents='none';
    splash.classList.add('loading');
    if(hintWrap) hintWrap.style.display='none';
    if(loadingWrap) loadingWrap.classList.add('show');

    // Give some action: subtle tick every 240ms
    let ticks=0;
    const iv=setInterval(()=>{ ticks++; if(ticks>12) clearInterval(iv); else { try{ playTick(); }catch(e){} } }, 240);

    setTimeout(()=>{
      try{ clearInterval(iv); }catch(e){}
      removeSplash();
      try{ window.__gameStarted = true; }catch(e){}
      // After splash disappears (fadeOut 600ms), force-center on the token.
      scheduleInitialCenter();
      setTimeout(()=>{ try{ snapCameraToTokenNow(); }catch(e){} }, 650);
    }, 3000);
  }

  if(splash){
    // iOS/Safari reliability: use pointerdown/touchstart (click can be delayed or swallowed)
    const onSplashGesture = (e)=>{
      // prevent accidental scrolling / selection during splash tap
      try{ e.preventDefault(); }catch(err){}
      beginSplashLoading();
    };
    splash.addEventListener('pointerdown', onSplashGesture, {passive:false});
    splash.addEventListener('touchstart', onSplashGesture, {passive:false});
    splash.addEventListener('click', (e)=>{ try{ e.preventDefault(); }catch(err){} beginSplashLoading(); }, {passive:false});
    splash.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') beginSplashLoading(); });
  }

  const DATA = {"1호선":["연천","전곡","청산","소요산","동두천","지행","덕정","덕계","양주","녹양","가능","의정부","회룡","망월사","도봉산","도봉","방학","창동","녹천","월계","광운대","석계","신이문","외대앞","회기","청량리","제기동","신설동","동묘앞","동대문","종로5가","종로3가","종각","시청","서울역","남영","용산","노량진","대방","신길","영등포","신도림","구로","구일","개봉","오류동","온수","역곡","소사","부천","중동","상동","송내","부개","부평","백운","동암","간석","주안","도화","제물포","도원","동인천","인천","가산디지털단지","독산","금천구청","석수","관악","안양","명학","금정","산본","수리산","대야미","반월","상록수","한대앞","중앙","고잔","초지","안산","신길온천","정왕","오이도","의왕","성균관대","화서","수원","세류","병점","세마","오산대","오산","진위","송탄","서정리","평택지제","평택","성환","직산","두정","천안","봉명","쌍용","아산","탕정","배방","온양온천","신창"],"2호선":["시청","을지로입구","을지로3가","을지로4가","동대문역사문화공원","신당","상왕십리","왕십리","한양대","뚝섬","성수","건대입구","구의","강변","잠실나루","잠실","잠실새내","종합운동장","삼성","선릉","역삼","강남","교대","서초","방배","사당","낙성대","서울대입구","봉천","신림","신대방","구로디지털단지","대림","신도림","문래","영등포구청","당산","합정","홍대입구","신촌","이대","아현","충정로","용답","신답","용두","신설동","도림천","양천구청","신정네거리","까치산"],"3호선":["대화","주엽","정발산","마두","백석","대곡","화정","원당","원흥","삼송","지축","구파발","연신내","불광","녹번","홍제","무악재","독립문","경복궁","안국","종로3가","을지로3가","충무로","동대입구","약수","금호","옥수","압구정","신사","잠원","고속터미널","교대","남부터미널","양재","매봉","도곡","대치","학여울","대청","일원","수서","가락시장","경찰병원","오금"],"4호선":["진접","오남","별내별가람","당고개","상계","노원","창동","쌍문","수유","미아","미아사거리","길음","성신여대입구","한성대입구","혜화","동대문","동대문역사문화공원","충무로","명동","회현","서울역","숙대입구","삼각지","신용산","이촌","동작","총신대입구","사당","남태령","선바위","경마공원","대공원","과천","정부과천청사","인덕원","평촌","범계","금정","산본","수리산","대야미","반월","상록수","한대앞","중앙","고잔","초지","안산","신길온천","정왕","오이도"],"5호선":["방화","개화산","김포공항","송정","마곡","발산","우장산","화곡","까치산","신정","목동","오목교","양평","영등포구청","영등포시장","신길","여의도","여의나루","마포","공덕","애오개","충정로","서대문","광화문","종로3가","을지로4가","동대문역사문화공원","청구","신금호","행당","왕십리","마장","답십리","장한평","군자","아차산","광나루","천호","강동","길동","굽은다리","명일","고덕","상일동","강일","미사","하남풍산","하남시청","하남검단산","둔촌동","올림픽공원","방이","오금","개롱","거여","마천"],"6호선":["응암","역촌","독바위","연신내","구산","새절","증산","디지털미디어시티","월드컵경기장","마포구청","망원","합정","상수","광흥창","대흥","공덕","효창공원앞","삼각지","녹사평","이태원","한강진","버티고개","약수","청구","신당","동묘앞","창신","보문","안암","고려대","월곡","상월곡","돌곶이","석계","태릉입구","화랑대","봉화산","신내"],"7호선":["장암","도봉산","수락산","마들","노원","중계","하계","공릉","태릉입구","먹골","중화","상봉","면목","사가정","용마산","중곡","군자","어린이대공원","건대입구","뚝섬유원지","청담","강남구청","학동","논현","반포","고속터미널","내방","이수","남성","숭실대입구","상도","장승배기","신대방삼거리","보라매","신풍","대림","남구로","가산디지털단지","철산","광명사거리","천왕","온수","까치울","부천종합운동장","춘의","신중동","부천시청","상동","삼산체육관","굴포천","부평구청","상갈","산곡","석남"],"8호선":["별내","다산","동구릉","구리","장자호수공원","암사역사공원","암사","천호","강동구청","몽촌토성","잠실","석촌","송파","가락시장","문정","장지","복정","남위례","산성","남한산성입구","단대오거리","신흥","신촌","수진","모란"],"9호선":["개화","김포공항","공항시장","신방화","마곡나루","양천향교","가양","증미","등촌","염창","신목동","선유도","당산","국회의사당","여의도","샛강","노량진","노들","흑석","동작","구반포","신반포","고속터미널","사평","신논현","언주","선정릉","삼성중앙","봉은사","종합운동장","삼전","석촌고분","석촌","송파나루","한성백제","올림픽공원","둔촌오륜","중앙보훈병원"],"경의중앙선":["문산","파주","월롱","금촌","금릉","운정","야당","탄현","일산","풍산","백마","곡산","대곡","능곡","행신","강매","화전","수색","디지털미디어시티","가좌","홍대입구","서강대","공덕","효창공원앞","용산","이촌","서빙고","한남","옥수","응봉","왕십리","청량리","회기","중랑","상봉","망우","양원","구리","도농","양정","덕소","도심","팔당","운길산","양수","신원","국수","아신","오빈","양평","원덕","용문","지평"],"신분당선":["신사","논현","신논현","강남","양재","양재시민의숲","청계산입구","판교","정자","미금","동천","수지구청","성복","상현","광교중앙","광교"],"수인분당선":["청량리","회기","중랑","상봉","망우","구리","도농","양정","덕소","왕십리","서울숲","압구정로데오","강남구청","선정릉","선릉","한티","도곡","구룡","개포동","대모산입구","수서","복정","가천대","태평","모란","야탑","이매","서현","수내","정자","미금","오리","죽전","보정","구성","신갈","기흥","상갈","청명","영통","망포","매탄권선","수원시청","매교","수원","고색","오목천","어천","야목","사리","한대앞","중앙","고잔","초지","안산","신길온천","정왕","오이도","달월","월곶","소래포구","인천논현","호구포","남동인더스파크","원인재","연수","송도","학익","인하대","숭의","신포","인천"]};

  // Audio: NO BGM, only SFX
  let sfxGain=null;

  // === Sound settings (volume) ===
  const VOL_MUTED_KEY = "jesong_vol_muted";
  const VOL_MOVE_KEY = "jesong_vol_move_pct";
  const VOL_TRANSFER_KEY = "jesong_vol_transfer_pct";
  const VOL_ARRIVE_KEY = "jesong_vol_arrive_pct";

  let isMuted = false;
  let volMovePct = 1000;     // 0~2000
  let volTransferPct = 2500; // 0~5000
  let volArrivePct = 500;   // 0~1000

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function loadSoundSettings(){
    try{
      isMuted = (localStorage.getItem(VOL_MUTED_KEY)||"0") === "1";
      const m = parseInt(localStorage.getItem(VOL_MOVE_KEY)||"100",10);
      const t = parseInt(localStorage.getItem(VOL_TRANSFER_KEY)||"100",10);
      const a = parseInt(localStorage.getItem(VOL_ARRIVE_KEY)||"100",10);
      volMovePct = clamp(Number.isFinite(m)?m:1000, 0, 2000);
      volTransferPct = clamp(Number.isFinite(t)?t:2500, 0, 5000);
      volArrivePct = clamp(Number.isFinite(a)?a:500, 0, 1000);
    }catch(e){}
  }
  function saveSoundSettings(){
    try{
      localStorage.setItem(VOL_MUTED_KEY, isMuted ? "1" : "0");
      localStorage.setItem(VOL_MOVE_KEY, String(volMovePct));
      localStorage.setItem(VOL_TRANSFER_KEY, String(volTransferPct));
      localStorage.setItem(VOL_ARRIVE_KEY, String(volArrivePct));
    }catch(e){}
  }
  function volMove(){ return (isMuted ? 0 : (volMovePct/100)); }
  function volTransfer(){ return (isMuted ? 0 : (volTransferPct/100)); }
  function volArrive(){ return (isMuted ? 0 : (volArrivePct/100)); }

  function applyTransferGain(){
    try{
      if(transferGain) transferGain.gain.value = 0.01 * volTransfer();
    }catch(e){}
    try{
      // If <audio> fallback is used
      if(typeof sfxTransfer !== "undefined" && sfxTransfer) sfxTransfer.volume = 0.01 * volTransfer();
    }catch(e){}
  }

  loadSoundSettings();

  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(!sfxGain){ sfxGain = audioCtx.createGain(); sfxGain.gain.value=0.18; sfxGain.connect(audioCtx.destination); }
  }
  function startBGM(){ ensureAudio(); }
  function playTick(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    const f=audioCtx.createBiquadFilter();
    o.type='square'; o.frequency.value=1500;
    f.type='bandpass'; f.frequency.value=1100; f.Q.value=9;
    g.gain.value=0.0001;
    o.connect(f).connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.18*volMove(), now+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.06);
    o.stop(now+0.07);
    const o2=audioCtx.createOscillator();
    const g2=audioCtx.createGain();
    o2.type='sine'; o2.frequency.value=420;
    g2.gain.value=0.0001;
    o2.connect(g2).connect(sfxGain);
    o2.start(now+0.018);
    g2.gain.linearRampToValueAtTime(0.07*volMove(), now+0.03);
    g2.gain.exponentialRampToValueAtTime(0.0001, now+0.16);
    o2.stop(now+0.17);
  }
  function playDing(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.type='sine'; o.frequency.value=880;
    g.gain.value=0.0001;
    o.connect(g).connect(sfxGain);
    o.start(now);
    g.gain.linearRampToValueAtTime(0.14*volMove(), now+0.02);
    o.frequency.linearRampToValueAtTime(1175, now+0.14);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.42);
    o.stop(now+0.43);
  }
  function playFanfare(){
    ensureAudio();
    const now=audioCtx.currentTime;
    const g=audioCtx.createGain();
    g.gain.value=0.0001;
    g.connect(sfxGain);
    const o1=audioCtx.createOscillator();
    const o2=audioCtx.createOscillator();
    o1.type='square'; o2.type='square';
    o1.connect(g); o2.connect(g);
    const seq=[523.25,659.25,783.99,1046.5];
    const dur=0.10;
    o1.start(now); o2.start(now);
    seq.forEach((f,i)=>{ o1.frequency.setValueAtTime(f, now+i*dur); o2.frequency.setValueAtTime(f*0.5, now+i*dur); });
    g.gain.linearRampToValueAtTime(0.18*volArrive(), now+0.02);
    g.gain.linearRampToValueAtTime(0.12*volArrive(), now+0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, now+seq.length*dur+0.12);
    o1.stop(now+seq.length*dur+0.15);
    o2.stop(now+seq.length*dur+0.15);
  }

  function formatStation(s){ s=String(s).trim().replace(/역$/,''); return s+'역'; }
  function normalizeName(s){ return String(s).trim().replace(/역$/,'').replace(/\s+/g,''); }

  // Build line data (line-aware)
  function cleanLine(arr){
    const out=[];
    for(let i=0;i<arr.length;i++){
      const s=String(arr[i]).trim();
      if(!s) continue;
      if(out.length && out[out.length-1]===s) continue;
      out.push(s);
    }
    return out;
  }
  const subwayData={};
  const lineNames=Object.keys(DATA);
  for(const line of lineNames) subwayData[line]=cleanLine(DATA[line]);

  const lineIndex={};
  for(const line of lineNames){
    lineIndex[line]={};
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++) lineIndex[line][arr[i]]=i;
  }
  const stationLines=new Map();
  for(const line of lineNames){
    for(const st of subwayData[line]){
      if(!stationLines.has(st)) stationLines.set(st,new Set());
      stationLines.get(st).add(line);
    }
  }
  const getLinesOf=(st)=>stationLines.get(st)?Array.from(stationLines.get(st)):[];

  const getNextOnLine=(line,st,dir)=>{
    const idx=lineIndex[line][st];
    if(idx===undefined) return null;
    const arr=subwayData[line];
    const ni=idx+dir;
    if(ni<0||ni>=arr.length) return null;
    return arr[ni];
  };

  const allStations=Array.from(stationLines.keys());

  // Load saved movement settings
  try{
    const ms = parseInt(localStorage.getItem(MIN_STOPS_KEY)||'',10);
    const mx = parseInt(localStorage.getItem(MAX_STOPS_KEY)||'',10);
    if(Number.isFinite(ms)) minStops = Math.max(1, Math.min(99, ms));
    if(Number.isFinite(mx)) maxStops = Math.max(1, Math.min(99, mx));
    if(minStops>maxStops) [minStops,maxStops] = [maxStops,minStops];
  }catch(e){}


  // Layout (no x-averaging)
  const yStep=90, xStep=22, marginX=90, marginY=90;
  const pos=new Map();
  for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const y=marginY + li*yStep;
    const arr=subwayData[line];
    for(let i=0;i<arr.length;i++){
      const st=arr[i];
      const x=marginX + i*xStep;
      pos.set(line+'::'+st, {x:x,y:y});
    }
  }

  // Draw SVG
  
  // === Pause overlay (background -> pause, return -> require one tap) ===
  function initPauseOverlay(){
    const pauseOverlay = document.getElementById('pauseOverlay');
    const pausePlayBtn = document.getElementById('pausePlayBtn');
    if(!pauseOverlay || !pausePlayBtn) return;

    function showPause(){ pauseOverlay.classList.add('show'); pauseOverlay.setAttribute('aria-hidden','false'); }
    function hidePause(){ pauseOverlay.classList.remove('show'); pauseOverlay.setAttribute('aria-hidden','true'); }

    function setPaused(on){
      if(!window.__gameStarted) return;
      window.__paused = !!on;
      if(window.__paused){
        try{ stopTransferSound(); }catch(e){}
        try{ sessionStorage.setItem('jesong_bg', String(Date.now())); }catch(e){}
      }
    }

    function resumeFromPause(){
      try{ playTick(); }catch(e){}
      try{ primeAudio(); }catch(e){}
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
      window.__paused = false;
      try{ sessionStorage.removeItem('jesong_bg'); }catch(e){}
      hidePause();
    }

    pauseOverlay.addEventListener('click', (e)=>{ e.preventDefault(); resumeFromPause(); });
    pauseOverlay.addEventListener('touchend', (e)=>{ e.preventDefault(); resumeFromPause(); }, {passive:false});
    pausePlayBtn.addEventListener('click', (e)=>{ e.preventDefault(); resumeFromPause(); });
    pausePlayBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); resumeFromPause(); }, {passive:false});

    document.addEventListener('visibilitychange', ()=>{
      if(!window.__gameStarted) return;
      if(document.hidden){ setPaused(true); return; }
      const hadBg = window.__paused || !!sessionStorage.getItem('jesong_bg');
      if(hadBg){ window.__paused = true; showPause(); }
    });

    window.addEventListener('pagehide', ()=>{ setPaused(true); });
    window.addEventListener('blur', ()=>{ setPaused(true); });
    window.addEventListener('pageshow', ()=>{ 
      if(!window.__gameStarted) return;
      const hadBg = !!sessionStorage.getItem('jesong_bg');
      if(hadBg){ window.__paused = true; showPause(); }
    });
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initPauseOverlay);
  }else{
    initPauseOverlay();
  }


const viewport=document.getElementById('viewport');
  const map=document.getElementById('map');
  const gLines=document.getElementById('gLines');
  const gDots=document.getElementById('gDots');
  const token=document.getElementById('token');

  // --- Camera follow (stable): keep token centered without jitter (step-based + smoothing) ---
  const viewportEl = document.getElementById('viewport');

    let isAutoScroll = false;
// User can drag the view freely; after a short pause, camera returns to token center.
  if(viewportEl){
    const GRACE_MS = 1200; // time after last interaction before recenter
    const markUserPan = () => {
            if(isAutoScroll) return;
userPanUntil = Date.now() + GRACE_MS;
      if(recenterTimer) clearTimeout(recenterTimer);
      recenterTimer = setTimeout(() => {
        // Once user stops, snap back to token center (even if not animating)
        followTokenStable(true);
        setTimeout(()=>followTokenStable(true), 60);
      }, GRACE_MS + 20);
    };

    viewportEl.addEventListener('pointerdown', markUserPan, {passive:true});
    viewportEl.addEventListener('pointermove', markUserPan, {passive:true});
    window.addEventListener('pointerup', markUserPan, {passive:true});

    viewportEl.addEventListener('touchstart', markUserPan, {passive:true});
    viewportEl.addEventListener('touchmove', markUserPan, {passive:true});
    window.addEventListener('touchend', markUserPan, {passive:true});

    viewportEl.addEventListener('wheel', markUserPan, {passive:true});
  }

  let followPending = false;
  let userPanUntil = 0; // timestamp until which we don't auto-center (user is dragging)
  let recenterTimer = null;


  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  // Camera offset: user wants the person token to be **dead center**.
  const CAMERA_OFFSET_Y = 0;

  function scheduleInitialCenter(){
    // iOS Safari: run a few times after layout settles
    requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} });
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 120);
    setTimeout(()=>{ try{ followTokenStable(true); }catch(e){} }, 320);
  }

  // Snap camera to token immediately (used after teleport / after splash removal)
  function snapCameraToTokenNow(){
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }


  function followTokenStable(force){
    if(followPending) return;
    followPending = true;
    requestAnimationFrame(()=>{
      followPending = false;

      // overlays guard
      const startOverlayEl = document.getElementById('startOverlay');
      const settingsOverlayEl = document.getElementById('settingsOverlay');
      if(startOverlayEl){
        // While splash is fading out, allow camera to run so map becomes visible immediately.
        const cs = getComputedStyle(startOverlayEl);
        const fading = startOverlayEl.classList.contains('fadeOut');
        if(!fading && cs.display !== 'none' && cs.visibility !== 'hidden' && !startOverlayEl.classList.contains('hidden')) return;
      }


  // Snap camera to token immediately (useful right after setting station via input)
  function snapCameraToTokenNow(){
    // 2 frames only, once per teleport -> no noticeable stutter
    requestAnimationFrame(()=>{
      try{ followTokenStable(true); }catch(e){}
      requestAnimationFrame(()=>{
        try{ followTokenStable(true); }catch(e){}
      });
    });
  }
      if(settingsOverlayEl && settingsOverlayEl.classList.contains('show')) return;

      if(!viewportEl || !token) return;
      if(!force && Date.now() < userPanUntil) return;

      const vp = viewportEl.getBoundingClientRect();
      const tr = token.getBoundingClientRect();

      // token center in scroll-content coordinates
      const tokenCx = (tr.left - vp.left) + viewportEl.scrollLeft + tr.width/2;
      const tokenCy = (tr.top  - vp.top ) + viewportEl.scrollTop  + tr.height/2;

      const vpW = viewportEl.clientWidth;
      const vpH = viewportEl.clientHeight;

      const targetLeft = clamp(tokenCx - vpW/2, 0, viewportEl.scrollWidth - vpW);
      const targetTop  = clamp(tokenCy - vpH/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - vpH);

      isAutoScroll = true;
      viewportEl.scrollLeft = targetLeft;
      viewportEl.scrollTop  = targetTop;
      requestAnimationFrame(()=>{ isAutoScroll = false; });

      // one more settle frame for iOS timing
      requestAnimationFrame(()=>{
        const vp2 = viewportEl.getBoundingClientRect();
        const tr2 = token.getBoundingClientRect();
        const tokenCx2 = (tr2.left - vp2.left) + viewportEl.scrollLeft + tr2.width/2;
        const tokenCy2 = (tr2.top  - vp2.top ) + viewportEl.scrollTop  + tr2.height/2;
        const tL2 = clamp(tokenCx2 - viewportEl.clientWidth/2, 0, viewportEl.scrollWidth - viewportEl.clientWidth);
        const tT2 = clamp(tokenCy2 - viewportEl.clientHeight/2 + CAMERA_OFFSET_Y, 0, viewportEl.scrollHeight - viewportEl.clientHeight);
        isAutoScroll = true;
        viewportEl.scrollLeft = tL2;
        viewportEl.scrollTop  = tT2;
        requestAnimationFrame(()=>{ isAutoScroll = false; });
      });
    });
  }



  const hudG=document.getElementById('hudG');
  const HUD_OFFSET_Y = 68; // adjusted: closer to head, avoid clipping

  const hudLine1=document.getElementById('hudLine1');
  const hudLine2=document.getElementById('hudLine2');

  const LINE_COLORS={"1호선":"#1e88e5","2호선":"#2e7d32","3호선":"#f9a825","4호선":"#039be5","5호선":"#8e24aa","6호선":"#6d4c41","7호선":"#7b1fa2","8호선":"#d81b60","9호선":"#b59a00","경의중앙선":"#00838f","신분당선":"#c62828","수인분당선":"#f06292"};
  const lineColor=(n)=>LINE_COLORS[n]||"#ff4d6d";
  function svgEl(tag, attrs){
    const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  let maxLen=0;
  // Extra top padding so the token can be centered even when starting near the top lines.
  // (Otherwise scrollTop clamps to 0 and the token appears too low.)
  const PAD_TOP = 700;
  const PAD_BOTTOM = 900;
  const mapShift = document.getElementById('mapShift');
  for(const line of lineNames) maxLen=Math.max(maxLen, subwayData[line].length);
  const W=Math.max(1800, marginX + maxLen*xStep + 140);
  const H=Math.max(1100, marginY + lineNames.length*yStep + 140);
  map.setAttribute('width', String(W));
  map.setAttribute('height', String(H + PAD_TOP + PAD_BOTTOM));
  map.setAttribute('viewBox', '0 ' + (-PAD_TOP) + ' ' + W + ' ' + (H + PAD_TOP + PAD_BOTTOM));
  if(mapShift) mapShift.setAttribute('transform', 'translate(0,'+PAD_TOP+')');
for(let li=0; li<lineNames.length; li++){
    const line=lineNames[li];
    const arr=subwayData[line];
    let d='';
    for(let i=0;i<arr.length;i++){
      const p=pos.get(line+'::'+arr[i]);
      d += (i===0 ? ('M '+p.x+' '+p.y) : (' L '+p.x+' '+p.y));
    }
    gLines.appendChild(svgEl('path', {d:d, class:'lineStroke', stroke: lineColor(line)}));
    gLines.appendChild(svgEl('path', {d:d, class:'lineInner'}));
    const label=svgEl('text', {x:'16', y:String(marginY + li*yStep + 5), class:'label'});
    label.textContent=line;
    gLines.appendChild(label);
  }

  stationLines.forEach((set, st)=>{
    const lines=Array.from(set);
    if(lines.length<2) return;
    const pts=[];
    for(const l of lines){ const p=pos.get(l+'::'+st); if(p) pts.push(p); }
    pts.sort((a,b)=>a.y-b.y);
    if(pts.length<2) return;
    let d='M '+pts[0].x+' '+pts[0].y;
    for(let i=1;i<pts.length;i++) d += ' L '+pts[i].x+' '+pts[i].y;
    gLines.appendChild(svgEl('path', {d:d, class:'connector'}));
  });

  stationLines.forEach((set, st)=>{
    if(set.size<2) return;
    for(const line of set){
      const p=pos.get(line+'::'+st);
      if(!p) continue;
      gDots.appendChild(svgEl('circle', {cx:String(p.x), cy:String(p.y), r:'4', class:'stationDot'}));
    }
  });

  // Drag-to-pan
  (function enableDragPan(){
    let isDown=false, startX=0, startY=0, sl=0, st=0;
    viewport.addEventListener('pointerdown',(e)=>{
      isDown=true; viewport.setPointerCapture(e.pointerId);
      startX=e.clientX; startY=e.clientY;
      sl=viewport.scrollLeft; st=viewport.scrollTop;
    });
    viewport.addEventListener('pointermove',(e)=>{
      if(!isDown) return;
      viewport.scrollLeft = sl - (e.clientX - startX);
      viewport.scrollTop  = st - (e.clientY - startY);
    });
    viewport.addEventListener('pointerup',()=>{ isDown=false; });
    viewport.addEventListener('pointercancel',()=>{ isDown=false; });
    // Set initial scroll so default view stays the same (but you can drag down to see more top)
})();

  // Confetti
  const confCanvas=document.getElementById('confetti');
  const confCtx=confCanvas.getContext('2d');
  function resizeCanvasTo(el, canvas, ctx){
    const r=el.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w:r.width,h:r.height};
  }
  function burstConfettiOn(canvas, ctx, w, h){
    if(canvas.__raf) cancelAnimationFrame(canvas.__raf);
    const colors=["#ff4d6d","#ff85a2","#ffd6e0","#c9184a","#ffb3c1","#ffe3ea"];
    const pieces=[];
    const count=190;
    for(let i=0;i<count;i++) pieces.push({x:w*0.5,y:h*0.32,vx:(Math.random()-0.5)*9,vy:-Math.random()*11-7,g:0.22+Math.random()*0.18,w:4+Math.random()*5,h:3+Math.random()*5,a:Math.random()*Math.PI,va:(Math.random()-0.5)*0.25,c:colors[Math.floor(Math.random()*colors.length)],life:0,max:170+Math.random()*70});
    function tick(){
      ctx.clearRect(0,0,w,h);
      let alive=0;
      for(const p of pieces){
        p.life++; if(p.life<p.max) alive++;
        p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.va;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.a);
        ctx.globalAlpha=Math.max(0,1-p.life/p.max);
        ctx.fillStyle=p.c;
        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }
      ctx.globalAlpha=1;
      if(alive>0) canvas.__raf=requestAnimationFrame(tick);
      else ctx.clearRect(0,0,w,h);
    }
    tick();
  }
  resizeCanvasTo(viewport, confCanvas, confCtx);
  window.addEventListener('resize', ()=>{ resizeCanvasTo(viewport, confCanvas, confCtx); });

  // Movement helpers
  // Camera policy (IMPORTANT):
  // - Person token must stay *dead center* of the map viewport.
  // - User can drag/pan anytime; while dragging we don't fight.
  // - After dragging ends, we gently return to token.
  // We reuse the existing followTokenStable() logic above to avoid conflicting camera systems.
  function setTokenXY(x,y, smooth){
    token.setAttribute('transform','translate('+x+','+y+')');
    hudG.setAttribute('transform','translate('+x+','+(y-HUD_OFFSET_Y)+')');

    // If smooth=false (snap moments like first render / arrival), force-center once.
    // Otherwise keep centering every frame (but do not fight the user while dragging).
    try{ followTokenStable(!smooth); }catch(e){}
  }

  function setTokenAt(line, st, smooth){
    const p=pos.get(line+'::'+st);
    if(!p) return;
    setTokenXY(p.x,p.y,smooth);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
  function moveSegment(lineA, stA, lineB, stB){
    const a=pos.get(lineA+'::'+stA);
    const b=pos.get(lineB+'::'+stB);
    if(!a||!b) return Promise.resolve();
    const d=dist(a,b);
    const duration=Math.max(240, Math.min(650, d*6.5));
    const start=performance.now();
    let pausedTotal=0;
    let lastT=0;
    let wasPaused=false;
    return new Promise(res=>{
      function tick(t){
      // freeze animation progress while paused (no const reassign; accumulate paused time)
      if(window.__paused){
        if(!wasPaused){ wasPaused=true; lastT = t; }
        else { pausedTotal += (t - lastT); lastT = t; }
        requestAnimationFrame(tick);
        return;
      }
      if(wasPaused){ wasPaused=false; lastT = t; }

        const p=Math.min(1,(t-start-pausedTotal)/duration);
        const e=p<0.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
        setTokenXY(a.x+(b.x-a.x)*e, a.y+(b.y-a.y)*e, true);
        if(p<1) requestAnimationFrame(tick); else res();
      }
      requestAnimationFrame(tick);
    });
  }

  // Path generator: transfer only at interchange, stop at terminal, no reverse
  let minStops = 1;
  let maxStops = 25;
  let trueRandomMode = false;
  // Always start with true-random OFF on initial load
  trueRandomMode = false;
  try{ localStorage.setItem(TRUE_RANDOM_KEY, '0'); }catch(e){}  
  // ------------------------------
  // Pathfinding (최적 경로: 최소 이동역 + 불필요 환승 최소화)
  // ------------------------------
  // Build station adjacency (neighbors along each line)
  // IMPORTANT: We do NOT treat each line's station array as a single continuous chain when the line has branches.
  // Instead, we build an explicit adjacency list (stationNeighbors) and patch known branch-breaks so iOS/Android/PC all compute the same *real* shortest-stop routes.
  const stationNeighbors = new Map(); // station -> Set(neighborStation)
  const addEdge = (a,b)=>{
    if(!a||!b||a===b) return;
    if(!stationNeighbors.has(a)) stationNeighbors.set(a, new Set());
    if(!stationNeighbors.has(b)) stationNeighbors.set(b, new Set());
    stationNeighbors.get(a).add(b);
    stationNeighbors.get(b).add(a);
  };

  // 1) 기본: 각 호선의 인접 역(배열에서 바로 앞/뒤)만 edge로 추가
  lineNames.forEach(line => {
    const arr = subwayData[line];
    for(let i=1;i<arr.length;i++){
      const a = arr[i-1];
      const b = arr[i];
      // Branch patches for Line 1 (수도권 1호선은 분기가 많아서, 단일 배열을 그대로 잇으면 가짜 연결이 생김)
      if(line==='1호선'){
        // (1) 인천(경인선 종점) 다음에 가산디지털단지로 '점프'하는 가짜 연결 차단
        if((a==='인천' && b==='가산디지털단지') || (a==='가산디지털단지' && b==='인천')) continue;
        // (2) 1호선 데이터에 섞여있는 4호선 구간(금정→산본…) 가짜 연결 차단
        if((a==='금정' && b==='산본') || (a==='산본' && b==='금정')) continue;
        // (3) 오이도 이후 의왕으로 점프하는 가짜 연결 차단
        if((a==='오이도' && b==='의왕') || (a==='의왕' && b==='오이도')) continue;
      }
      addEdge(a,b);
    }
  });

  // 2) 1호선 분기 보정: 구로↔가산디지털단지(경부선 방향)는 실제 인접역인데,
  //    위의 원본 배열에선 '인천 지선' 뒤에 붙어있어 연결이 빠져있기 때문에 명시적으로 추가한다.
  addEdge('구로','가산디지털단지');


  function bfsDistances(start){
    const q=[start];
    const dist=new Map([[start,0]]);
    for(let qi=0; qi<q.length; qi++){
      const cur=q[qi];
      const d=dist.get(cur);
      const ns=stationNeighbors.get(cur);
      if(!ns) continue;
      ns.forEach(n=>{
        if(!dist.has(n)){
          dist.set(n,d+1);
          q.push(n);
        }
      });
    }
    return dist;
  }

  // Dijkstra with lexicographic cost: (stops, transfers)
  // State is (station, line). Move along same line adds 1 stop. Transfer changes line adds 1 transfer (0 stop).
  // We minimize **stops first**, and only if stops are equal, we minimize transfers.
  function bestRoute(startStation, endStation){
    const startLines = getLinesOf(startStation);
    const endLines = getLinesOf(endStation);
    if(!startLines.length || !endLines.length) return null;

    const pq=[];
    const key=(st,line)=>st+"@@"+line;
    const best=new Map();     // key -> [stops, transfers]
    const prev=new Map();     // key -> previous key
    const prevStep=new Map(); // key -> {st,line}

    function push(st,line,stops,transfers,fromKey){
      const k=key(st,line);
      const cur=best.get(k);
      if(cur){
        if(stops>cur[0] || (stops===cur[0] && transfers>=cur[1])) return;
      }
      best.set(k,[stops,transfers]);
      if(fromKey){
        prev.set(k,fromKey);
        prevStep.set(k,{st,line});
      }
      pq.push([stops,transfers,st,line]);
    }

    // init: allow starting on any line at startStation with 0/0
    startLines.forEach(line=>push(startStation,line,0,0,null));

    // poor man's priority queue: sort each pop (small graph so OK)
    while(pq.length){
      pq.sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
      const [stops,transfers,st,line]=pq.shift();
      const k=key(st,line);
      const cur=best.get(k);
      if(!cur || cur[0]!==stops || cur[1]!==transfers) continue;

      if(st===endStation && endLines.includes(line)){
        // reconstruct
        const path=[];
        let kk=k;
        while(kk){
          const [station, ln] = kk.split("@@");
          path.push({line: ln, st: station});
          kk = prev.get(kk);
        }
        path.reverse();
        // compress any accidental duplicates (same station+line)
        const out=[];
        for(const step of path){
          const last=out[out.length-1];
          if(last && last.st===step.st && last.line===step.line) continue;
          out.push(step);
        }
        return out;
      }

      // 1) move to neighbors along same line
      const idxMap = lineIndex[line];
      const arr = subwayData[line];
      const idx = idxMap ? idxMap[st] : undefined;
      if(idx!==undefined){
        if(idx>0){
          const n=arr[idx-1];
          push(n,line,stops+1,transfers,k);
        }
        if(idx<arr.length-1){
          const n=arr[idx+1];
          push(n,line,stops+1,transfers,k);
        }
      }

      // 2) transfer at same station
      const linesHere = getLinesOf(st).filter(l=>l!==line);
      for(const nl of linesHere){
        push(st,nl,stops,transfers+1,k);
      }
    }

    // If we couldn't reach with line-matching end, allow endStation on any line (still minimal)
    // Find best among endStation states
    let bestEndKey=null, bestCost=null;
    for(const ln of endLines){
      const k=key(endStation,ln);
      const c=best.get(k);
      if(c && (!bestCost || c[0]<bestCost[0] || (c[0]==bestCost[0] && c[1]<bestCost[1]))){
        bestCost=c; bestEndKey=k;
      }
    }
    if(!bestEndKey) return null;
    const path=[];
    let kk=bestEndKey;
    while(kk){
      const [station, ln] = kk.split("@@");
      path.push({line: ln, st: station});
      kk = prev.get(kk);
    }
    path.reverse();
    const out=[];
    for(const step of path){
      const last=out[out.length-1];
      if(last && last.st===step.st && last.line===step.line) continue;
      out.push(step);
    }
    return out;
  }

  // Compatibility alias: returns {path} where path is bestRoute (min stops, then min transfers)
  function dijkstraMinTransferStops(startStation, endStation){
    var p = bestRoute(startStation, endStation);
    return { path: p || [] };
  }


  // Pick a random destination within [minStops, maxStops] stops, then compute best route to it.
  
  // Pick a random destination within [minStops, maxStops] stops from start (by BFS distance),
  // then compute an optimal route prioritizing: (1) minimum transfers, (2) minimum stops.
  
  // Pick a destination whose *actual route stops* (path length - 1) falls within [minStops, maxStops].
  // Route is optimized by: (1) minimum transfers, (2) minimum stops.
  function planOptimalTrip(startStation){
    const dist = bfsDistances(startStation);
    const candidates = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d === undefined) continue;
      if(st !== startStation && d >= minStops && d <= maxStops) candidates.push(st);
    }

    // Shuffle candidates to keep it random but within constraints
    for(let i=candidates.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = candidates[i]; candidates[i]=candidates[j]; candidates[j]=tmp;
    }

    function routeStops(path){
      if(!path || !path.length) return 0;
      let s=0;
      for(let i=1;i<path.length;i++){ if(path[i].st !== path[i-1].st) s++; }
      return s;
    }

    // 1) Try strict: find a dest whose optimized route also fits the stop-range.
    for(const dest of candidates){
      const best = dijkstraMinTransferStops(startStation, dest);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops >= minStops && stops <= maxStops){
        return { dest, path };
      }
    }

    // 2) Fallback: if none fits (rare due to transfer-priority), pick the closest route <= maxStops
    let bestPick = null;
    for(const st of allStations){
      if(st === startStation) continue;
      const best = dijkstraMinTransferStops(startStation, st);
      const path = best && best.path ? best.path : [];
      const stops = routeStops(path);
      if(stops > 0 && stops <= maxStops){
        if(!bestPick || stops > bestPick.stops){
          bestPick = { dest: st, path, stops };
        }
      }
    }
    if(bestPick) return { dest: bestPick.dest, path: bestPick.path };

    // 3) Absolute fallback: any reachable station
    const reachable = [];
    for(const st of allStations){
      const d = dist.get(st);
      if(d !== undefined && st !== startStation) reachable.push(st);
    }
    const dest = reachable.length ? pick(reachable) : startStation;
    const best = dijkstraMinTransferStops(startStation, dest);
    return { dest, path: (best && best.path) ? best.path : [] };
  }

function randomWalkPath(startLine, startStation){
    let curLine = startLine;

    const idx = lineIndex[curLine][startStation];
    const arr = subwayData[curLine];

    // 종점에서 출발하면 무조건 종점 반대 방향으로 출발
    let dir;
    if (idx === 0) dir = 1;
    else if (idx === arr.length - 1) dir = -1;
    else dir = Math.random() < 0.5 ? -1 : 1;

    const stepsPlanned = randInt(minStops, maxStops);
    const path = [{ line: curLine, st: startStation }];
    let curSt = startStation;

    for (let step = 1; step <= stepsPlanned; step++) {
      const linesAtCur = getLinesOf(curSt);
      if (linesAtCur.length >= 2) {
        const remain = stepsPlanned - step + 1;
        const nearEnd = remain <= 6;
        const pTransfer = nearEnd ? 0.55 : 0.22;
        if (Math.random() < pTransfer) {
          const choices = linesAtCur.filter(l => l !== curLine);
          if (choices.length) {
            curLine = pick(choices);

            // 환승 후에도 종점이면 방향 다시 보정
            const newIdx = lineIndex[curLine][curSt];
            const newArr = subwayData[curLine];
            if (newIdx === 0) dir = 1;
            else if (newIdx === newArr.length - 1) dir = -1;
          }
        }
      }

      const nextSt = getNextOnLine(curLine, curSt, dir);
      if (!nextSt) break;

      curSt = nextSt;
      path.push({ line: curLine, st: curSt });
    }

    return path;
  }

  // Result overlay
  const overlay=document.getElementById('resultOverlay');
  const resultStation=document.getElementById('resultStation');
  const resultCount=document.getElementById('resultCount');
  const resultBox=document.getElementById('resultBox');
  const resultCanvas=document.getElementById('resultCanvas');
  const resultCtx=resultCanvas.getContext('2d');

  document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; });
  document.getElementById('searchBtn').addEventListener('click', ()=>{
    const station = (resultStation.textContent || '').trim(); // includes '역'
    const query = encodeURIComponent(station + " 데이트코스");
    window.open("https://search.naver.com/search.naver?query=" + query, "_blank");
  });

  function showResultOverlay(stationName,totalMoved){
    resultStation.textContent = formatStation(stationName);
    if(typeof totalMoved === 'number' && isFinite(totalMoved)){
      resultCount.textContent = '총 ' + totalMoved + '정거장 이동';
    } else {
      resultCount.textContent = '';
      // 찐랜덤 모드에서는 정거장 수를 표시하지 않음
    }
    overlay.style.display='flex';
    const dims = resizeCanvasTo(resultBox, resultCanvas, resultCtx);
    burstConfettiOn(resultCanvas, resultCtx, dims.w, dims.h);
    playFanfare();
  }

  // Init
  const startInput=document.getElementById('startInput');
  const goBtn=document.getElementById('goBtn');

  try{ localStorage.removeItem(LAST_STATION_KEY); }catch(e){}
  let currentStation = (allStations.includes(DEFAULT_FIRST_STATION) ? DEFAULT_FIRST_STATION : (allStations[0] || DEFAULT_FIRST_STATION));
let currentLine = getLinesOf(currentStation)[0] || lineNames[0];
  startInput.value=currentStation;
  // Force initial dead-center on the person token.
  setTokenAt(currentLine,currentStation,false);
    try{ snapCameraToTokenNow(); }catch(e){}
  // Ensure initial camera is centered on token (after layout settles)
  requestAnimationFrame(()=>requestAnimationFrame(()=>{ try{ followTokenStable(true); }catch(e){} }));

  scheduleInitialCenter();
  hudLine1.textContent=formatStation(currentStation);
  hudLine2.textContent='이동: 0정거장';
  let animating=false;

  // --- Transfer SFX (loop while transferring) ---
  let isTransferring = false;
  let audioPrimed = false;
  const sfxTransfer = document.getElementById('sfxTransfer');
  if(sfxTransfer){
    try{ sfxTransfer.src = TRANSFER_SFX_URL; sfxTransfer.load(); }catch(e){}
    try{ sfxTransfer.volume = 0.01 * volTransfer(); }catch(e){}
    try{ sfxTransfer.muted = false; }catch(e){}
  }
  if(sfxTransfer){
    sfxTransfer.loop = false;
    sfxTransfer.volume = 0.01;
    sfxTransfer.preload = 'auto';
  }

  function primeAudio(){
    // iOS: unlock audio on first user gesture
    if(audioPrimed) return;
    if(!sfxTransfer) { audioPrimed = true; return; }
    audioPrimed = true;
    try{
      sfxTransfer.pause();
      sfxTransfer.currentTime = 0;
      sfxTransfer.muted = true;
      const p = sfxTransfer.play();
      // once a play is allowed, immediately stop and unmute
      Promise.resolve(p).then(()=>{
        try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
        sfxTransfer.muted = false;
      }).catch(()=>{
        // even if it fails, keep unmuted; future plays after gesture may work
        sfxTransfer.muted = false;
      });
    }catch(e){
      try{ sfxTransfer.muted = false; }catch(_e){}
    }

  // Also prime WebAudio so iOS volume control via GainNode is guaranteed
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC && !audioCtx) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.01 * volTransfer();
      // kick off decode early
      if(!transferBuffer) loadTransferBuffer();
    }
  }catch(e){}
}

  // --- audio resume notice (reuse error toast style) ---
  function showResumeNotice(){ /* disabled */ }
  function hideResumeNotice(){ /* disabled */ }

// --- iOS background/foreground audio resume fix ---
  // iOS Safari/WebView may suspend or silently drop audio when the page is backgrounded.
  // When returning, sound can stay silent until a new user gesture.
  // We show a small notice (only when likely needed) and arm a one-time resume on the next touch/pointer.
  let _resumeArmed = false;
  let _bgAt = 0;

  function armAudioResumeOnNextGesture(){
    if(_resumeArmed) return;
    _resumeArmed = true;
    const resume = ()=>{
      _resumeArmed = false;
      try{ hideResumeNotice(); }catch(e){}

      // Try hard to re-unlock audio on iOS after background.
      // 1) Resume (or recreate) AudioContext
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        if(AC && !audioCtx) audioCtx = new AC();
        if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }
      }catch(e){}

      // 2) Prime HTMLAudio elements again (iOS can drop the media pipeline after long background)
      try{
        if(sfxTransfer){
          try{ sfxTransfer.pause(); }catch(e){}
          try{ sfxTransfer.currentTime = 0; }catch(e){}
          // Reload helps after long background
          try{ sfxTransfer.load(); }catch(e){}
          // A short play attempt (muted) can re-unlock
          try{
            const prevMuted = sfxTransfer.muted;
            sfxTransfer.muted = true;
            const pp = sfxTransfer.play();
            Promise.resolve(pp).then(()=>{
              try{ sfxTransfer.pause(); sfxTransfer.currentTime = 0; }catch(e){}
              sfxTransfer.muted = prevMuted;
            }).catch(()=>{ sfxTransfer.muted = prevMuted; });
          }catch(e){}
        }
      }catch(e){}

      // 3) Prime once more if needed
      try{ if(!audioPrimed){ primeAudio(); } }catch(e){}

      // If a transfer SFX was in progress when we backgrounded, restart it.
      try{ if(isTransferring){ startTransferSound(); } }catch(e){}
    };
    const opts = { once:true, capture:true, passive:true };
    document.addEventListener('pointerdown', resume, opts);
    document.addEventListener('touchstart', resume, opts);
    document.addEventListener('mousedown', resume, opts);
  }

  function onAppForeground(bgMs){
    // bgMs: how long we were in background (ms)
    let shouldShow = false;
    try{
      // If AudioContext is actually suspended, we definitely need a touch.
      if(audioCtx && audioCtx.state === 'suspended') shouldShow = true;
    }catch(e){}

    // Some iOS cases keep audioCtx 'running' but audio is still muted after long background.
    // If we were away for a while and the app is/was playing movement SFX, prompt a touch anyway.
    try{
      // After a long background (e.g., watching a video), iOS may drop audio even if AudioContext isn't 'suspended'.
      // In that case, always prompt for a single touch to re-unlock audio.
      if(!shouldShow && bgMs && bgMs >= 8000) shouldShow = true;
    }catch(e){}

    if(shouldShow){
      try{ showResumeNotice(); }catch(e){}
    }
    try{ armAudioResumeOnNextGesture(); }catch(e){}
  }

  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      _bgAt = Date.now();
    }else{
      const bgMs = _bgAt ? (Date.now() - _bgAt) : 0;
      _bgAt = 0;
      onAppForeground(bgMs);
    }
  });
  window.addEventListener('pageshow', ()=>{ onAppForeground(9000); });


  function startTransferSound(){
  if(!sfxTransfer) return;
  if(!audioPrimed) primeAudio();

  isTransferring = true;

  
  try{ applyTransferGain(); }catch(e){}
// Ensure WebAudio volume path exists (works reliably on iOS)
  let usingWebAudio = false;
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx && AC) audioCtx = new AC();
    if(audioCtx && audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }

    if(audioCtx){
      if(!transferGain){
        transferGain = audioCtx.createGain();
        transferGain.connect(audioCtx.destination);
      }
      transferGain.gain.value = 0.01 * volTransfer();
      usingWebAudio = true;
      // Kick off preload (don't await)
      try{ if(!transferBuffer) loadTransferBuffer(); }catch(e){}
    }
  }catch(e){}

  // Preferred: play decoded AudioBuffer from time 0 every time (no Safari currentTime quirks)
  if(usingWebAudio && transferBuffer){
    try{
      // stop any previous one-shot immediately
      try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
      transferOneShot = audioCtx.createBufferSource();
      transferOneShot.buffer = transferBuffer;
      transferOneShot.connect(transferGain);
      transferOneShot.start(0);
      transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
      return;
    }catch(e){
      // fall through to <audio> fallback
    }
  }



  // If WebAudio is available but the buffer isn't decoded yet, wait and then play (avoid iOS <audio> volume quirks)
  if(usingWebAudio && !transferBuffer){
    try{
      loadTransferBuffer().then(()=>{
        try{
          if(!isTransferring) return;
          if(!audioCtx || !transferGain || !transferBuffer) return;
          try{ if(transferOneShot) transferOneShot.stop(0); }catch(e){}
          transferOneShot = audioCtx.createBufferSource();
          transferOneShot.buffer = transferBuffer;
          transferOneShot.connect(transferGain);
          transferOneShot.start(0);
          transferOneShot.onended = ()=>{ try{ transferOneShot = null; }catch(e){} };
        }catch(e){}
      });
      return;
    }catch(e){}
  }
  // Fallback: <audio> element restart (only when WebAudio isn't available)
  if(usingWebAudio){ return; }

  // Fallback: <audio> element restart (less reliable on iOS, but better than silence)
  try{
    // If WebAudio isn't in use, apply element volume
    if(!usingWebAudio){ try{ sfxTransfer.volume = 0.01; }catch(e){} }

    sfxTransfer.muted = false;
    try{ sfxTransfer.loop = false; }catch(e){}
    try{ sfxTransfer.pause(); }catch(e){}

    const doPlay = ()=>{
      try{
        const p = sfxTransfer.play();
        if(p && p.catch) p.catch(()=>{});
      }catch(e){}
    };

    try{
      const onSeeked = ()=>{ doPlay(); };
      sfxTransfer.addEventListener('seeked', onSeeked, { once:true });
      try{ sfxTransfer.currentTime = 0; }catch(e){}
      setTimeout(doPlay, 100);
    }catch(e){
      try{ sfxTransfer.currentTime = 0; }catch(_){}
      doPlay();
    }
  }catch(e){}
}

  function stopTransferSound(){
  if(!sfxTransfer) return;
  isTransferring = false;

  // Stop WebAudio one-shot if used
  try{
    if(transferOneShot){
      try{ transferOneShot.stop(0); }catch(e){}
      transferOneShot = null;
    }
  }catch(e){}

  // Also stop <audio> fallback (harmless if not used)
  try{
    try{ sfxTransfer.loop = false; }catch(e){}
    sfxTransfer.pause();
    try{ sfxTransfer.currentTime = 0; }catch(e){}
  }catch(e){}
}
  
  // === Audio UI ===
  const audioBtn = document.getElementById('audioBtn');

  // Block all background interactions while any overlay is open
  const modalBlocker = document.getElementById('modalBlocker');
  if(modalBlocker){
    ['pointerdown','touchstart','touchmove','click'].forEach(ev=>{
      modalBlocker.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
    });
  }

  const audioOverlay = document.getElementById('audioOverlay');
  const audioBackdrop = document.getElementById('audioBackdrop');
  const audioCloseBtn = document.getElementById('audioCloseBtn');

  const volMoveRange = document.getElementById('volMoveRange');
  const volTransferRange = document.getElementById('volTransferRange');
  const volArriveRange = document.getElementById('volArriveRange');
  const audioMuteBtn = document.getElementById('audioMuteBtn');
  const audioResetBtn = document.getElementById('audioResetBtn');

  function syncAudioUI(){
    if(volMoveRange) volMoveRange.value = String(volMovePct);
    if(volTransferRange) volTransferRange.value = String(volTransferPct);
    if(volArriveRange) volArriveRange.value = String(volArrivePct);
    // keep icons stable; muted state is stored, no extra text
    try{ audioMuteBtn.style.opacity = isMuted ? '0.75' : '1'; }catch(e){}
  }


  function setOverlayState(isOpen){
    const open = !!isOpen;
    document.body.classList.toggle('overlayOpen', open);

    // Robust scroll lock (iOS-safe): freeze body at current scroll position
    const root = document.documentElement;
    const body = document.body;
    if(open){
      const y = window.scrollY || root.scrollTop || 0;
      body.dataset.scrollY = String(y);
      body.style.position = 'fixed';
      body.style.top = `-${y}px`;
      body.style.left = '0';
      body.style.right = '0';
      body.style.width = '100%';
      body.style.overflow = 'hidden';
      root.style.overflow = 'hidden';
    }else{
      const y = parseInt(body.dataset.scrollY || '0', 10) || 0;
      body.style.position = '';
      body.style.top = '';
      body.style.left = '';
      body.style.right = '';
      body.style.width = '';
      body.style.overflow = '';
      root.style.overflow = '';
      try{ delete body.dataset.scrollY; }catch(e){}
      window.scrollTo(0, y);
    }

    const mb = document.getElementById('modalBlocker');
    if(mb) mb.setAttribute('aria-hidden', open ? 'false' : 'true');
  }

  
  // Extra safety: prevent background scroll/drag on iOS while overlays are open
  // BUT allow gestures inside overlays (e.g., dragging range sliders)
  document.addEventListener('touchmove', (e)=>{
    if(!document.body.classList.contains('overlayOpen')) return;
    const t = e.target;
    const inOverlay = !!(t && (t.closest && (t.closest('#audioOverlay') || t.closest('#settingsOverlay'))));
    if(inOverlay) return; // allow slider drag, scrolling inside overlay content if any
    e.preventDefault();
  }, {passive:false});

  function openAudio(){
    if(!audioOverlay) return;
    syncAudioUI();
    audioOverlay.classList.add('show');
    setOverlayState(true);
    audioOverlay.setAttribute('aria-hidden','false');
  }
  function closeAudio(){
    if(!audioOverlay) return;
    audioOverlay.classList.remove('show');
    setOverlayState(false);
    audioOverlay.setAttribute('aria-hidden','true');
  }

  function previewMove(){ try{ playDing(); }catch(e){} }
  function previewArrive(){ try{ playFanfare(); }catch(e){} }
  function previewTransfer(){
    try{
      startTransferSound();
      setTimeout(()=>{ try{ stopTransferSound(); }catch(e){} }, 220);
    }catch(e){}
  }

  function onRangeCommit(kind){
    saveSoundSettings();
    // apply transfer gain immediately if it is currently active
    if(kind==='transfer'){ applyTransferGain(); }
    // preview once on release/change
    if(kind==='move') previewMove();
    else if(kind==='transfer') previewTransfer();
    else if(kind==='arrive') previewArrive();
  }

  if(audioBtn){
    audioBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); });
    audioBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); try{ playTick(); }catch(e){} openAudio(); }, {passive:false});
  }
  if(audioBackdrop){
    audioBackdrop.addEventListener('click', closeAudio);
  }
  if(audioCloseBtn){
    audioCloseBtn.addEventListener('click', closeAudio);
  }

  if(audioMuteBtn){
    audioMuteBtn.addEventListener('click', ()=>{ try{ playTick(); }catch(e){}
      isMuted = !isMuted;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
    });
  }

  if(audioResetBtn){
    audioResetBtn.addEventListener('click', ()=>{
      isMuted = false;
      volMovePct = 1000;
      volTransferPct = 2500;
      volArrivePct = 500;
      saveSoundSettings();
      applyTransferGain();
      syncAudioUI();
      // preview a tiny ding so user knows it worked
      try{ playDing(); }catch(e){}
    });
  }

  if(volMoveRange){
    volMoveRange.addEventListener('input', ()=>{ volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 2000); });
    volMoveRange.addEventListener('change', ()=>{ volMovePct = clamp(parseInt(volMoveRange.value,10)||0, 0, 2000); onRangeCommit('move'); });
  }
  if(volTransferRange){
    volTransferRange.addEventListener('input', ()=>{ volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000); });
    volTransferRange.addEventListener('change', ()=>{ volTransferPct = clamp(parseInt(volTransferRange.value,10)||0, 0, 5000); onRangeCommit('transfer'); });
  }
  if(volArriveRange){
    volArriveRange.addEventListener('input', ()=>{ volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 1000); });
    volArriveRange.addEventListener('change', ()=>{ volArrivePct = clamp(parseInt(volArriveRange.value,10)||0, 0, 1000); onRangeCommit('arrive'); });
  }

  // Initial UI sync (values already loaded)
  syncAudioUI();


  // Settings UI (min/max stops)
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsBackdrop = document.getElementById('settingsBackdrop');
  const minStopsInputEl = document.getElementById('minStopsInput');
  const maxStopsInputEl = document.getElementById('maxStopsInput');
  const trueRandomToggle = document.getElementById('trueRandomToggle');
  const settingsOk = document.getElementById('settingsOk');
  const settingsCancel = document.getElementById('settingsCancel');

  function updateTrueRandomUI(){
    const on = !!(trueRandomToggle && trueRandomToggle.checked);

    // Fully disable the min/max range controls when True Random is ON
    const stopsRowEl = document.getElementById('stopsRow');
    if(stopsRowEl){
      stopsRowEl.classList.toggle('controlsDisabled', on);
      stopsRowEl.setAttribute('aria-disabled', on ? 'true' : 'false');
    }

    // Also set disabled attributes for accessibility
    [minStopsInputEl, maxStopsInputEl].forEach(el=>{
      if(!el) return;
      el.disabled = on;
      el.style.opacity = on ? '0.45' : '1';
    });
    document.querySelectorAll('.stepBtn').forEach(btn=>{
      if(!btn) return;
      btn.disabled = on;
      btn.style.opacity = on ? '0.35' : '1';
    });

    // Slightly dim the stop row (visual)
    if(stopsRowEl){ stopsRowEl.style.opacity = on ? '0.55' : '1'; }
  }

  function updateStartInputForMode(){
    try{
      if(trueRandomMode){
        startInput.classList.add('trueRandomInput');
        startInput.value = '찐랜덤 모드';
        startInput.setAttribute('readonly','');
        // prevent keyboard / touches
        startInput.style.pointerEvents = 'none';
      }else{
        startInput.classList.remove('trueRandomInput');
        startInput.removeAttribute('readonly');
        startInput.style.pointerEvents = 'auto';
        // restore to last/ current station name
        startInput.value = currentStation || '';
      }
    }catch(e){}
  }

  function clampInt(v, lo, hi){
    v = parseInt(String(v||'').trim(), 10);
    if(!Number.isFinite(v)) return lo;
    return Math.max(lo, Math.min(hi, v));
  }
  function openSettings(){
    if(animating) return;
    minStopsInputEl.value = String(minStops);
    maxStopsInputEl.value = String(maxStops);
    if(trueRandomToggle){
      trueRandomToggle.checked = !!trueRandomMode;
    }
    updateTrueRandomUI();
    settingsOverlay.classList.add('show');
    setOverlayState(true);
    settingsOverlay.setAttribute('aria-hidden','false');
    try{ playTick(); }catch(e){}
    setTimeout(()=>{ try{ (trueRandomMode ? settingsOk : minStopsInputEl).focus(); }catch(e){} }, 40);
  }
  function closeSettings(){
    settingsOverlay.classList.remove('show');
    setOverlayState(false);
    settingsOverlay.setAttribute('aria-hidden','true');
  }
  function applySettings(){
    var minEl = document.getElementById('minStopsInput');
    var maxEl = document.getElementById('maxStopsInput');

    var newMin = parseInt(minEl && minEl.value ? minEl.value : '', 10);
    var newMax = parseInt(maxEl && maxEl.value ? maxEl.value : '', 10);

    if(!isFinite(newMin)) newMin = 6;
    if(!isFinite(newMax)) newMax = 25;

    newMin = Math.min(99, Math.max(1, newMin));
    newMax = Math.min(99, Math.max(1, newMax));

    if(newMax < newMin){
      newMax = newMin;
      if(maxEl) maxEl.value = String(newMax);
    }

    // Save true random toggle
    if(trueRandomToggle){
      trueRandomMode = !!trueRandomToggle.checked;
      try{ localStorage.setItem(TRUE_RANDOM_KEY, trueRandomMode ? '1' : '0'); }catch(e){}
    }

    if(!trueRandomMode){
      minStops = newMin;
      maxStops = newMax;
      try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
      try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
    }

    updateTrueRandomUI();
    updateStartInputForMode();
    closeSettings();
    try{ playDing(); }catch(e){}
  }

  if(settingsBtn){
    settingsBtn.addEventListener('click', openSettings);
    settingsBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); openSettings(); }, {passive:false});
  }
  if(settingsBackdrop){
    settingsBackdrop.addEventListener('click', closeSettings);
  }
  if(settingsCancel){
    settingsCancel.addEventListener('click', closeSettings);
  }
  if(settingsOk){
    settingsOk.addEventListener('click', applySettings);
  }

  if(trueRandomToggle){
    trueRandomToggle.addEventListener('change', ()=>{ try{ playTick(); }catch(e){} try{ const tr=document.getElementById('trueRandomTrack'); if(tr) tr.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} updateTrueRandomUI(); });

    // Make only the switch itself clickable (avoid row-wide label hit areas)
    const trueRandomTrack = document.getElementById('trueRandomTrack');
    const syncSwitchAria = ()=>{ try{ trueRandomTrack.setAttribute('aria-checked', trueRandomToggle.checked ? 'true':'false'); }catch(e){} };
    syncSwitchAria();
    if(trueRandomTrack){
      trueRandomTrack.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        trueRandomToggle.checked = !trueRandomToggle.checked;
        syncSwitchAria();
        trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
      });
      trueRandomTrack.addEventListener('keydown', (e)=>{
        if(e.key==='Enter' || e.key===' '){
          e.preventDefault();
          trueRandomToggle.checked = !trueRandomToggle.checked;
          syncSwitchAria();
          trueRandomToggle.dispatchEvent(new Event('change', {bubbles:true}));
        }
      });
    }

  }

  // Apply initial mode effects to the start input (after we have UI refs).
  updateStartInputForMode();

  // Step buttons
  document.querySelectorAll('.stepBtn').forEach(btn=>{
    const doStep = ()=>{
      if(btn.disabled) return;
      if(typeof trueRandomMode!=='undefined' && trueRandomMode) return;
      const which = btn.getAttribute('data-step');
      const delta = parseInt(btn.getAttribute('data-delta')||'0',10) || 0;
      if(which === 'min'){
        const next = clampInt(minStopsInputEl.value,1,99) + delta;
        minStopsInputEl.value = String(clampInt(next,1,99));
      } else {
        const next = clampInt(maxStopsInputEl.value,1,99) + delta;
        maxStopsInputEl.value = String(clampInt(next,1,99));
      }
      try{ playTick(); }catch(e){}
    };

    // Prevent double-tap / bubbling into the map viewport
    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); });
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); e.stopPropagation(); doStep(); }, {passive:false});
    btn.addEventListener('dblclick', (e)=>{ e.preventDefault(); });
  });

  // Enter = apply, ESC = close
  settingsOverlay && settingsOverlay.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape') closeSettings();
    if(e.key === 'Enter') applySettings();
  });


  function findStartStation(input){
    const q=normalizeName(input);
    for(const s of allStations) if(normalizeName(s)===q) return s;
    return null;
  }

  async function animatePath(path){
    let moved=0;
    for(let i=0;i<path.length;i++){
      const cur=path[i];
      hudLine1.textContent=formatStation(cur.st);
      hudLine2.textContent='이동: '+moved+'정거장';
      if(i===0){
        // Teleport to start: snap camera immediately so it follows from the first segment
        setTokenAt(cur.line,cur.st,false);
        try{ snapCameraToTokenNow(); }catch(e){}
        await sleep(180);
        continue;
      }
      const prev=path[i-1];
            if(prev.line !== cur.line){ startTransferSound(); }
      await moveSegment(prev.line,prev.st,cur.line,cur.st);
      if(prev.line !== cur.line){ stopTransferSound(); }

      // Count only actual station-to-station moves. Transfers at the same station do NOT count as a stop.
      if(prev.st !== cur.st){
        moved++;
      }
      hudLine2.textContent='이동: '+moved+'정거장';

      playTick();
      await sleep(160);
      const remain=(path.length-1)-i;
      const t=Math.max(0,6-remain);
      const jitter=Math.floor(Math.random()*180);
      const curve=t===0 ? 1 : (1 + 0.14*t*t);
      let ms=(380 + jitter)*curve;
      if(remain<=2) ms += 260;
      await sleep(ms);
    }
    return moved;
  }

  async function trueRandomWarpTo(destStation){
    // Warp around randomly for a fixed duration, then stop at destination.
    // NOTE: This is purely for fun (찐랜덤), so it doesn't follow line order.
    const DURATION_MS = 16500; // 총 16.5초 워프 애니메이션 (쪼는맛 있게 조금 더 길게)
    const WARPS = 24;          // 점프 횟수 (너무 빽빽하지 않게)

    // Create a slowdown schedule whose intervals sum to DURATION_MS.
    // Start fast, end slow (quadratic ease-out style).
    const minInterval = 160;
    const maxInterval = 1150;
    const raw = [];
    let rawSum = 0;
    for(let i=0;i<WARPS;i++){
      const t = (WARPS<=1) ? 1 : (i/(WARPS-1));
      const e = Math.pow(t, 1.7); // 부드러운 감속 (초반 너무 빠른 워프 방지)
      const v = minInterval + (maxInterval - minInterval) * e;
      raw.push(v);
      rawSum += v;
    }
    const scale = DURATION_MS / rawSum;

    for(let i=0;i<WARPS;i++){
      const isLast = (i === WARPS-1);
      // pick a random station (avoid dest until the very last warp)
      let st = destStation;
      if(!isLast){
        for(let tries=0; tries<10; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== destStation){ st = cand; break; }
        }
      }

      const lines = getLinesOf(st);
      const ln = lines.length ? lines[Math.floor(Math.random()*lines.length)] : (lineNames[0]||'');
      setTokenAt(ln, st, false);
      // Keep station name updating (including final stop). Only the 2nd line stays uniform.
      hudLine1.textContent = formatStation(st);
      hudLine2.textContent = '워프중..';
      try{ playTick(); }catch(e){}

      // scaled interval + tiny randomness (kept small so total stays ~16.5s)
      const jitter = isLast ? 0 : (Math.random()*40);
      const delay = Math.max(20, Math.floor(raw[i] * scale + jitter));
      await sleep(delay);
    }

    // Ensure camera is centered once we land.
    try{ snapCameraToTokenNow(); }catch(e){}
    // 살짝 정착하는 느낌
    await sleep(180);
  }

  async function finale(targetStation,totalMoved){
    // Keep HUD consistent at arrival (no '워프중..' flash).
    try{ hudLine1.textContent = formatStation(targetStation); }catch(e){}
    try{
      if(typeof totalMoved === 'number'){
        hudLine2.textContent = '이동: ' + totalMoved + '정거장';
      } else {
        hudLine2.textContent = '워프중..';
      }
    }catch(e){}
    stopTransferSound();
    playDing();
    const dims = resizeCanvasTo(viewport, confCanvas, confCtx);
    burstConfettiOn(confCanvas, confCtx, dims.w, dims.h);
    showResultOverlay(targetStation,totalMoved);
  }

  async function onStart(){
    if(animating) return;
    if(trueRandomMode){
      // True random: pick a random start AND destination from the whole map.
      animating=true; goBtn.disabled=true;
      primeAudio();
      startBGM();
      overlay.style.display='none';

      // Pick random start
      let startStation = currentStation;
      if(allStations.length){
        startStation = allStations[Math.floor(Math.random()*allStations.length)] || currentStation;
      }
      currentStation = startStation;
      currentLine = (getLinesOf(currentStation)[0] || lineNames[0]);
      setTokenAt(currentLine, currentStation, false);
      try{ snapCameraToTokenNow(); }catch(e){}
      try{ hudLine1.textContent = formatStation(currentStation); }catch(e){}
      try{ hudLine2.textContent = '워프중..'; }catch(e){}

      // Pick random destination (not the same as start)
      let dest = startStation;
      if(allStations.length>1){
        for(let tries=0; tries<40; tries++){
          const cand = allStations[Math.floor(Math.random()*allStations.length)];
          if(cand && cand !== startStation){ dest = cand; break; }
        }
      }

      await trueRandomWarpTo(dest);
      // Hold on the destination briefly so it doesn't feel like it "pops".
      await sleep(650);
      await finale(dest, null);
      currentStation=dest;
      currentLine=getLinesOf(currentStation)[0] || currentLine;
      try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
      animating=false; goBtn.disabled=false;
      return;
    }

    const startStation=findStartStation(startInput.value);
    if(!startStation){ showErr('출발역 오타! 예: 혜화, 동대문, 서울역, 강남'); return; }


    // If the user sets a stop range that is impossible from this start station (in terms of
    // *minimum-stops* graph distance), clamp it and clearly 안내한다.
    try{
      const dist = bfsDistances(startStation);
      let maxPossible = 0;
      dist.forEach((v)=>{ if(v>maxPossible) maxPossible = v; });
      if(Number.isFinite(maxPossible) && maxPossible > 0){
        if(maxStops > maxPossible){
          maxStops = maxPossible;
          if(minStops > maxStops) minStops = maxStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('출발역 기준 최대 이동 가능 정거장 수(' + maxPossible + '역)를 적용했습니다.');
        } else if(minStops > maxPossible){
          minStops = maxPossible;
          if(maxStops < minStops) maxStops = minStops;
          try{ localStorage.setItem(MIN_STOPS_KEY, String(minStops)); }catch(e){}
          try{ localStorage.setItem(MAX_STOPS_KEY, String(maxStops)); }catch(e){}
          showErr('출발역 기준 최대 이동 가능 정거장 수(' + maxPossible + '역)를 적용했습니다.');
        }
      }
    }catch(e){}

    animating=true; goBtn.disabled=true;
    primeAudio();
    startBGM();
    overlay.style.display='none';
    currentStation=startStation;
    currentLine=getLinesOf(currentStation)[0] || lineNames[0];
    const plan = planOptimalTrip(currentStation);
    const path = (plan && plan.path) ? plan.path : [];
    if(!path.length || !path[0] || !path[0].st){
      alert('경로를 찾지 못했어 ㅠㅠ (출발/도착 역을 다시 확인해줘)');
      animating=false; goBtn.disabled=false;
      return;
    }

    // update currentLine to the route's starting line (could change if station belongs to multiple lines)
    currentLine = (path[0] && path[0].line) ? path[0].line : currentLine;
    const last=path[path.length-1];
    const moved=await animatePath(path);
    // Arrived: pause briefly before showing the result so it feels intentional.
    hudLine1.textContent = formatStation(last.st);
    hudLine2.textContent = '이동: ' + moved + '정거장';
    await sleep(650);
    await finale(last.st,moved);
    currentStation=last.st;
    currentLine=last.line;
    try{ localStorage.setItem(LAST_STATION_KEY, currentStation); }catch(e){}
    animating=false; goBtn.disabled=false;
  }

  goBtn.addEventListener('click', onStart);
  goBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
})();

// === VisualViewport height fix (prevents top blank on mobile Safari) ===
(function setupVvh(){
  const setVvh = () => {
    const vv = window.visualViewport;
    const h = vv ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--vvh', (h * 0.01) + 'px');
  };
  setVvh();
  window.addEventListener('resize', setVvh);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', setVvh);
})();</script>

<script>
// Prevent text selection, callout, and dragging (mobile friendly)
(()=>{
  const prevent = (e)=>{ try{ e.preventDefault(); }catch(_){} };
  document.addEventListener('selectstart', prevent, {passive:false});
  document.addEventListener('dragstart', prevent, {passive:false});
  document.addEventListener('contextmenu', prevent, {passive:false});
  document.addEventListener('gesturestart', prevent, {passive:false});
  document.addEventListener('dblclick', (e)=>{
    // avoid double-tap selection on some browsers
    prevent(e);
  }, {passive:false});
})();
</script>

  <div id="resumeNotice">화면을 한 번 터치하면 소리가 다시 재생됩니다.</div>
  <div id="modalBlocker" class="modalBlocker" aria-hidden="true"></div>

  <div id="pauseOverlay" class="pauseOverlay" aria-hidden="true">
    <div class="pauseCard">
      <div class="pauseTitle">일시정지됨</div>
      <button id="pausePlayBtn" class="pausePlayBtn" type="button" aria-label="재개">
        <span class="tri"></span>
      </button>
      <div class="pauseHint">화면을 터치하면 재개됩니다</div>
    </div>
  </div>

</body>
</html>
